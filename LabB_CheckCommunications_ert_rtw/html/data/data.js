var DataHeading = 'Code'; var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":false},"build":"LabB_CheckCommunications","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: ert_main.c\n *\n * Code generated for Simulink model 'LabB_CheckCommunications'.\n *\n * Model version                  : 18.0\n * Simulink Coder version         : 25.2 (R2025b) 28-Jul-2025\n * C/C++ source code generated on : Wed Jan 21 10:38:09 2026\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Atmel->AVR\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"LabB_CheckCommunications.h\"\n#include \"rtwtypes.h\"\n#include \"xcp.h\"\n#include \"ext_mode.h\"\n#include \"MW_target_hardware_resources.h\"\n\nvolatile int IsrOverrun = 0;\nstatic boolean_T OverrunFlag = 0;\nvoid rt_OneStep(void)\n{\n  extmodeSimulationTime_T currentTime = (extmodeSimulationTime_T) 0;\n\n  /* Check for overrun. Protect OverrunFlag against preemption */\n  if (OverrunFlag++) {\n    IsrOverrun = 1;\n    OverrunFlag--;\n    return;\n  }\n\n#ifndef _MW_ARDUINO_LOOP_\n\n  sei();\n\n#endif;\n\n  currentTime = (extmodeSimulationTime_T)\n    LabB_CheckCommunications_M->Timing.clockTick0;\n  LabB_CheckCommunications_step();\n\n  /* Get model outputs here */\n\n  /* Trigger External Mode event */\n  extmodeEvent(0, currentTime);\n\n#ifndef _MW_ARDUINO_LOOP_\n\n  cli();\n\n#endif;\n\n  OverrunFlag--;\n}\n\nextern void rtIOStreamResync();\nvolatile boolean_T stopRequested;\nvolatile boolean_T runModel;\nint main(void)\n{\n  float modelBaseRate = 0.01;\n  float systemClock = 0;\n  extmodeErrorCode_T errorCode = EXTMODE_SUCCESS;\n\n  /* Initialize variables */\n  stopRequested = false;\n  runModel = false;\n  init();\n  MW_Arduino_Init();\n  rtmSetErrorStatus(LabB_CheckCommunications_M, 0);\n\n  /* Set Final Simulation Time in Ticks */\n  errorCode = extmodeSetFinalSimulationTime((extmodeSimulationTime_T) -1);\n\n  /* Parse External Mode command line arguments */\n  errorCode = extmodeParseArgs(0, NULL);\n  if (errorCode != EXTMODE_SUCCESS) {\n    return (errorCode);\n  }\n\n  LabB_CheckCommunications_initialize();\n  cli();\n  sei();\n\n  /* External Mode initialization */\n  errorCode = extmodeInit(LabB_CheckCommunications_M->extModeInfo,\n    (extmodeSimulationTime_T *)rteiGetPtrTFinalTicks\n    (LabB_CheckCommunications_M->extModeInfo));\n  if (errorCode != EXTMODE_SUCCESS) {\n    /* Code to handle External Mode initialization errors\n       may be added here */\n  }\n\n  if (errorCode == EXTMODE_SUCCESS) {\n    /* Wait until a Start or Stop Request has been received from the Host */\n    extmodeWaitForHostRequest(EXTMODE_WAIT_FOREVER);\n    if (extmodeStopRequested()) {\n      rtmSetStopRequested(LabB_CheckCommunications_M, true);\n    }\n  }\n\n  cli();\n  configureArduinoAVRTimer();\n  runModel =\n    !extmodeSimulationComplete()&& !extmodeStopRequested()&&\n    !rtmGetStopRequested(LabB_CheckCommunications_M);\n\n#ifndef _MW_ARDUINO_LOOP_\n\n  sei();\n\n#endif;\n\n  XcpStatus lastXcpState = xcpStatusGet();\n  sei();\n  while (runModel) {\n    /* Run External Mode background activities */\n    errorCode = extmodeBackgroundRun();\n    if (errorCode != EXTMODE_SUCCESS && errorCode != EXTMODE_EMPTY) {\n      /* Code to handle External Mode background task errors\n         may be added here */\n    }\n\n    stopRequested = !(\n                      !extmodeSimulationComplete()&& !extmodeStopRequested()&&\n                      !rtmGetStopRequested(LabB_CheckCommunications_M));\n    runModel = !(stopRequested);\n    if (stopRequested)\n      disable_rt_OneStep();\n    if (lastXcpState==XCP_CONNECTED && xcpStatusGet()==XCP_DISCONNECTED)\n      rtIOStreamResync();\n    lastXcpState = xcpStatusGet();\n    MW_Arduino_Loop();\n    MW_Modbus_Slave_Poll();\n  }\n\n  /* Terminate model */\n  LabB_CheckCommunications_terminate();\n\n  /* External Mode reset */\n  extmodeReset();\n  cli();\n  return 0;\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"LabB_CheckCommunications.c","type":"source","group":"model","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: LabB_CheckCommunications.c\n *\n * Code generated for Simulink model 'LabB_CheckCommunications'.\n *\n * Model version                  : 18.0\n * Simulink Coder version         : 25.2 (R2025b) 28-Jul-2025\n * C/C++ source code generated on : Wed Jan 21 10:38:09 2026\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Atmel->AVR\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"LabB_CheckCommunications.h\"\n#include \"LabB_CheckCommunications_private.h\"\n#include <math.h>\n#include \"rt_nonfinite.h\"\n#include \"rtwtypes.h\"\n#include <string.h>\n#include \"rt_defines.h\"\n\n/* Block signals (default storage) */\nBlockIO_LabB_CheckCommunication LabB_CheckCommunications_B;\n\n/* Block states (default storage) */\nD_Work_LabB_CheckCommunications LabB_CheckCommunications_DWork;\n\n/* Real-time model */\nstatic RT_MODEL_LabB_CheckCommunicatio LabB_CheckCommunications_M_;\nRT_MODEL_LabB_CheckCommunicatio *const LabB_CheckCommunications_M =\n  &LabB_CheckCommunications_M_;\nreal_T rt_atan2d_snf(real_T u0, real_T u1)\n{\n  real_T y;\n  int16_T tmp;\n  int16_T tmp_0;\n  if (rtIsNaN(u0) || rtIsNaN(u1)) {\n    y = (rtNaN);\n  } else if (rtIsInf(u0) && rtIsInf(u1)) {\n    if (u0 > 0.0) {\n      tmp = 1;\n    } else {\n      tmp = -1;\n    }\n\n    if (u1 > 0.0) {\n      tmp_0 = 1;\n    } else {\n      tmp_0 = -1;\n    }\n\n    y = atan2(tmp, tmp_0);\n  } else if (u1 == 0.0) {\n    if (u0 > 0.0) {\n      y = RT_PI / 2.0;\n    } else if (u0 < 0.0) {\n      y = -(RT_PI / 2.0);\n    } else {\n      y = 0.0;\n    }\n  } else {\n    y = atan2(u0, u1);\n  }\n\n  return y;\n}\n\nreal_T rt_roundd_snf(real_T u)\n{\n  real_T y;\n  if (fabs(u) < 4.503599627370496E+15) {\n    if (u >= 0.5) {\n      y = floor(u + 0.5);\n    } else if (u > -0.5) {\n      y = u * 0.0;\n    } else {\n      y = ceil(u - 0.5);\n    }\n  } else {\n    y = u;\n  }\n\n  return y;\n}\n\n/* Model step function */\nvoid LabB_CheckCommunications_step(void)\n{\n  real_T rtb_Switch;\n  real_T u0;\n  int16_T out[3];\n  int16_T rtb_Abs;\n  uint8_T tmp;\n\n  /* MATLABSystem: '<S1>/M2V3 Left Connector 18, 19' */\n  /*         %% Define output properties */\n  /* 'Encoder_arduino:136' num = 0; */\n  /* 'Encoder_arduino:140' num = 1; */\n  /* 'Encoder_arduino:121' y = int32(0); */\n  /* 'Encoder_arduino:122' if coder.target('Rtw') */\n  /*  Call: int enc_output(int enc) */\n  /* 'Encoder_arduino:124' y = coder.ceval('enc_output', obj.Encoder); */\n  LabB_CheckCommunications_B.M2V3LeftConnector1819 = enc_output(1.0);\n\n  /* Gain: '<S3>/Gain' incorporates:\n   *  Constant: '<S1>/angle offset'\n   *  DiscreteIntegrator: '<S1>/angular velocity to angle'\n   *  Sum: '<S1>/Sum'\n   *  Sum: '<S1>/Sum4'\n   */\n  LabB_CheckCommunications_B.Gain =\n    ((LabB_CheckCommunications_P.angleoffset_Value +\n      LabB_CheckCommunications_DWork.angularvelocitytoangle_DSTATE) +\n     LabB_CheckCommunications_P.angleoffset_Value) *\n    LabB_CheckCommunications_P.Gain_Gain;\n\n  /* MATLABSystem: '<S1>/Accelerometer' */\n  /*  initialize output to a single (float) with the value zero */\n  /* 'soMPU6050Accel:40' out = int16(zeros(3,1)); */\n  /* 'soMPU6050Accel:41' if (coder.target('Rtw')) */\n  /*  done only for code gen */\n  /* 'soMPU6050Accel:42' coder.cinclude('MPU6050wrapper.h'); */\n  /*  get the current value of the sensor */\n  /* 'soMPU6050Accel:44' coder.ceval('MPU6050Accel_Read', coder.wref(out)); */\n  MPU6050Accel_Read(&out[0]);\n\n  /* Gain: '<S2>/Gain' incorporates:\n   *  Constant: '<S1>/accelerometer angle bias'\n   *  Constant: '<S1>/angle offset'\n   *  DataTypeConversion: '<S1>/Data Type Conversion1'\n   *  DataTypeConversion: '<S1>/Data Type Conversion2'\n   *  Gain: '<S1>/raw y acceleration to g_y'\n   *  Gain: '<S1>/raw z acceleration to g_z'\n   *  MATLABSystem: '<S1>/Accelerometer'\n   *  Sum: '<S1>/Sum1'\n   *  Sum: '<S1>/Sum3'\n   *  Trigonometry: '<S1>/g_y and g_z to angle in radians'\n   * */\n  /*  pull the data appart */\n  /* 'soMPU6050Accel:49' xaccel = out(1); */\n  /* 'soMPU6050Accel:50' yaccel = out(2); */\n  /* 'soMPU6050Accel:51' zaccel = out(3); */\n  LabB_CheckCommunications_B.Gain_j = ((rt_atan2d_snf\n    (LabB_CheckCommunications_P.rawyaccelerationtog_y_Gain * (real_T)out[1],\n     LabB_CheckCommunications_P.rawzaccelerationtog_z_Gain * (real_T)out[2]) +\n    LabB_CheckCommunications_P.accelerometeranglebias_Value) +\n    LabB_CheckCommunications_P.angleoffset_Value) *\n    LabB_CheckCommunications_P.Gain_Gain_g;\n\n  /* Sin: '<Root>/Sine Wave' */\n  if (LabB_CheckCommunications_DWork.systemEnable != 0L) {\n    rtb_Switch = LabB_CheckCommunications_P.SineWave_Freq *\n      ((LabB_CheckCommunications_M->Timing.clockTick0) * 0.01);\n    LabB_CheckCommunications_DWork.lastSin = sin(rtb_Switch);\n    LabB_CheckCommunications_DWork.lastCos = cos(rtb_Switch);\n    LabB_CheckCommunications_DWork.systemEnable = 0L;\n  }\n\n  /* Sin: '<Root>/Sine Wave' */\n  LabB_CheckCommunications_B.SineWave = ((LabB_CheckCommunications_DWork.lastSin\n    * LabB_CheckCommunications_P.SineWave_PCos +\n    LabB_CheckCommunications_DWork.lastCos *\n    LabB_CheckCommunications_P.SineWave_PSin) *\n    LabB_CheckCommunications_P.SineWave_HCos +\n    (LabB_CheckCommunications_DWork.lastCos *\n     LabB_CheckCommunications_P.SineWave_PCos -\n     LabB_CheckCommunications_DWork.lastSin *\n     LabB_CheckCommunications_P.SineWave_PSin) *\n    LabB_CheckCommunications_P.SineWave_Hsin) *\n    LabB_CheckCommunications_P.SineWave_Amp +\n    LabB_CheckCommunications_P.SineWave_Bias;\n\n  /* MATLABSystem: '<S1>/Gyroscope' */\n  /*  initialize output to a single (float) with the value zero */\n  /* 'soMPU6050Gyro:59' out = int16(zeros(3,1)); */\n  /* 'soMPU6050Gyro:60' if coder.target('Rtw') */\n  /*  done only for code gen */\n  /* 'soMPU6050Gyro:61' coder.cinclude('MPU6050wrapper.h'); */\n  /*  get the current value of the sensor */\n  /* 'soMPU6050Gyro:63' coder.ceval('MPU6050Gyro_Read', coder.wref(out)); */\n  MPU6050Gyro_Read(&out[0]);\n\n  /* Gain: '<S1>/conversion to duty cycle (convert to int)' */\n  /*  pull the data appart */\n  /* 'soMPU6050Gyro:68' xvel = out(1); */\n  /* 'soMPU6050Gyro:69' yvel = out(2); */\n  /* 'soMPU6050Gyro:70' zvel = out(3); */\n  u0 = floor(LabB_CheckCommunications_P.conversiontodutycycleconverttoi *\n             LabB_CheckCommunications_B.SineWave);\n  if (rtIsNaN(u0) || rtIsInf(u0)) {\n    u0 = 0.0;\n  } else {\n    u0 = fmod(u0, 65536.0);\n  }\n\n  rtb_Abs = u0 < 0.0 ? -(int16_T)(uint16_T)-u0 : (int16_T)(uint16_T)u0;\n\n  /* End of Gain: '<S1>/conversion to duty cycle (convert to int)' */\n\n  /* Switch: '<S1>/Switch' incorporates:\n   *  Constant: '<S1>/Constant1'\n   *  Constant: '<S1>/Constant2'\n   */\n  if (rtb_Abs >= LabB_CheckCommunications_P.Switch_Threshold) {\n    rtb_Switch = LabB_CheckCommunications_P.Constant2_Value;\n  } else {\n    rtb_Switch = LabB_CheckCommunications_P.Constant1_Value;\n  }\n\n  /* End of Switch: '<S1>/Switch' */\n\n  /* MATLABSystem: '<S1>/Digital Output1' */\n  u0 = rt_roundd_snf(rtb_Switch);\n  if (u0 < 256.0) {\n    if (u0 >= 0.0) {\n      tmp = (uint8_T)u0;\n    } else {\n      tmp = 0U;\n    }\n  } else {\n    tmp = MAX_uint8_T;\n  }\n\n  writeDigitalPin(6, tmp);\n\n  /* End of MATLABSystem: '<S1>/Digital Output1' */\n\n  /* MATLABSystem: '<S1>/PWM' */\n  LabB_CheckCommunications_DWork.obj_i.PWMDriverObj.MW_PWM_HANDLE =\n    MW_PWM_GetHandle(8UL);\n\n  /* Abs: '<S1>/Abs' */\n  if (rtb_Abs < 0) {\n    rtb_Abs = -rtb_Abs;\n  }\n\n  /* Sum: '<S1>/Add2' incorporates:\n   *  Abs: '<S1>/Abs'\n   *  Constant: '<S1>/Constant3'\n   */\n  u0 = LabB_CheckCommunications_P.Constant3_Value + (real_T)rtb_Abs;\n\n  /* Saturate: '<S1>/Saturation 0 to 255' */\n  if (u0 > LabB_CheckCommunications_P.Saturation0to255_UpperSat) {\n    u0 = LabB_CheckCommunications_P.Saturation0to255_UpperSat;\n  } else if (u0 < LabB_CheckCommunications_P.Saturation0to255_LowerSat) {\n    u0 = LabB_CheckCommunications_P.Saturation0to255_LowerSat;\n  }\n\n  /* Abs: '<S1>/Abs3' incorporates:\n   *  Gain: '<S1>/Gain1'\n   *  Saturate: '<S1>/Saturation 0 to 255'\n   *  Sum: '<S1>/Add1'\n   */\n  u0 = fabs(LabB_CheckCommunications_P.Gain1_Gain_b * rtb_Switch - u0);\n\n  /* Start for MATLABSystem: '<S1>/PWM' */\n  if (!(u0 <= 255.0)) {\n    u0 = 255.0;\n  }\n\n  /* MATLABSystem: '<S1>/PWM' */\n  MW_PWM_SetDutyCycle\n    (LabB_CheckCommunications_DWork.obj_i.PWMDriverObj.MW_PWM_HANDLE, u0);\n\n  /* Update for DiscreteIntegrator: '<S1>/angular velocity to angle' incorporates:\n   *  Constant: '<S1>/gyro velocity bias'\n   *  DataTypeConversion: '<S1>/Data Type Conversion'\n   *  Gain: '<S1>/raw x velocity to deg. // sec.'\n   *  Gain: '<S4>/Gain1'\n   *  MATLABSystem: '<S1>/Gyroscope'\n   *  Sum: '<S1>/Sum2'\n   * */\n  LabB_CheckCommunications_DWork.angularvelocitytoangle_DSTATE +=\n    (LabB_CheckCommunications_P.rawxvelocitytodegsec_Gain * (real_T)out[0] *\n     LabB_CheckCommunications_P.Gain1_Gain +\n     LabB_CheckCommunications_P.gyrovelocitybias_Value) *\n    LabB_CheckCommunications_P.angularvelocitytoangle_gainval;\n\n  /* Update for Sin: '<Root>/Sine Wave' */\n  rtb_Switch = LabB_CheckCommunications_DWork.lastSin;\n  LabB_CheckCommunications_DWork.lastSin =\n    LabB_CheckCommunications_DWork.lastSin *\n    LabB_CheckCommunications_P.SineWave_HCos +\n    LabB_CheckCommunications_DWork.lastCos *\n    LabB_CheckCommunications_P.SineWave_Hsin;\n  LabB_CheckCommunications_DWork.lastCos =\n    LabB_CheckCommunications_DWork.lastCos *\n    LabB_CheckCommunications_P.SineWave_HCos - rtb_Switch *\n    LabB_CheckCommunications_P.SineWave_Hsin;\n\n  /* Update absolute time for base rate */\n  /* The \"clockTick0\" counts the number of times the code of this task has\n   * been executed. The resolution of this integer timer is 0.01, which is the step size\n   * of the task. Size of \"clockTick0\" ensures timer will not overflow during the\n   * application lifespan selected.\n   */\n  LabB_CheckCommunications_M->Timing.clockTick0++;\n}\n\n/* Model initialize function */\nvoid LabB_CheckCommunications_initialize(void)\n{\n  /* Registration code */\n\n  /* initialize non-finites */\n  rt_InitInfAndNaN(sizeof(real_T));\n\n  /* initialize real-time model */\n  (void) memset((void *)LabB_CheckCommunications_M, 0,\n                sizeof(RT_MODEL_LabB_CheckCommunicatio));\n  rtmSetTFinal(LabB_CheckCommunications_M, -1);\n\n  /* External mode info */\n  LabB_CheckCommunications_M->Sizes.checksums[0] = (1222194246U);\n  LabB_CheckCommunications_M->Sizes.checksums[1] = (3515119507U);\n  LabB_CheckCommunications_M->Sizes.checksums[2] = (1792380461U);\n  LabB_CheckCommunications_M->Sizes.checksums[3] = (4168725295U);\n\n  {\n    static const sysRanDType rtAlwaysEnabled = SUBSYS_RAN_BC_ENABLE;\n    static RTWExtModeInfo rt_ExtModeInfo;\n    static const sysRanDType *systemRan[8];\n    LabB_CheckCommunications_M->extModeInfo = (&rt_ExtModeInfo);\n    rteiSetSubSystemActiveVectorAddresses(&rt_ExtModeInfo, systemRan);\n    systemRan[0] = &rtAlwaysEnabled;\n    systemRan[1] = &rtAlwaysEnabled;\n    systemRan[2] = &rtAlwaysEnabled;\n    systemRan[3] = &rtAlwaysEnabled;\n    systemRan[4] = &rtAlwaysEnabled;\n    systemRan[5] = &rtAlwaysEnabled;\n    systemRan[6] = &rtAlwaysEnabled;\n    systemRan[7] = &rtAlwaysEnabled;\n    rteiSetModelMappingInfoPtr(LabB_CheckCommunications_M->extModeInfo,\n      &LabB_CheckCommunications_M->SpecialInfo.mappingInfo);\n    rteiSetChecksumsPtr(LabB_CheckCommunications_M->extModeInfo,\n                        LabB_CheckCommunications_M->Sizes.checksums);\n    rteiSetTFinalTicks(LabB_CheckCommunications_M->extModeInfo, -1);\n  }\n\n  /* block I/O */\n  (void) memset(((void *) &LabB_CheckCommunications_B), 0,\n                sizeof(BlockIO_LabB_CheckCommunication));\n\n  /* states (dwork) */\n  (void) memset((void *)&LabB_CheckCommunications_DWork, 0,\n                sizeof(D_Work_LabB_CheckCommunications));\n\n  /* Start for MATLABSystem: '<S1>/M2V3 Left Connector 18, 19' */\n  /*  Constructor */\n  /* 'Encoder_arduino:36' coder.allowpcode('plain'); */\n  /* 'Encoder_arduino:1' matlab.System */\n  /* 'Encoder_arduino:2' coder.ExternalDependency */\n  /* 'Encoder_arduino:3' matlab.system.mixin.Propagates */\n  /* 'Encoder_arduino:4' matlab.system.mixin.CustomIcon */\n  /*  Support name-value pair arguments when constructing the object. */\n  /* 'Encoder_arduino:39' setProperties(obj,nargin,varargin{:}); */\n  LabB_CheckCommunications_DWork.obj_c.matlabCodegenIsDeleted = false;\n\n  /* 'Encoder_arduino:69' validateattributes(value,... */\n  /* 'Encoder_arduino:70'                 {'numeric'},... */\n  /* 'Encoder_arduino:71'                 {'real','nonnegative','integer','scalar','>=',0,'<=',obj.MaxNumEncoder},... */\n  /* 'Encoder_arduino:72'                 '', ... */\n  /* 'Encoder_arduino:73'                 'Encoder'); */\n  /* 'Encoder_arduino:74' obj.Encoder = value; */\n  /* 'Encoder_arduino:43' coder.extrinsic('sprintf') */\n  /*  Do not generate code for sprintf */\n  /* 'Encoder_arduino:44' validateattributes(value,... */\n  /* 'Encoder_arduino:45'                 {'numeric'},... */\n  /* 'Encoder_arduino:46'                 {'real','nonnegative','integer','scalar'},... */\n  /* 'Encoder_arduino:47'                 '', ... */\n  /* 'Encoder_arduino:48'                 'PinA'); */\n  /* 'Encoder_arduino:49' assert(any(value == obj.AvailablePin), ... */\n  /* 'Encoder_arduino:50'                 'Invalid value for Pin. Pin must be one of the following: %s', ... */\n  /* 'Encoder_arduino:51'                 sprintf('%d ', obj.AvailablePin)); */\n  /* 'Encoder_arduino:52' obj.PinA = value; */\n  /* 'Encoder_arduino:56' coder.extrinsic('sprintf') */\n  /*  Do not generate code for sprintf */\n  /* 'Encoder_arduino:57' validateattributes(value,... */\n  /* 'Encoder_arduino:58'                 {'numeric'},... */\n  /* 'Encoder_arduino:59'                 {'real','nonnegative','integer','scalar'},... */\n  /* 'Encoder_arduino:60'                 '', ... */\n  /* 'Encoder_arduino:61'                 'PinB'); */\n  /* 'Encoder_arduino:62' assert(any(value == obj.AvailablePin), ... */\n  /* 'Encoder_arduino:63'                 'Invalid value for Pin. Pin must be one of the following: %s', ... */\n  /* 'Encoder_arduino:64'                 sprintf('%d ', obj.AvailablePin)); */\n  /* 'Encoder_arduino:65' obj.PinB = value; */\n  LabB_CheckCommunications_DWork.obj_c.isInitialized = 1L;\n\n  /*         %% Define output properties */\n  /* 'Encoder_arduino:136' num = 0; */\n  /*         %% Define output properties */\n  /* 'Encoder_arduino:136' num = 0; */\n  /* 'Encoder_arduino:108' if coder.target('Rtw') */\n  /*    Call: void enc_init(int enc, int pinA, int pinB) */\n  /* 'Encoder_arduino:110' coder.cinclude('encoder_arduino.h'); */\n  /* 'Encoder_arduino:111' coder.ceval('enc_init', obj.Encoder, obj.PinA, obj.PinB); */\n  enc_init(1.0, 19.0, 18.0);\n\n  /*                  if(obj.PWMTimer> 0) */\n  /*                      coder.cinclude('PWMFSelect.h'); */\n  /*                      coder.ceval('PWM_Select', obj.PWMFSelect, obj.PWMTimer); */\n  /*                      disp('skipp!!!') */\n  /*                  end */\n  LabB_CheckCommunications_DWork.obj_c.isSetupComplete = true;\n\n  /* Start for MATLABSystem: '<S1>/Accelerometer' */\n  /* 'soMPU6050Accel:1' matlab.System */\n  /* 'soMPU6050Accel:1' coder.ExternalDependency */\n  LabB_CheckCommunications_DWork.obj.matlabCodegenIsDeleted = false;\n  LabB_CheckCommunications_DWork.obj.isInitialized = 1L;\n\n  /* 'soMPU6050Accel:29' if coder.target('Rtw') */\n  /*  done only for code gen */\n  /* 'soMPU6050Accel:30' coder.cinclude('MPU6050wrapper.h'); */\n  /*  initialize the potentiometer */\n  /* 'soMPU6050Accel:32' coder.ceval('MPU6050Accel_Init'); */\n  MPU6050Accel_Init();\n  LabB_CheckCommunications_DWork.obj.isSetupComplete = true;\n\n  /* Start for MATLABSystem: '<S1>/Gyroscope' */\n  /*  Constructor */\n  /* 'soMPU6050Gyro:27' coder.allowpcode('plain'); */\n  /* 'soMPU6050Gyro:1' matlab.System */\n  /* 'soMPU6050Gyro:1' coder.ExternalDependency */\n  /*  Support name-value pair arguments when constructing the object. */\n  /* 'soMPU6050Gyro:30' setProperties(obj,nargin,varargin{:}); */\n  LabB_CheckCommunications_DWork.obj_p.matlabCodegenIsDeleted = false;\n\n  /* 'soMPU6050Gyro:34' coder.extrinsic('sprintf'); */\n  /*  Do not generate code for sprintf */\n  /* 'soMPU6050Gyro:35' validateattributes(value,... */\n  /* 'soMPU6050Gyro:36'                 {'numeric'},... */\n  /* 'soMPU6050Gyro:37'                 {'real','nonnegative','integer','scalar'},... */\n  /* 'soMPU6050Gyro:38'                 '', ... */\n  /* 'soMPU6050Gyro:39'                 'DLPFmode'); */\n  /* 'soMPU6050Gyro:40' obj.DLPFmode = value; */\n  LabB_CheckCommunications_DWork.obj_p.isInitialized = 1L;\n\n  /* 'soMPU6050Gyro:46' if coder.target('Rtw') */\n  /*  done only for code gen */\n  /* 'soMPU6050Gyro:47' coder.cinclude('MPU6050wrapper.h'); */\n  /*  initialize the sensor */\n  /*                  coder.ceval('MPU6050Accel_Init'); */\n  /* 'soMPU6050Gyro:51' coder.ceval('MPU6050Gyro_Init', obj.DLPFmode); */\n  MPU6050Gyro_Init(0.0);\n  LabB_CheckCommunications_DWork.obj_p.isSetupComplete = true;\n\n  /* Start for MATLABSystem: '<S1>/Digital Output1' */\n  LabB_CheckCommunications_DWork.obj_l.matlabCodegenIsDeleted = false;\n  LabB_CheckCommunications_DWork.obj_l.isInitialized = 1L;\n  digitalIOSetup(6, 1);\n  LabB_CheckCommunications_DWork.obj_l.isSetupComplete = true;\n\n  /* Start for MATLABSystem: '<S1>/PWM' */\n  LabB_CheckCommunications_DWork.obj_i.matlabCodegenIsDeleted = false;\n  LabB_CheckCommunications_DWork.obj_i.isInitialized = 1L;\n  LabB_CheckCommunications_DWork.obj_i.PWMDriverObj.MW_PWM_HANDLE = MW_PWM_Open\n    (8UL, 0.0, 0.0);\n  LabB_CheckCommunications_DWork.obj_i.isSetupComplete = true;\n\n  /* InitializeConditions for DiscreteIntegrator: '<S1>/angular velocity to angle' */\n  LabB_CheckCommunications_DWork.angularvelocitytoangle_DSTATE =\n    LabB_CheckCommunications_P.angularvelocitytoangle_IC;\n\n  /* Enable for Sin: '<Root>/Sine Wave' */\n  LabB_CheckCommunications_DWork.systemEnable = 1L;\n}\n\n/* Model terminate function */\nvoid LabB_CheckCommunications_terminate(void)\n{\n  /* Terminate for MATLABSystem: '<S1>/M2V3 Left Connector 18, 19' */\n  if (!LabB_CheckCommunications_DWork.obj_c.matlabCodegenIsDeleted) {\n    LabB_CheckCommunications_DWork.obj_c.matlabCodegenIsDeleted = true;\n  }\n\n  /* End of Terminate for MATLABSystem: '<S1>/M2V3 Left Connector 18, 19' */\n  /* Terminate for MATLABSystem: '<S1>/Accelerometer' */\n  if (!LabB_CheckCommunications_DWork.obj.matlabCodegenIsDeleted) {\n    LabB_CheckCommunications_DWork.obj.matlabCodegenIsDeleted = true;\n  }\n\n  /* End of Terminate for MATLABSystem: '<S1>/Accelerometer' */\n  /* Terminate for MATLABSystem: '<S1>/Gyroscope' */\n  if (!LabB_CheckCommunications_DWork.obj_p.matlabCodegenIsDeleted) {\n    LabB_CheckCommunications_DWork.obj_p.matlabCodegenIsDeleted = true;\n  }\n\n  /* End of Terminate for MATLABSystem: '<S1>/Gyroscope' */\n\n  /* Terminate for MATLABSystem: '<S1>/Digital Output1' */\n  if (!LabB_CheckCommunications_DWork.obj_l.matlabCodegenIsDeleted) {\n    LabB_CheckCommunications_DWork.obj_l.matlabCodegenIsDeleted = true;\n  }\n\n  /* End of Terminate for MATLABSystem: '<S1>/Digital Output1' */\n\n  /* Terminate for MATLABSystem: '<S1>/PWM' */\n  if (!LabB_CheckCommunications_DWork.obj_i.matlabCodegenIsDeleted) {\n    LabB_CheckCommunications_DWork.obj_i.matlabCodegenIsDeleted = true;\n    if ((LabB_CheckCommunications_DWork.obj_i.isInitialized == 1L) &&\n        LabB_CheckCommunications_DWork.obj_i.isSetupComplete) {\n      LabB_CheckCommunications_DWork.obj_i.PWMDriverObj.MW_PWM_HANDLE =\n        MW_PWM_GetHandle(8UL);\n      MW_PWM_SetDutyCycle\n        (LabB_CheckCommunications_DWork.obj_i.PWMDriverObj.MW_PWM_HANDLE, 0.0);\n      LabB_CheckCommunications_DWork.obj_i.PWMDriverObj.MW_PWM_HANDLE =\n        MW_PWM_GetHandle(8UL);\n      MW_PWM_Close\n        (LabB_CheckCommunications_DWork.obj_i.PWMDriverObj.MW_PWM_HANDLE);\n    }\n  }\n\n  /* End of Terminate for MATLABSystem: '<S1>/PWM' */\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"LabB_CheckCommunications.h","type":"header","group":"model","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: LabB_CheckCommunications.h\n *\n * Code generated for Simulink model 'LabB_CheckCommunications'.\n *\n * Model version                  : 18.0\n * Simulink Coder version         : 25.2 (R2025b) 28-Jul-2025\n * C/C++ source code generated on : Wed Jan 21 10:38:09 2026\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Atmel->AVR\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef LabB_CheckCommunications_h_\n#define LabB_CheckCommunications_h_\n#ifndef LabB_CheckCommunications_COMMON_INCLUDES_\n#define LabB_CheckCommunications_COMMON_INCLUDES_\n#include \"rtwtypes.h\"\n#include \"rtw_extmode.h\"\n#include \"sysran_types.h\"\n#include \"rtw_continuous.h\"\n#include \"rtw_solver.h\"\n#include \"MPU6050wrapper.h\"\n#include \"MW_arduino_digitalio.h\"\n#include \"encoder_arduino.h\"\n#include \"MW_PWM.h\"\n#endif                           /* LabB_CheckCommunications_COMMON_INCLUDES_ */\n\n#include \"LabB_CheckCommunications_types.h\"\n#include \"rtGetNaN.h\"\n#include <string.h>\n#include \"rt_nonfinite.h\"\n#include \"MW_target_hardware_resources.h\"\n\n/* Macros for accessing real-time model data structure */\n#ifndef rtmGetFinalTime\n#define rtmGetFinalTime(rtm)           ((rtm)->Timing.tFinal)\n#endif\n\n#ifndef rtmGetRTWExtModeInfo\n#define rtmGetRTWExtModeInfo(rtm)      ((rtm)->extModeInfo)\n#endif\n\n#ifndef rtmGetErrorStatus\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\n#endif\n\n#ifndef rtmSetErrorStatus\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\n#endif\n\n#ifndef rtmGetStopRequested\n#define rtmGetStopRequested(rtm)       ((rtm)->Timing.stopRequestedFlag)\n#endif\n\n#ifndef rtmSetStopRequested\n#define rtmSetStopRequested(rtm, val)  ((rtm)->Timing.stopRequestedFlag = (val))\n#endif\n\n#ifndef rtmGetStopRequestedPtr\n#define rtmGetStopRequestedPtr(rtm)    (&((rtm)->Timing.stopRequestedFlag))\n#endif\n\n#ifndef rtmGetTFinal\n#define rtmGetTFinal(rtm)              ((rtm)->Timing.tFinal)\n#endif\n\n#ifndef rtmGetTPtr\n#define rtmGetTPtr(rtm)                (&)\n#endif\n\n/* Block signals (default storage) */\ntypedef struct {\n  real_T Gain;                         /* '<S3>/Gain' */\n  real_T Gain_j;                       /* '<S2>/Gain' */\n  real_T SineWave;                     /* '<Root>/Sine Wave' */\n  int32_T M2V3LeftConnector1819;       /* '<S1>/M2V3 Left Connector 18, 19' */\n} BlockIO_LabB_CheckCommunication;\n\n/* Block states (default storage) for system '<Root>' */\ntypedef struct {\n  soMPU6050Accel_LabB_CheckCommun obj; /* '<S1>/Accelerometer' */\n  codertarget_arduinobase_blocks_ obj_l;/* '<S1>/Digital Output1' */\n  soMPU6050Gyro_LabB_CheckCommuni obj_p;/* '<S1>/Gyroscope' */\n  Encoder_arduino_LabB_CheckCommu obj_c;/* '<S1>/M2V3 Left Connector 18, 19' */\n  codertarget_arduinobase_interna obj_i;/* '<S1>/PWM' */\n  real_T angularvelocitytoangle_DSTATE;/* '<S1>/angular velocity to angle' */\n  real_T lastSin;                      /* '<Root>/Sine Wave' */\n  real_T lastCos;                      /* '<Root>/Sine Wave' */\n  struct {\n    void *LoggedData;\n  } accelerometer_PWORK;               /* '<Root>/accelerometer' */\n\n  struct {\n    void *LoggedData;\n  } encoder_PWORK;                     /* '<Root>/encoder' */\n\n  struct {\n    void *LoggedData;\n  } gyro_PWORK;                        /* '<Root>/gyro' */\n\n  struct {\n    void *LoggedData;\n  } motor_PWORK;                       /* '<Root>/motor' */\n\n  int32_T systemEnable;                /* '<Root>/Sine Wave' */\n} D_Work_LabB_CheckCommunications;\n\n/* Parameters (default storage) */\nstruct Parameters_LabB_CheckCommunicat_ {\n  real_T Constant2_Value;              /* Expression: 0\n                                        * Referenced by: '<S1>/Constant2'\n                                        */\n  real_T Constant1_Value;              /* Expression: 1\n                                        * Referenced by: '<S1>/Constant1'\n                                        */\n  real_T angleoffset_Value;            /* Expression: pi/2\n                                        * Referenced by: '<S1>/angle offset'\n                                        */\n  real_T angularvelocitytoangle_gainval;\n                           /* Computed Parameter: angularvelocitytoangle_gainval\n                            * Referenced by: '<S1>/angular velocity to angle'\n                            */\n  real_T angularvelocitytoangle_IC;    /* Expression: 0\n                                        * Referenced by: '<S1>/angular velocity to angle'\n                                        */\n  real_T Gain_Gain;                    /* Expression: 180/pi\n                                        * Referenced by: '<S3>/Gain'\n                                        */\n  real_T rawyaccelerationtog_y_Gain;   /* Expression: 1 / 2048\n                                        * Referenced by: '<S1>/raw y acceleration to g_y'\n                                        */\n  real_T rawzaccelerationtog_z_Gain;   /* Expression: 1 / 2048\n                                        * Referenced by: '<S1>/raw z acceleration to g_z'\n                                        */\n  real_T accelerometeranglebias_Value; /* Expression: 0\n                                        * Referenced by: '<S1>/accelerometer angle bias'\n                                        */\n  real_T Gain_Gain_g;                  /* Expression: 180/pi\n                                        * Referenced by: '<S2>/Gain'\n                                        */\n  real_T SineWave_Amp;                 /* Expression: 1\n                                        * Referenced by: '<Root>/Sine Wave'\n                                        */\n  real_T SineWave_Bias;                /* Expression: 0\n                                        * Referenced by: '<Root>/Sine Wave'\n                                        */\n  real_T SineWave_Freq;                /* Expression: 5\n                                        * Referenced by: '<Root>/Sine Wave'\n                                        */\n  real_T SineWave_Phase;               /* Expression: 0\n                                        * Referenced by: '<Root>/Sine Wave'\n                                        */\n  real_T SineWave_Hsin;                /* Computed Parameter: SineWave_Hsin\n                                        * Referenced by: '<Root>/Sine Wave'\n                                        */\n  real_T SineWave_HCos;                /* Computed Parameter: SineWave_HCos\n                                        * Referenced by: '<Root>/Sine Wave'\n                                        */\n  real_T SineWave_PSin;                /* Computed Parameter: SineWave_PSin\n                                        * Referenced by: '<Root>/Sine Wave'\n                                        */\n  real_T SineWave_PCos;                /* Computed Parameter: SineWave_PCos\n                                        * Referenced by: '<Root>/Sine Wave'\n                                        */\n  real_T rawxvelocitytodegsec_Gain;    /* Expression: 1 / 131\n                                        * Referenced by: '<S1>/raw x velocity to deg. // sec.'\n                                        */\n  real_T Gain1_Gain;                   /* Expression: pi/180\n                                        * Referenced by: '<S4>/Gain1'\n                                        */\n  real_T gyrovelocitybias_Value;       /* Expression: 0\n                                        * Referenced by: '<S1>/gyro velocity bias'\n                                        */\n  real_T conversiontodutycycleconverttoi;/* Expression: 255/5\n                                          * Referenced by: '<S1>/conversion to duty cycle (convert to int)'\n                                          */\n  real_T Constant3_Value;              /* Expression: 10\n                                        * Referenced by: '<S1>/Constant3'\n                                        */\n  real_T Saturation0to255_UpperSat;    /* Expression: 255\n                                        * Referenced by: '<S1>/Saturation 0 to 255'\n                                        */\n  real_T Saturation0to255_LowerSat;    /* Expression: 0\n                                        * Referenced by: '<S1>/Saturation 0 to 255'\n                                        */\n  real_T Gain1_Gain_b;                 /* Expression: 255\n                                        * Referenced by: '<S1>/Gain1'\n                                        */\n  int16_T Switch_Threshold;            /* Computed Parameter: Switch_Threshold\n                                        * Referenced by: '<S1>/Switch'\n                                        */\n};\n\n/* Real-time Model Data Structure */\nstruct tag_RTM_LabB_CheckCommunication {\n  const char_T *errorStatus;\n  RTWExtModeInfo *extModeInfo;\n\n  /*\n   * Sizes:\n   * The following substructure contains sizes information\n   * for many of the model attributes such as inputs, outputs,\n   * dwork, sample times, etc.\n   */\n  struct {\n    uint32_T checksums[4];\n  } Sizes;\n\n  /*\n   * SpecialInfo:\n   * The following substructure contains special information\n   * related to other components that are dependent on RTW.\n   */\n  struct {\n    const void *mappingInfo;\n  } SpecialInfo;\n\n  /*\n   * Timing:\n   * The following substructure contains information regarding\n   * the timing information for the model.\n   */\n  struct {\n    uint32_T clockTick0;\n    time_T tFinal;\n    boolean_T stopRequestedFlag;\n  } Timing;\n};\n\n/* Block parameters (default storage) */\nextern Parameters_LabB_CheckCommunicat LabB_CheckCommunications_P;\n\n/* Block signals (default storage) */\nextern BlockIO_LabB_CheckCommunication LabB_CheckCommunications_B;\n\n/* Block states (default storage) */\nextern D_Work_LabB_CheckCommunications LabB_CheckCommunications_DWork;\n\n/* Model entry point functions */\nextern void LabB_CheckCommunications_initialize(void);\nextern void LabB_CheckCommunications_step(void);\nextern void LabB_CheckCommunications_terminate(void);\n\n/* Real-time Model object */\nextern RT_MODEL_LabB_CheckCommunicatio *const LabB_CheckCommunications_M;\nextern volatile boolean_T stopRequested;\nextern volatile boolean_T runModel;\n\n/*-\n * The generated code includes comments that allow you to trace directly\n * back to the appropriate location in the model.  The basic format\n * is <system>/block_name, where system is the system number (uniquely\n * assigned by Simulink) and block_name is the name of the block.\n *\n * Use the MATLAB hilite_system command to trace the generated code back\n * to the model.  For example,\n *\n * hilite_system('<S3>')    - opens system 3\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\n *\n * Here is the system hierarchy for this model\n *\n * '<Root>' : 'LabB_CheckCommunications'\n * '<S1>'   : 'LabB_CheckCommunications/Balancing Robot'\n * '<S2>'   : 'LabB_CheckCommunications/Radians to Degrees'\n * '<S3>'   : 'LabB_CheckCommunications/Radians to Degrees1'\n * '<S4>'   : 'LabB_CheckCommunications/Balancing Robot/Degrees to Radians'\n */\n#endif                                 /* LabB_CheckCommunications_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"LabB_CheckCommunications_private.h","type":"header","group":"model","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: LabB_CheckCommunications_private.h\n *\n * Code generated for Simulink model 'LabB_CheckCommunications'.\n *\n * Model version                  : 18.0\n * Simulink Coder version         : 25.2 (R2025b) 28-Jul-2025\n * C/C++ source code generated on : Wed Jan 21 10:38:09 2026\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Atmel->AVR\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef LabB_CheckCommunications_private_h_\n#define LabB_CheckCommunications_private_h_\n#include \"rtwtypes.h\"\n#include \"multiword_types.h\"\n#include \"LabB_CheckCommunications_types.h\"\n\n/* Private macros used by the generated code to access rtModel */\n#ifndef rtmSetTFinal\n#define rtmSetTFinal(rtm, val)         ((rtm)->Timing.tFinal = (val))\n#endif\n\nextern real_T rt_atan2d_snf(real_T u0, real_T u1);\nextern real_T rt_roundd_snf(real_T u);\n\n#endif                                 /* LabB_CheckCommunications_private_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"LabB_CheckCommunications_types.h","type":"header","group":"model","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: LabB_CheckCommunications_types.h\n *\n * Code generated for Simulink model 'LabB_CheckCommunications'.\n *\n * Model version                  : 18.0\n * Simulink Coder version         : 25.2 (R2025b) 28-Jul-2025\n * C/C++ source code generated on : Wed Jan 21 10:38:09 2026\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Atmel->AVR\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef LabB_CheckCommunications_types_h_\n#define LabB_CheckCommunications_types_h_\n#include \"rtwtypes.h\"\n#include \"MW_SVD.h\"\n#ifndef struct_tag_wfT8Nczpg5TjVpAprGMUWD\n#define struct_tag_wfT8Nczpg5TjVpAprGMUWD\n\nstruct tag_wfT8Nczpg5TjVpAprGMUWD\n{\n  boolean_T matlabCodegenIsDeleted;\n  int32_T isInitialized;\n  boolean_T isSetupComplete;\n};\n\n#endif                                 /* struct_tag_wfT8Nczpg5TjVpAprGMUWD */\n\n#ifndef typedef_soMPU6050Accel_LabB_CheckCommun\n#define typedef_soMPU6050Accel_LabB_CheckCommun\n\ntypedef struct tag_wfT8Nczpg5TjVpAprGMUWD soMPU6050Accel_LabB_CheckCommun;\n\n#endif                             /* typedef_soMPU6050Accel_LabB_CheckCommun */\n\n#ifndef struct_tag_bpMNyLZPCJBeBnOB7xlwFB\n#define struct_tag_bpMNyLZPCJBeBnOB7xlwFB\n\nstruct tag_bpMNyLZPCJBeBnOB7xlwFB\n{\n  int16_T __dummy;\n};\n\n#endif                                 /* struct_tag_bpMNyLZPCJBeBnOB7xlwFB */\n\n#ifndef typedef_b_arduinodriver_ArduinoDigitalI\n#define typedef_b_arduinodriver_ArduinoDigitalI\n\ntypedef struct tag_bpMNyLZPCJBeBnOB7xlwFB b_arduinodriver_ArduinoDigitalI;\n\n#endif                             /* typedef_b_arduinodriver_ArduinoDigitalI */\n\n#ifndef struct_tag_ldqgYDWP5Rq6U8J4ptL7cG\n#define struct_tag_ldqgYDWP5Rq6U8J4ptL7cG\n\nstruct tag_ldqgYDWP5Rq6U8J4ptL7cG\n{\n  boolean_T matlabCodegenIsDeleted;\n  int32_T isInitialized;\n  boolean_T isSetupComplete;\n  b_arduinodriver_ArduinoDigitalI DigitalIODriverObj;\n};\n\n#endif                                 /* struct_tag_ldqgYDWP5Rq6U8J4ptL7cG */\n\n#ifndef typedef_codertarget_arduinobase_blocks_\n#define typedef_codertarget_arduinobase_blocks_\n\ntypedef struct tag_ldqgYDWP5Rq6U8J4ptL7cG codertarget_arduinobase_blocks_;\n\n#endif                             /* typedef_codertarget_arduinobase_blocks_ */\n\n#ifndef struct_tag_mHWUscaTXtLko59TKHbPpC\n#define struct_tag_mHWUscaTXtLko59TKHbPpC\n\nstruct tag_mHWUscaTXtLko59TKHbPpC\n{\n  boolean_T matlabCodegenIsDeleted;\n  int32_T isInitialized;\n  boolean_T isSetupComplete;\n};\n\n#endif                                 /* struct_tag_mHWUscaTXtLko59TKHbPpC */\n\n#ifndef typedef_soMPU6050Gyro_LabB_CheckCommuni\n#define typedef_soMPU6050Gyro_LabB_CheckCommuni\n\ntypedef struct tag_mHWUscaTXtLko59TKHbPpC soMPU6050Gyro_LabB_CheckCommuni;\n\n#endif                             /* typedef_soMPU6050Gyro_LabB_CheckCommuni */\n\n#ifndef struct_tag_5BI4Vs8VF6VibLRLnF8B5\n#define struct_tag_5BI4Vs8VF6VibLRLnF8B5\n\nstruct tag_5BI4Vs8VF6VibLRLnF8B5\n{\n  boolean_T matlabCodegenIsDeleted;\n  int32_T isInitialized;\n  boolean_T isSetupComplete;\n};\n\n#endif                                 /* struct_tag_5BI4Vs8VF6VibLRLnF8B5 */\n\n#ifndef typedef_Encoder_arduino_LabB_CheckCommu\n#define typedef_Encoder_arduino_LabB_CheckCommu\n\ntypedef struct tag_5BI4Vs8VF6VibLRLnF8B5 Encoder_arduino_LabB_CheckCommu;\n\n#endif                             /* typedef_Encoder_arduino_LabB_CheckCommu */\n\n#ifndef struct_tag_7VFuPw0vSNrn5pRgG8Mc4C\n#define struct_tag_7VFuPw0vSNrn5pRgG8Mc4C\n\nstruct tag_7VFuPw0vSNrn5pRgG8Mc4C\n{\n  MW_Handle_Type MW_PWM_HANDLE;\n};\n\n#endif                                 /* struct_tag_7VFuPw0vSNrn5pRgG8Mc4C */\n\n#ifndef typedef_e_matlabshared_ioclient_periphe\n#define typedef_e_matlabshared_ioclient_periphe\n\ntypedef struct tag_7VFuPw0vSNrn5pRgG8Mc4C e_matlabshared_ioclient_periphe;\n\n#endif                             /* typedef_e_matlabshared_ioclient_periphe */\n\n#ifndef struct_tag_RWocY1aAVmuibq0rYX5t0G\n#define struct_tag_RWocY1aAVmuibq0rYX5t0G\n\nstruct tag_RWocY1aAVmuibq0rYX5t0G\n{\n  boolean_T matlabCodegenIsDeleted;\n  int32_T isInitialized;\n  boolean_T isSetupComplete;\n  e_matlabshared_ioclient_periphe PWMDriverObj;\n};\n\n#endif                                 /* struct_tag_RWocY1aAVmuibq0rYX5t0G */\n\n#ifndef typedef_codertarget_arduinobase_interna\n#define typedef_codertarget_arduinobase_interna\n\ntypedef struct tag_RWocY1aAVmuibq0rYX5t0G codertarget_arduinobase_interna;\n\n#endif                             /* typedef_codertarget_arduinobase_interna */\n\n/* Parameters (default storage) */\ntypedef struct Parameters_LabB_CheckCommunicat_ Parameters_LabB_CheckCommunicat;\n\n/* Forward declaration for rtModel */\ntypedef struct tag_RTM_LabB_CheckCommunication RT_MODEL_LabB_CheckCommunicatio;\n\n#endif                                 /* LabB_CheckCommunications_types_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"LabB_CheckCommunications_data.c","type":"source","group":"data","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw","tag":"","groupDisplay":"Data files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: LabB_CheckCommunications_data.c\n *\n * Code generated for Simulink model 'LabB_CheckCommunications'.\n *\n * Model version                  : 18.0\n * Simulink Coder version         : 25.2 (R2025b) 28-Jul-2025\n * C/C++ source code generated on : Wed Jan 21 10:38:09 2026\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Atmel->AVR\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"LabB_CheckCommunications.h\"\n\n/* Block parameters (default storage) */\nParameters_LabB_CheckCommunicat LabB_CheckCommunications_P = {\n  /* Expression: 0\n   * Referenced by: '<S1>/Constant2'\n   */\n  0.0,\n\n  /* Expression: 1\n   * Referenced by: '<S1>/Constant1'\n   */\n  1.0,\n\n  /* Expression: pi/2\n   * Referenced by: '<S1>/angle offset'\n   */\n  1.5707963267948966,\n\n  /* Computed Parameter: angularvelocitytoangle_gainval\n   * Referenced by: '<S1>/angular velocity to angle'\n   */\n  0.01,\n\n  /* Expression: 0\n   * Referenced by: '<S1>/angular velocity to angle'\n   */\n  0.0,\n\n  /* Expression: 180/pi\n   * Referenced by: '<S3>/Gain'\n   */\n  57.295779513082323,\n\n  /* Expression: 1 / 2048\n   * Referenced by: '<S1>/raw y acceleration to g_y'\n   */\n  0.00048828125,\n\n  /* Expression: 1 / 2048\n   * Referenced by: '<S1>/raw z acceleration to g_z'\n   */\n  0.00048828125,\n\n  /* Expression: 0\n   * Referenced by: '<S1>/accelerometer angle bias'\n   */\n  0.0,\n\n  /* Expression: 180/pi\n   * Referenced by: '<S2>/Gain'\n   */\n  57.295779513082323,\n\n  /* Expression: 1\n   * Referenced by: '<Root>/Sine Wave'\n   */\n  1.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Sine Wave'\n   */\n  0.0,\n\n  /* Expression: 5\n   * Referenced by: '<Root>/Sine Wave'\n   */\n  5.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Sine Wave'\n   */\n  0.0,\n\n  /* Computed Parameter: SineWave_Hsin\n   * Referenced by: '<Root>/Sine Wave'\n   */\n  0.049979169270678331,\n\n  /* Computed Parameter: SineWave_HCos\n   * Referenced by: '<Root>/Sine Wave'\n   */\n  0.99875026039496628,\n\n  /* Computed Parameter: SineWave_PSin\n   * Referenced by: '<Root>/Sine Wave'\n   */\n  -0.049979169270678331,\n\n  /* Computed Parameter: SineWave_PCos\n   * Referenced by: '<Root>/Sine Wave'\n   */\n  0.99875026039496628,\n\n  /* Expression: 1 / 131\n   * Referenced by: '<S1>/raw x velocity to deg. // sec.'\n   */\n  0.0076335877862595417,\n\n  /* Expression: pi/180\n   * Referenced by: '<S4>/Gain1'\n   */\n  0.017453292519943295,\n\n  /* Expression: 0\n   * Referenced by: '<S1>/gyro velocity bias'\n   */\n  0.0,\n\n  /* Expression: 255/5\n   * Referenced by: '<S1>/conversion to duty cycle (convert to int)'\n   */\n  51.0,\n\n  /* Expression: 10\n   * Referenced by: '<S1>/Constant3'\n   */\n  10.0,\n\n  /* Expression: 255\n   * Referenced by: '<S1>/Saturation 0 to 255'\n   */\n  255.0,\n\n  /* Expression: 0\n   * Referenced by: '<S1>/Saturation 0 to 255'\n   */\n  0.0,\n\n  /* Expression: 255\n   * Referenced by: '<S1>/Gain1'\n   */\n  255.0,\n\n  /* Computed Parameter: Switch_Threshold\n   * Referenced by: '<S1>/Switch'\n   */\n  0\n};\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: multiword_types.h\n *\n * Code generated for Simulink model 'LabB_CheckCommunications'.\n *\n * Model version                  : 18.0\n * Simulink Coder version         : 25.2 (R2025b) 28-Jul-2025\n * C/C++ source code generated on : Wed Jan 21 10:38:09 2026\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Atmel->AVR\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef MULTIWORD_TYPES_H\n#define MULTIWORD_TYPES_H\n#include \"rtwtypes.h\"\n\n/*\n * Definitions supporting external data access\n */\ntypedef int32_T chunk_T;\ntypedef uint32_T uchunk_T;\n\n#endif                                 /* MULTIWORD_TYPES_H */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rtGetInf.c","type":"source","group":"utility","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rtGetInf.c\n *\n * Code generated for Simulink model 'LabB_CheckCommunications'.\n *\n * Model version                  : 18.0\n * Simulink Coder version         : 25.2 (R2025b) 28-Jul-2025\n * C/C++ source code generated on : Wed Jan 21 10:38:09 2026\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Atmel->AVR\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n#include \"rtGetInf.h\"\n#include <stddef.h>\n#include \"rt_nonfinite.h\"\n#define NumBitsPerChar                 8U\n\n/*\n * Initialize rtInf needed by the generated code.\n * Inf is initialized as non-signaling. Assumes IEEE.\n */\nreal_T rtGetInf(void)\n{\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n  real_T inf = 0.0;\n  if (bitsPerReal == 32U) {\n    inf = rtGetInfF();\n  } else {\n    union {\n      LittleEndianIEEEDouble bitVal;\n      real_T fltVal;\n    } tmpVal;\n\n    tmpVal.bitVal.words.wordH = 0x7FF00000U;\n    tmpVal.bitVal.words.wordL = 0x00000000U;\n    inf = tmpVal.fltVal;\n  }\n\n  return inf;\n}\n\n/*\n * Initialize rtInfF needed by the generated code.\n * Inf is initialized as non-signaling. Assumes IEEE.\n */\nreal32_T rtGetInfF(void)\n{\n  IEEESingle infF;\n  infF.wordL.wordLuint = 0x7F800000U;\n  return infF.wordL.wordLreal;\n}\n\n/*\n * Initialize rtMinusInf needed by the generated code.\n * Inf is initialized as non-signaling. Assumes IEEE.\n */\nreal_T rtGetMinusInf(void)\n{\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n  real_T minf = 0.0;\n  if (bitsPerReal == 32U) {\n    minf = rtGetMinusInfF();\n  } else {\n    union {\n      LittleEndianIEEEDouble bitVal;\n      real_T fltVal;\n    } tmpVal;\n\n    tmpVal.bitVal.words.wordH = 0xFFF00000U;\n    tmpVal.bitVal.words.wordL = 0x00000000U;\n    minf = tmpVal.fltVal;\n  }\n\n  return minf;\n}\n\n/*\n * Initialize rtMinusInfF needed by the generated code.\n * Inf is initialized as non-signaling. Assumes IEEE.\n */\nreal32_T rtGetMinusInfF(void)\n{\n  IEEESingle minfF;\n  minfF.wordL.wordLuint = 0xFF800000U;\n  return minfF.wordL.wordLreal;\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rtGetInf.h\n *\n * Code generated for Simulink model 'LabB_CheckCommunications'.\n *\n * Model version                  : 18.0\n * Simulink Coder version         : 25.2 (R2025b) 28-Jul-2025\n * C/C++ source code generated on : Wed Jan 21 10:38:09 2026\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Atmel->AVR\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef rtGetInf_h_\n#define rtGetInf_h_\n#include \"rt_nonfinite.h\"\n#include \"rtwtypes.h\"\n\nextern real_T rtGetInf(void);\nextern real32_T rtGetInfF(void);\nextern real_T rtGetMinusInf(void);\nextern real32_T rtGetMinusInfF(void);\n\n#endif                                 /* rtGetInf_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rtGetNaN.c","type":"source","group":"utility","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rtGetNaN.c\n *\n * Code generated for Simulink model 'LabB_CheckCommunications'.\n *\n * Model version                  : 18.0\n * Simulink Coder version         : 25.2 (R2025b) 28-Jul-2025\n * C/C++ source code generated on : Wed Jan 21 10:38:09 2026\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Atmel->AVR\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n#include \"rtGetNaN.h\"\n#include <stddef.h>\n#include \"rt_nonfinite.h\"\n#define NumBitsPerChar                 8U\n\n/*\n * Initialize rtNaN needed by the generated code.\n * NaN is initialized as non-signaling. Assumes IEEE.\n */\nreal_T rtGetNaN(void)\n{\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n  real_T nan = 0.0;\n  if (bitsPerReal == 32U) {\n    nan = rtGetNaNF();\n  } else {\n    union {\n      LittleEndianIEEEDouble bitVal;\n      real_T fltVal;\n    } tmpVal;\n\n    tmpVal.bitVal.words.wordH = 0xFFF80000U;\n    tmpVal.bitVal.words.wordL = 0x00000000U;\n    nan = tmpVal.fltVal;\n  }\n\n  return nan;\n}\n\n/*\n * Initialize rtNaNF needed by the generated code.\n * NaN is initialized as non-signaling. Assumes IEEE.\n */\nreal32_T rtGetNaNF(void)\n{\n  IEEESingle nanF = { { 0.0F } };\n\n  nanF.wordL.wordLuint = 0xFFC00000U;\n  return nanF.wordL.wordLreal;\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rtGetNaN.h\n *\n * Code generated for Simulink model 'LabB_CheckCommunications'.\n *\n * Model version                  : 18.0\n * Simulink Coder version         : 25.2 (R2025b) 28-Jul-2025\n * C/C++ source code generated on : Wed Jan 21 10:38:09 2026\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Atmel->AVR\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef rtGetNaN_h_\n#define rtGetNaN_h_\n#include \"rt_nonfinite.h\"\n#include \"rtwtypes.h\"\n\nextern real_T rtGetNaN(void);\nextern real32_T rtGetNaNF(void);\n\n#endif                                 /* rtGetNaN_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rt_defines.h","type":"header","group":"utility","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rt_defines.h\n *\n * Code generated for Simulink model 'LabB_CheckCommunications'.\n *\n * Model version                  : 18.0\n * Simulink Coder version         : 25.2 (R2025b) 28-Jul-2025\n * C/C++ source code generated on : Wed Jan 21 10:38:09 2026\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Atmel->AVR\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef rt_defines_h_\n#define rt_defines_h_\n\n/*===========*\n * Constants *\n *===========*/\n#define RT_PI                          3.14159265358979323846\n#define RT_PIF                         3.1415927F\n#define RT_LN_10                       2.30258509299404568402\n#define RT_LN_10F                      2.3025851F\n#define RT_LOG10E                      0.43429448190325182765\n#define RT_LOG10EF                     0.43429449F\n#define RT_E                           2.7182818284590452354\n#define RT_EF                          2.7182817F\n\n/*\n * UNUSED_PARAMETER(x)\n *   Used to specify that a function parameter (argument) is required but not\n *   accessed by the function body.\n */\n#ifndef UNUSED_PARAMETER\n#if defined(__LCC__)\n#define UNUSED_PARAMETER(x)                                      /* do nothing */\n#else\n\n/*\n * This is the semi-ANSI standard way of indicating that an\n * unused function parameter is required.\n */\n#define UNUSED_PARAMETER(x)            (void) (x)\n#endif\n#endif\n#endif                                 /* rt_defines_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rt_nonfinite.c","type":"source","group":"utility","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rt_nonfinite.c\n *\n * Code generated for Simulink model 'LabB_CheckCommunications'.\n *\n * Model version                  : 18.0\n * Simulink Coder version         : 25.2 (R2025b) 28-Jul-2025\n * C/C++ source code generated on : Wed Jan 21 10:38:09 2026\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Atmel->AVR\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"rtGetNaN.h\"\n#include \"rtGetInf.h\"\n#include <stddef.h>\n#include \"rtwtypes.h\"\n#include \"rt_nonfinite.h\"\n#define NumBitsPerChar                 8U\n\nreal_T rtInf;\nreal_T rtMinusInf;\nreal_T rtNaN;\nreal32_T rtInfF;\nreal32_T rtMinusInfF;\nreal32_T rtNaNF;\n\n/*\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\n */\nvoid rt_InitInfAndNaN(size_t realSize)\n{\n  (void) (realSize);\n  rtNaN = rtGetNaN();\n  rtNaNF = rtGetNaNF();\n  rtInf = rtGetInf();\n  rtInfF = rtGetInfF();\n  rtMinusInf = rtGetMinusInf();\n  rtMinusInfF = rtGetMinusInfF();\n}\n\n/* Test if value is infinite */\nboolean_T rtIsInf(real_T value)\n{\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\n}\n\n/* Test if single-precision value is infinite */\nboolean_T rtIsInfF(real32_T value)\n{\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\n}\n\n/* Test if value is not a number */\nboolean_T rtIsNaN(real_T value)\n{\n  boolean_T result = (boolean_T) 0;\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n  if (bitsPerReal == 32U) {\n    result = rtIsNaNF((real32_T)value);\n  } else {\n    union {\n      LittleEndianIEEEDouble bitVal;\n      real_T fltVal;\n    } tmpVal;\n\n    tmpVal.fltVal = value;\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\n                          (tmpVal.bitVal.words.wordL != 0) ));\n  }\n\n  return result;\n}\n\n/* Test if single-precision value is not a number */\nboolean_T rtIsNaNF(real32_T value)\n{\n  IEEESingle tmp;\n  tmp.wordL.wordLreal = value;\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rt_nonfinite.h\n *\n * Code generated for Simulink model 'LabB_CheckCommunications'.\n *\n * Model version                  : 18.0\n * Simulink Coder version         : 25.2 (R2025b) 28-Jul-2025\n * C/C++ source code generated on : Wed Jan 21 10:38:09 2026\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Atmel->AVR\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef rt_nonfinite_h_\n#define rt_nonfinite_h_\n#include <stddef.h>\n#include \"rtwtypes.h\"\n#define NOT_USING_NONFINITE_LITERALS   1\n\nextern real_T rtInf;\nextern real_T rtMinusInf;\nextern real_T rtNaN;\nextern real32_T rtInfF;\nextern real32_T rtMinusInfF;\nextern real32_T rtNaNF;\nextern void rt_InitInfAndNaN(size_t realSize);\nextern boolean_T rtIsInf(real_T value);\nextern boolean_T rtIsInfF(real32_T value);\nextern boolean_T rtIsNaN(real_T value);\nextern boolean_T rtIsNaNF(real32_T value);\ntypedef struct {\n  struct {\n    uint32_T wordH;\n    uint32_T wordL;\n  } words;\n} BigEndianIEEEDouble;\n\ntypedef struct {\n  struct {\n    uint32_T wordL;\n    uint32_T wordH;\n  } words;\n} LittleEndianIEEEDouble;\n\ntypedef struct {\n  union {\n    real32_T wordLreal;\n    uint32_T wordLuint;\n  } wordL;\n} IEEESingle;\n\n#endif                                 /* rt_nonfinite_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rtwtypes.h\n *\n * Code generated for Simulink model 'LabB_CheckCommunications'.\n *\n * Model version                  : 18.0\n * Simulink Coder version         : 25.2 (R2025b) 28-Jul-2025\n * C/C++ source code generated on : Wed Jan 21 10:38:09 2026\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Atmel->AVR\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n\n/* Logical type definitions */\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n\n/*=======================================================================*\n * Target hardware information\n *   Device type: Atmel->AVR\n *   Number of bits:     char:   8    short:   16    int:  16\n *                       long:  32\n *                       native word size:   8\n *   Byte ordering: LittleEndian\n *   Signed integer division rounds to: Zero\n *   Shift right on a signed integer as arithmetic shift: on\n *=======================================================================*/\n\n/*=======================================================================*\n * Fixed width word size data types:                                     *\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\n *=======================================================================*/\ntypedef signed char int8_T;\ntypedef unsigned char uint8_T;\ntypedef int int16_T;\ntypedef unsigned int uint16_T;\ntypedef long int32_T;\ntypedef unsigned long uint32_T;\ntypedef float real32_T;\ntypedef double real64_T;\n\n/*===========================================================================*\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\n *                           real_T, time_T, ulong_T.                        *\n *===========================================================================*/\ntypedef double real_T;\ntypedef double time_T;\ntypedef unsigned char boolean_T;\ntypedef int int_T;\ntypedef unsigned int uint_T;\ntypedef unsigned long ulong_T;\ntypedef char char_T;\ntypedef unsigned char uchar_T;\ntypedef char_T byte_T;\n\n/*===========================================================================*\n * Complex number type definitions                                           *\n *===========================================================================*/\n#define CREAL_T\n\ntypedef struct {\n  real32_T re;\n  real32_T im;\n} creal32_T;\n\ntypedef struct {\n  real64_T re;\n  real64_T im;\n} creal64_T;\n\ntypedef struct {\n  real_T re;\n  real_T im;\n} creal_T;\n\n#define CINT8_T\n\ntypedef struct {\n  int8_T re;\n  int8_T im;\n} cint8_T;\n\n#define CUINT8_T\n\ntypedef struct {\n  uint8_T re;\n  uint8_T im;\n} cuint8_T;\n\n#define CINT16_T\n\ntypedef struct {\n  int16_T re;\n  int16_T im;\n} cint16_T;\n\n#define CUINT16_T\n\ntypedef struct {\n  uint16_T re;\n  uint16_T im;\n} cuint16_T;\n\n#define CINT32_T\n\ntypedef struct {\n  int32_T re;\n  int32_T im;\n} cint32_T;\n\n#define CUINT32_T\n\ntypedef struct {\n  uint32_T re;\n  uint32_T im;\n} cuint32_T;\n\n/*=======================================================================*\n * Min and Max:                                                          *\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n *=======================================================================*/\n#define MAX_int8_T                     ((int8_T)(127))\n#define MIN_int8_T                     ((int8_T)(-128))\n#define MAX_uint8_T                    ((uint8_T)(255U))\n#define MAX_int16_T                    ((int16_T)(32767))\n#define MIN_int16_T                    ((int16_T)(-32768))\n#define MAX_uint16_T                   ((uint16_T)(65535U))\n#define MAX_int32_T                    ((int32_T)(2147483647L))\n#define MIN_int32_T                    ((int32_T)(-2147483647L-1L))\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFUL))\n\n/* Block D-Work pointer type */\ntypedef void * pointer_T;\n\n#endif                                 /* RTWTYPES_H */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"ext_mode_types.h","type":"header","group":"interface","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw","tag":"","groupDisplay":"Interface files","code":"/*\n * ext_mode_types.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"LabB_CheckCommunications\".\n *\n * Model version              : 18.0\n * Simulink Coder version : 25.2 (R2025b) 28-Jul-2025\n * C source code generated on : Wed Jan 21 10:38:09 2026\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Atmel->AVR\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef EXT_MODE_TYPES_H\n#define EXT_MODE_TYPES_H\n#include \"rtwtypes.h\"\n\n/** External Mode Event ID */\ntypedef uint16_T extmodeEventId_T;\n\n/** External Mode real time, measured using the target's clock */\ntypedef uint32_T extmodeRealTime_T;\n\n/** External Mode simulation time */\ntypedef uint32_T extmodeSimulationTime_T;\n\n/** External Mode double data type */\ntypedef real_T extmodeDouble_T;\n\n/** External Mode classic trigger signal */\ntypedef real_T extmodeClassicTriggerSignal_T;\n\n/** Run the simulation forever (infinite simulation end time) */\n#define EXTMODE_SIMULATION_RUN_FOREVER ((extmodeSimulationTime_T) -1)\n\n/* Define max value of 32-bit unsigned type */\n#define XCP_UINT32_MAX                 0xFFFFFFFFU\n\n/** External Mode MAX simulation time */\n#define MAX_extmodeSimulationTime_T    XCP_UINT32_MAX\n\n/** External Mode MAX base rate simulation time */\n#define EXTMODE_MAX_BASE_RATE_SIMULATION_TIME MAX_uint32_T\n\n/** External Mode Step Size in microseconds */\n#define EXTMODE_STEP_SIZE_IN_MICROSECONDS 10000\n\n/** External Mode Base rate event id */\n#define EXTMODE_BASE_RATE_EVENT_ID     0\n\n/** External Mode Max Event Id */\n#define EXTMODE_MAX_EVENT_ID           0xFF\n#endif                                 /* EXT_MODE_TYPES_H */\n\n/* [EOF] ext_mode_types.h */\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw","tag":"","groupDisplay":"Interface files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rtmodel.h\n *\n * Code generated for Simulink model 'LabB_CheckCommunications'.\n *\n * Model version                  : 18.0\n * Simulink Coder version         : 25.2 (R2025b) 28-Jul-2025\n * C/C++ source code generated on : Wed Jan 21 10:38:09 2026\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Atmel->AVR\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef rtmodel_h_\n#define rtmodel_h_\n#include \"LabB_CheckCommunications.h\"\n#endif                                 /* rtmodel_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"Adafruit_BMP085.cpp","type":"source","group":"other","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/*************************************************** \n  This is a library for the Adafruit BMP085/BMP180 Barometric Pressure + Temp sensor\n\n  Designed specifically to work with the Adafruit BMP085 or BMP180 Breakout \n  ----> http://www.adafruit.com/products/391\n  ----> http://www.adafruit.com/products/1603\n\n  These displays use I2C to communicate, 2 pins are required to  \n  interface\n  Adafruit invests time and resources providing this open source code, \n  please support Adafruit and open-source hardware by purchasing \n  products from Adafruit!\n\n  Written by Limor Fried/Ladyada for Adafruit Industries.  \n  BSD license, all text above must be included in any redistribution\n ****************************************************/\n\n#include \"Adafruit_BMP085.h\"\n\nAdafruit_BMP085::Adafruit_BMP085() {\n}\n\n\nboolean Adafruit_BMP085::begin(uint8_t mode) {\n  if (mode > BMP085_ULTRAHIGHRES) \n    mode = BMP085_ULTRAHIGHRES;\n  oversampling = mode;\n\n  Wire.begin();\n\n  if (read8(0xD0) != 0x55) return false;\n\n  /* read calibration data */\n  ac1 = read16(BMP085_CAL_AC1);\n  ac2 = read16(BMP085_CAL_AC2);\n  ac3 = read16(BMP085_CAL_AC3);\n  ac4 = read16(BMP085_CAL_AC4);\n  ac5 = read16(BMP085_CAL_AC5);\n  ac6 = read16(BMP085_CAL_AC6);\n\n  b1 = read16(BMP085_CAL_B1);\n  b2 = read16(BMP085_CAL_B2);\n\n  mb = read16(BMP085_CAL_MB);\n  mc = read16(BMP085_CAL_MC);\n  md = read16(BMP085_CAL_MD);\n#if (BMP085_DEBUG == 1)\n  Serial.print(\"ac1 = \"); Serial.println(ac1, DEC);\n  Serial.print(\"ac2 = \"); Serial.println(ac2, DEC);\n  Serial.print(\"ac3 = \"); Serial.println(ac3, DEC);\n  Serial.print(\"ac4 = \"); Serial.println(ac4, DEC);\n  Serial.print(\"ac5 = \"); Serial.println(ac5, DEC);\n  Serial.print(\"ac6 = \"); Serial.println(ac6, DEC);\n\n  Serial.print(\"b1 = \"); Serial.println(b1, DEC);\n  Serial.print(\"b2 = \"); Serial.println(b2, DEC);\n\n  Serial.print(\"mb = \"); Serial.println(mb, DEC);\n  Serial.print(\"mc = \"); Serial.println(mc, DEC);\n  Serial.print(\"md = \"); Serial.println(md, DEC);\n#endif\n\n  return true;\n}\n\nint32_t Adafruit_BMP085::computeB5(int32_t UT) {\n  int32_t X1 = (UT - (int32_t)ac6) * ((int32_t)ac5) >> 15;\n  int32_t X2 = ((int32_t)mc << 11) / (X1+(int32_t)md);\n  return X1 + X2;\n}\n\nuint16_t Adafruit_BMP085::readRawTemperature(void) {\n  write8(BMP085_CONTROL, BMP085_READTEMPCMD);\n  delay(5);\n#if BMP085_DEBUG == 1\n  Serial.print(\"Raw temp: \"); Serial.println(read16(BMP085_TEMPDATA));\n#endif\n  return read16(BMP085_TEMPDATA);\n}\n\nuint32_t Adafruit_BMP085::readRawPressure(void) {\n  uint32_t raw;\n\n  write8(BMP085_CONTROL, BMP085_READPRESSURECMD + (oversampling << 6));\n\n  if (oversampling == BMP085_ULTRALOWPOWER) \n    delay(5);\n  else if (oversampling == BMP085_STANDARD) \n    delay(8);\n  else if (oversampling == BMP085_HIGHRES) \n    delay(14);\n  else \n    delay(26);\n\n  raw = read16(BMP085_PRESSUREDATA);\n\n  raw <<= 8;\n  raw |= read8(BMP085_PRESSUREDATA+2);\n  raw >>= (8 - oversampling);\n\n /* this pull broke stuff, look at it later?\n  if (oversampling==0) {\n    raw <<= 8;\n    raw |= read8(BMP085_PRESSUREDATA+2);\n    raw >>= (8 - oversampling);\n  }\n */\n\n#if BMP085_DEBUG == 1\n  Serial.print(\"Raw pressure: \"); Serial.println(raw);\n#endif\n  return raw;\n}\n\n\nint32_t Adafruit_BMP085::readPressure(void) {\n  int32_t UT, UP, B3, B5, B6, X1, X2, X3, p;\n  uint32_t B4, B7;\n\n  UT = readRawTemperature();\n  UP = readRawPressure();\n\n#if BMP085_DEBUG == 1\n  // use datasheet numbers!\n  UT = 27898;\n  UP = 23843;\n  ac6 = 23153;\n  ac5 = 32757;\n  mc = -8711;\n  md = 2868;\n  b1 = 6190;\n  b2 = 4;\n  ac3 = -14383;\n  ac2 = -72;\n  ac1 = 408;\n  ac4 = 32741;\n  oversampling = 0;\n#endif\n\n  B5 = computeB5(UT);\n\n#if BMP085_DEBUG == 1\n  Serial.print(\"X1 = \"); Serial.println(X1);\n  Serial.print(\"X2 = \"); Serial.println(X2);\n  Serial.print(\"B5 = \"); Serial.println(B5);\n#endif\n\n  // do pressure calcs\n  B6 = B5 - 4000;\n  X1 = ((int32_t)b2 * ( (B6 * B6)>>12 )) >> 11;\n  X2 = ((int32_t)ac2 * B6) >> 11;\n  X3 = X1 + X2;\n  B3 = ((((int32_t)ac1*4 + X3) << oversampling) + 2) / 4;\n\n#if BMP085_DEBUG == 1\n  Serial.print(\"B6 = \"); Serial.println(B6);\n  Serial.print(\"X1 = \"); Serial.println(X1);\n  Serial.print(\"X2 = \"); Serial.println(X2);\n  Serial.print(\"B3 = \"); Serial.println(B3);\n#endif\n\n  X1 = ((int32_t)ac3 * B6) >> 13;\n  X2 = ((int32_t)b1 * ((B6 * B6) >> 12)) >> 16;\n  X3 = ((X1 + X2) + 2) >> 2;\n  B4 = ((uint32_t)ac4 * (uint32_t)(X3 + 32768)) >> 15;\n  B7 = ((uint32_t)UP - B3) * (uint32_t)( 50000UL >> oversampling );\n\n#if BMP085_DEBUG == 1\n  Serial.print(\"X1 = \"); Serial.println(X1);\n  Serial.print(\"X2 = \"); Serial.println(X2);\n  Serial.print(\"B4 = \"); Serial.println(B4);\n  Serial.print(\"B7 = \"); Serial.println(B7);\n#endif\n\n  if (B7 < 0x80000000) {\n    p = (B7 * 2) / B4;\n  } else {\n    p = (B7 / B4) * 2;\n  }\n  X1 = (p >> 8) * (p >> 8);\n  X1 = (X1 * 3038) >> 16;\n  X2 = (-7357 * p) >> 16;\n\n#if BMP085_DEBUG == 1\n  Serial.print(\"p = \"); Serial.println(p);\n  Serial.print(\"X1 = \"); Serial.println(X1);\n  Serial.print(\"X2 = \"); Serial.println(X2);\n#endif\n\n  p = p + ((X1 + X2 + (int32_t)3791)>>4);\n#if BMP085_DEBUG == 1\n  Serial.print(\"p = \"); Serial.println(p);\n#endif\n  return p;\n}\n\nint32_t Adafruit_BMP085::readSealevelPressure(float altitude_meters) {\n  float pressure = readPressure();\n  return (int32_t)(pressure / pow(1.0-altitude_meters/44330, 5.255));\n}\n\nfloat Adafruit_BMP085::readTemperature(void) {\n  int32_t UT, B5;     // following ds convention\n  float temp;\n\n  UT = readRawTemperature();\n\n#if BMP085_DEBUG == 1\n  // use datasheet numbers!\n  UT = 27898;\n  ac6 = 23153;\n  ac5 = 32757;\n  mc = -8711;\n  md = 2868;\n#endif\n\n  B5 = computeB5(UT);\n  temp = (B5+8) >> 4;\n  temp /= 10;\n  \n  return temp;\n}\n\nfloat Adafruit_BMP085::readAltitude(float sealevelPressure) {\n  float altitude;\n\n  float pressure = readPressure();\n\n  altitude = 44330 * (1.0 - pow(pressure /sealevelPressure,0.1903));\n\n  return altitude;\n}\n\n\n/*********************************************************************/\n\nuint8_t Adafruit_BMP085::read8(uint8_t a) {\n  uint8_t ret;\n\n  Wire.beginTransmission(BMP085_I2CADDR); // start transmission to device \n#if (ARDUINO >= 100)\n  Wire.write(a); // sends register address to read from\n#else\n  Wire.send(a); // sends register address to read from\n#endif\n  Wire.endTransmission(); // end transmission\n  \n  Wire.beginTransmission(BMP085_I2CADDR); // start transmission to device \n  Wire.requestFrom(BMP085_I2CADDR, 1);// send data n-bytes read\n#if (ARDUINO >= 100)\n  ret = Wire.read(); // receive DATA\n#else\n  ret = Wire.receive(); // receive DATA\n#endif\n  Wire.endTransmission(); // end transmission\n\n  return ret;\n}\n\nuint16_t Adafruit_BMP085::read16(uint8_t a) {\n  uint16_t ret;\n\n  Wire.beginTransmission(BMP085_I2CADDR); // start transmission to device \n#if (ARDUINO >= 100)\n  Wire.write(a); // sends register address to read from\n#else\n  Wire.send(a); // sends register address to read from\n#endif\n  Wire.endTransmission(); // end transmission\n  \n  Wire.beginTransmission(BMP085_I2CADDR); // start transmission to device \n  Wire.requestFrom(BMP085_I2CADDR, 2);// send data n-bytes read\n#if (ARDUINO >= 100)\n  ret = Wire.read(); // receive DATA\n  ret <<= 8;\n  ret |= Wire.read(); // receive DATA\n#else\n  ret = Wire.receive(); // receive DATA\n  ret <<= 8;\n  ret |= Wire.receive(); // receive DATA\n#endif\n  Wire.endTransmission(); // end transmission\n\n  return ret;\n}\n\nvoid Adafruit_BMP085::write8(uint8_t a, uint8_t d) {\n  Wire.beginTransmission(BMP085_I2CADDR); // start transmission to device \n#if (ARDUINO >= 100)\n  Wire.write(a); // sends register address to read from\n  Wire.write(d);  // write data\n#else\n  Wire.send(a); // sends register address to read from\n  Wire.send(d);  // write data\n#endif\n  Wire.endTransmission(); // end transmission\n}\n"},{"name":"Adafruit_BMP280.cpp","type":"source","group":"other","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/***************************************************************************\n  This is a library for the BMP280 pressure sensor\n\n  Designed specifically to work with the Adafruit BMP280 Breakout\n  ----> http://www.adafruit.com/products/2651\n\n  These sensors use I2C to communicate, 2 pins are required to interface.\n\n  Adafruit invests time and resources providing this open source code,\n  please support Adafruit andopen-source hardware by purchasing products\n  from Adafruit!\n\n  Written by Kevin Townsend for Adafruit Industries.\n  BSD license, all text above must be included in any redistribution\n ***************************************************************************/\n#include \"Arduino.h\"\n#include <Wire.h>\n#include \"Adafruit_BMP280.h\"\n\n\n/***************************************************************************\n PRIVATE FUNCTIONS\n ***************************************************************************/\n\n\nAdafruit_BMP280::Adafruit_BMP280()\n  : _cs(-1), _mosi(-1), _miso(-1), _sck(-1)\n{ }\n\n\nbool Adafruit_BMP280::begin(uint8_t a, uint8_t chipid) {\n  _i2caddr = a;\n\n  Wire.begin();\n\n\n  if (read8(BMP280_REGISTER_CHIPID) != chipid)\n    return false;\n\n  readCoefficients();\n  write8(BMP280_REGISTER_CONTROL, 0x3F);\n  return true;\n}\n\n/**************************************************************************/\n/*!\n    @brief  Writes an 8 bit value over I2C/SPI\n*/\n/**************************************************************************/\nvoid Adafruit_BMP280::write8(byte reg, byte value)\n{\n\n    Wire.beginTransmission((uint8_t)_i2caddr);\n    Wire.write((uint8_t)reg);\n    Wire.write((uint8_t)value);\n    Wire.endTransmission();\n\n}\n\n/**************************************************************************/\n/*!\n    @brief  Reads an 8 bit value over I2C/SPI\n*/\n/**************************************************************************/\nuint8_t Adafruit_BMP280::read8(byte reg)\n{\n  uint8_t value;\n\n    Wire.beginTransmission((uint8_t)_i2caddr);\n    Wire.write((uint8_t)reg);\n    Wire.endTransmission();\n    Wire.requestFrom((uint8_t)_i2caddr, (byte)1);\n    value = Wire.read();\n\n  return value;\n}\n\n/**************************************************************************/\n/*!\n    @brief  Reads a 16 bit value over I2C/SPI\n*/\n/**************************************************************************/\nuint16_t Adafruit_BMP280::read16(byte reg)\n{\n  uint16_t value;\n\n\n    Wire.beginTransmission((uint8_t)_i2caddr);\n    Wire.write((uint8_t)reg);\n    Wire.endTransmission();\n    Wire.requestFrom((uint8_t)_i2caddr, (byte)2);\n    value = (Wire.read() << 8) | Wire.read();\n\n  return value;\n}\n\nuint16_t Adafruit_BMP280::read16_LE(byte reg) {\n  uint16_t temp = read16(reg);\n  return (temp >> 8) | (temp << 8);\n\n}\n\n/**************************************************************************/\n/*!\n    @brief  Reads a signed 16 bit value over I2C/SPI\n*/\n/**************************************************************************/\nint16_t Adafruit_BMP280::readS16(byte reg)\n{\n  return (int16_t)read16(reg);\n\n}\n\nint16_t Adafruit_BMP280::readS16_LE(byte reg)\n{\n  return (int16_t)read16_LE(reg);\n\n}\n\n\n/**************************************************************************/\n/*!\n    @brief  Reads a 24 bit value over I2C/SPI\n*/\n/**************************************************************************/\nuint32_t Adafruit_BMP280::read24(byte reg)\n{\n  uint32_t value;\n\n    Wire.beginTransmission((uint8_t)_i2caddr);\n    Wire.write((uint8_t)reg);\n    Wire.endTransmission();\n    Wire.requestFrom((uint8_t)_i2caddr, (byte)3);\n    \n    value = Wire.read();\n    value <<= 8;\n    value |= Wire.read();\n    value <<= 8;\n    value |= Wire.read();\n\n  return value;\n}\n\n/**************************************************************************/\n/*!\n    @brief  Reads the factory-set coefficients\n*/\n/**************************************************************************/\nvoid Adafruit_BMP280::readCoefficients(void)\n{\n    _bmp280_calib.dig_T1 = read16_LE(BMP280_REGISTER_DIG_T1);\n    _bmp280_calib.dig_T2 = readS16_LE(BMP280_REGISTER_DIG_T2);\n    _bmp280_calib.dig_T3 = readS16_LE(BMP280_REGISTER_DIG_T3);\n\n    _bmp280_calib.dig_P1 = read16_LE(BMP280_REGISTER_DIG_P1);\n    _bmp280_calib.dig_P2 = readS16_LE(BMP280_REGISTER_DIG_P2);\n    _bmp280_calib.dig_P3 = readS16_LE(BMP280_REGISTER_DIG_P3);\n    _bmp280_calib.dig_P4 = readS16_LE(BMP280_REGISTER_DIG_P4);\n    _bmp280_calib.dig_P5 = readS16_LE(BMP280_REGISTER_DIG_P5);\n    _bmp280_calib.dig_P6 = readS16_LE(BMP280_REGISTER_DIG_P6);\n    _bmp280_calib.dig_P7 = readS16_LE(BMP280_REGISTER_DIG_P7);\n    _bmp280_calib.dig_P8 = readS16_LE(BMP280_REGISTER_DIG_P8);\n    _bmp280_calib.dig_P9 = readS16_LE(BMP280_REGISTER_DIG_P9);\n}\n\n/**************************************************************************/\n/*!\n\n*/\n/**************************************************************************/\nfloat Adafruit_BMP280::readTemperature(void)\n{\n  int32_t var1, var2;\n\n  int32_t adc_T = read24(BMP280_REGISTER_TEMPDATA);\n  adc_T >>= 4;\n\n  var1  = ((((adc_T>>3) - ((int32_t)_bmp280_calib.dig_T1 <<1))) *\n\t   ((int32_t)_bmp280_calib.dig_T2)) >> 11;\n\n  var2  = (((((adc_T>>4) - ((int32_t)_bmp280_calib.dig_T1)) *\n\t     ((adc_T>>4) - ((int32_t)_bmp280_calib.dig_T1))) >> 12) *\n\t   ((int32_t)_bmp280_calib.dig_T3)) >> 14;\n\n  t_fine = var1 + var2;\n\n  float T  = (t_fine * 5 + 128) >> 8;\n  return T/100;\n}\n\n/**************************************************************************/\n/*!\n\n*/\n/**************************************************************************/\nfloat Adafruit_BMP280::readPressure(void) {\n  int64_t var1, var2, p;\n\n  // Must be done first to get the t_fine variable set up\n  readTemperature();\n\n  int32_t adc_P = read24(BMP280_REGISTER_PRESSUREDATA);\n  adc_P >>= 4;\n\n  var1 = ((int64_t)t_fine) - 128000;\n  var2 = var1 * var1 * (int64_t)_bmp280_calib.dig_P6;\n  var2 = var2 + ((var1*(int64_t)_bmp280_calib.dig_P5)<<17);\n  var2 = var2 + (((int64_t)_bmp280_calib.dig_P4)<<35);\n  var1 = ((var1 * var1 * (int64_t)_bmp280_calib.dig_P3)>>8) +\n    ((var1 * (int64_t)_bmp280_calib.dig_P2)<<12);\n  var1 = (((((int64_t)1)<<47)+var1))*((int64_t)_bmp280_calib.dig_P1)>>33;\n\n  if (var1 == 0) {\n    return 0;  // avoid exception caused by division by zero\n  }\n  p = 1048576 - adc_P;\n  p = (((p<<31) - var2)*3125) / var1;\n  var1 = (((int64_t)_bmp280_calib.dig_P9) * (p>>13) * (p>>13)) >> 25;\n  var2 = (((int64_t)_bmp280_calib.dig_P8) * p) >> 19;\n\n  p = ((p + var1 + var2) >> 8) + (((int64_t)_bmp280_calib.dig_P7)<<4);\n  return (float)p/256;\n}\n\nfloat Adafruit_BMP280::readAltitude(float seaLevelhPa) {\n  float altitude;\n\n  float pressure = readPressure(); // in Si units for Pascal\n  pressure /= 100;\n\n  altitude = 44330 * (1.0 - pow(pressure / seaLevelhPa, 0.1903));\n\n  return altitude;\n}\n"},{"name":"ArduinoPinHandleMap.cpp","type":"source","group":"legacy","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/../../../Documents/MATLAB/SupportPackages/R2025b/toolbox/target/supportpackages/arduinobase/src","tag":"","groupDisplay":"Other files","code":"#include \"rtwtypes.h\"\n\n#define ANALOG_MODULES_MAX 70  /* For Mega and Due. Other boards have less number of Modules */\n#define PWM_MODULES_MAX 70  /* For Mega and Due. Other boards have less number of Modules */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n    \ntypedef uint8_T PeripheralHandleMapType;\nPeripheralHandleMapType analogPinHandleMap[(ANALOG_MODULES_MAX/8)+1] = {0};\nPeripheralHandleMapType PWMPinHandleMap[(PWM_MODULES_MAX/8)+1] = {0};\n\n#ifdef __cplusplus\n}\n#endif\n"},{"name":"BMI160.cpp","type":"source","group":"other","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/*\n===============================================\nBMI160 accelerometer/gyroscope library for Intel(R) Curie(TM) devices.\nCopyright (c) 2015 Intel Corporation.  All rights reserved.\n\nBased on MPU6050 Arduino library provided by Jeff Rowberg as part of his\nexcellent I2Cdev device library: https://github.com/jrowberg/i2cdevlib\n\n===============================================\nI2Cdev device library code is placed under the MIT license\nCopyright (c) 2012 Jeff Rowberg\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n===============================================\n*/\n#include \"BMI160.h\"\n\n#define BMI160_CHIP_ID 0xD1\n\n#define BMI160_ACCEL_POWERUP_DELAY_MS 10\n#define BMI160_GYRO_POWERUP_DELAY_MS 100\n\n/* Test the sign bit and set remaining MSBs if sign bit is set */\n#define BMI160_SIGN_EXTEND(val, from) \\\n    (((val) & (1 << ((from) - 1))) ? (val | (((1 << (1 + (sizeof(val) << 3) - (from))) - 1) << (from))) : val)\n\n/******************************************************************************/\n\nuint8_t BMI160Class::reg_read (uint8_t reg)\n{\n    uint8_t buffer[1];\n    buffer[0] = reg;\n    serial_buffer_transfer(buffer, 1, 1);\n    return buffer[0];\n}\n\nvoid BMI160Class::reg_write(uint8_t reg, uint8_t data)\n{\n    uint8_t buffer[2];\n    buffer[0] = reg;\n    buffer[1] = data;\n    serial_buffer_transfer(buffer, 2, 0);\n}\n\nvoid BMI160Class::reg_write_bits(uint8_t reg, uint8_t data, unsigned pos, unsigned len)\n{\n    uint8_t b = reg_read(reg);\n    uint8_t mask = ((1 << len) - 1) << pos;\n    data <<= pos; // shift data into correct position\n    data &= mask; // zero all non-important bits in data\n    b &= ~(mask); // zero all important bits in existing byte\n    b |= data; // combine data with existing byte\n    reg_write(reg, b);\n}\n\nuint8_t BMI160Class::reg_read_bits(uint8_t reg, unsigned pos, unsigned len)\n{\n    uint8_t b = reg_read(reg);\n    uint8_t mask = (1 << len) - 1;\n    b >>= pos;\n    b &= mask;\n    return b;\n}\n\n/******************************************************************************/\n\n/** Power on and prepare for general usage.\n * This will activate the device and take it out of sleep mode (which must be done\n * after start-up). This function also sets both the accelerometer and the gyroscope\n * to default range settings, namely +/- 2g and +/- 250 degrees/sec.\n */\nvoid BMI160Class::initialize()\n{\n    /* Issue a soft-reset to bring the device into a clean state */\n    reg_write(BMI160_RA_CMD, BMI160_CMD_SOFT_RESET);\n    delay(1);\n\n    /* Issue a dummy-read to force the device into SPI comms mode */\n    reg_read(0x7F);\n    delay(1);\n\n    /* Power up the accelerometer */\n    reg_write(BMI160_RA_CMD, BMI160_CMD_ACC_MODE_NORMAL);\n    delay(1);\n    /* Wait for power-up to complete */\n    while (0x1 != reg_read_bits(BMI160_RA_PMU_STATUS,\n                                BMI160_ACC_PMU_STATUS_BIT,\n                                BMI160_ACC_PMU_STATUS_LEN))\n        delay(1);\n\n    /* Power up the gyroscope */\n    reg_write(BMI160_RA_CMD, BMI160_CMD_GYR_MODE_NORMAL);\n    delay(1);\n    /* Wait for power-up to complete */\n    while (0x1 != reg_read_bits(BMI160_RA_PMU_STATUS,\n                                BMI160_GYR_PMU_STATUS_BIT,\n                                BMI160_GYR_PMU_STATUS_LEN))\n        delay(1);\n\n    setFullScaleGyroRange(BMI160_GYRO_RANGE_250);\n    setFullScaleAccelRange(BMI160_ACCEL_RANGE_2G);\n\n    /* Only PIN1 interrupts currently supported - map all interrupts to PIN1 */\n    reg_write(BMI160_RA_INT_MAP_0, 0xFF);\n    reg_write(BMI160_RA_INT_MAP_1, 0xF0);\n    reg_write(BMI160_RA_INT_MAP_2, 0x00);\n}\n\n/** Get Device ID.\n * This register is used to verify the identity of the device (0b11010001, 0xD1).\n * @return Device ID (should be 0xD1)\n * @see BMI160_RA_CHIP_ID\n */\nuint8_t BMI160Class::getDeviceID() {\n    return reg_read(BMI160_RA_CHIP_ID);\n}\n\n/** Verify the SPI connection.\n * Make sure the device is connected and responds as expected.\n * @return True if connection is valid, false otherwise\n */\nbool BMI160Class::testConnection()\n{\n    return (BMI160_CHIP_ID == getDeviceID());\n}\n\n/** Get gyroscope output data rate.\n * The gyr_odr parameter allows setting the output data rate of the gyroscope\n * as described in the table below.\n *\n * <pre>\n *  6 =   25Hz\n *  7 =   50Hz\n *  8 =  100Hz\n *  9 =  200Hz\n * 10 =  400Hz\n * 11 =  800Hz\n * 12 = 1600Hz\n * 13 = 3200Hz\n * </pre>\n *\n * @return Current sample rate\n * @see BMI160_RA_GYRO_CONF\n * @see BMI160GyroRate\n */\nuint8_t BMI160Class::getGyroRate() {\n    return reg_read_bits(BMI160_RA_GYRO_CONF,\n                         BMI160_GYRO_RATE_SEL_BIT,\n                         BMI160_GYRO_RATE_SEL_LEN);\n}\n\n/** Set gyroscope output data rate.\n * @param rate New output data rate\n * @see getGyroRate()\n * @see BMI160_GYRO_RATE_25HZ\n * @see BMI160_RA_GYRO_CONF\n */\nvoid BMI160Class::setGyroRate(uint8_t rate) {\n    reg_write_bits(BMI160_RA_GYRO_CONF, rate,\n                   BMI160_GYRO_RATE_SEL_BIT,\n                   BMI160_GYRO_RATE_SEL_LEN);\n}\n\n/** Get accelerometer output data rate.\n * The acc_odr parameter allows setting the output data rate of the accelerometer\n * as described in the table below.\n *\n * <pre>\n *  5 =  25/2Hz\n *  6 =    25Hz\n *  7 =    50Hz\n *  8 =   100Hz\n *  9 =   200Hz\n * 10 =   400Hz\n * 11 =   800Hz\n * 12 =  1600Hz\n * 13 =  3200Hz\n * </pre>\n *\n * @return Current sample rate\n * @see BMI160_RA_ACCEL_CONF\n * @see BMI160AccelRate\n */\nuint8_t BMI160Class::getAccelRate() {\n    return reg_read_bits(BMI160_RA_ACCEL_CONF,\n                         BMI160_ACCEL_RATE_SEL_BIT,\n                         BMI160_ACCEL_RATE_SEL_LEN);\n}\n\n/** Set accelerometer output data rate.\n * @param rate New output data rate\n * @see getAccelRate()\n * @see BMI160_RA_ACCEL_CONF\n */\nvoid BMI160Class::setAccelRate(uint8_t rate) {\n    reg_write_bits(BMI160_RA_ACCEL_CONF, rate,\n                   BMI160_ACCEL_RATE_SEL_BIT,\n                   BMI160_ACCEL_RATE_SEL_LEN);\n}\n\n/** Get gyroscope digital low-pass filter mode.\n * The gyro_bwp parameter sets the gyroscope digital low pass filter configuration.\n *\n * When the filter mode is set to Normal (@see BMI160_DLPF_MODE_NORM), the filter\n * bandwidth for each respective gyroscope output data rates is shown in the table below:\n *\n * <pre>\n * ODR     | 3dB cut-off\n * --------+------------\n *    25Hz | 10.7Hz\n *    50Hz | 20.8Hz\n *   100Hz | 39.9Hz\n *   200Hz | 74.6Hz\n *   400Hz | 136.6Hz\n *   800Hz | 254.6Hz\n *  1600Hz | 523.9Hz\n *  3200Hz | 890Hz\n * </pre>\n *\n * When the filter mode is set to OSR2 (@see BMI160_DLPF_MODE_OSR2), the filter\n * bandwidths above are approximately halved.\n *\n * When the filter mode is set to OSR4 (@see BMI160_DLPF_MODE_OSR4), the filter\n * bandwidths above are approximately 4 times smaller.\n *\n * @return DLFP configuration\n * @see BMI160_RA_GYRO_CONF\n * @see BMI160DLPFMode\n */\nuint8_t BMI160Class::getGyroDLPFMode() {\n    return reg_read_bits(BMI160_RA_GYRO_CONF,\n                         BMI160_GYRO_DLPF_SEL_BIT,\n                         BMI160_GYRO_DLPF_SEL_LEN);\n}\n\n/** Set gyroscope digital low-pass filter configuration.\n * @param mode New DLFP configuration setting\n * @see getGyroDLPFMode()\n */\nvoid BMI160Class::setGyroDLPFMode(uint8_t mode) {\n    return reg_write_bits(BMI160_RA_GYRO_CONF, mode,\n                          BMI160_GYRO_DLPF_SEL_BIT,\n                          BMI160_GYRO_DLPF_SEL_LEN);\n}\n\n/** Get accelerometer digital low-pass filter mode.\n * The acc_bwp parameter sets the accelerometer digital low pass filter configuration.\n *\n * When the filter mode is set to Normal (@see BMI160_DLPF_MODE_NORM), the filter\n * bandwidth for each respective accelerometer output data rates is shown in the table below:\n *\n * <pre>\n * ODR     | 3dB cut-off\n * --------+--------------\n *  12.5Hz |  5.06Hz\n *    25Hz | 10.12Hz\n *    50Hz | 20.25Hz\n *   100Hz | 40.5Hz\n *   200Hz | 80Hz\n *   400Hz | 162Hz (155Hz for Z axis)\n *   800Hz | 324Hz (262Hz for Z axis)\n *  1600Hz | 684Hz (353Hz for Z axis)\n * </pre>\n *\n * When the filter mode is set to OSR2 (@see BMI160_DLPF_MODE_OSR2), the filter\n * bandwidths above are approximately halved.\n *\n * When the filter mode is set to OSR4 (@see BMI160_DLPF_MODE_OSR4), the filter\n * bandwidths above are approximately 4 times smaller.\n *\n * @return DLFP configuration\n * @see BMI160_RA_GYRO_CONF\n * @see BMI160DLPFMode\n */\nuint8_t BMI160Class::getAccelDLPFMode() {\n    return reg_read_bits(BMI160_RA_ACCEL_CONF,\n                         BMI160_ACCEL_DLPF_SEL_BIT,\n                         BMI160_ACCEL_DLPF_SEL_LEN);\n}\n\n/** Set accelerometer digital low-pass filter configuration.\n * @param mode New DLFP configuration setting\n * @see getAccelDLPFMode()\n */\nvoid BMI160Class::setAccelDLPFMode(uint8_t mode) {\n    return reg_write_bits(BMI160_RA_ACCEL_CONF, mode,\n                          BMI160_ACCEL_DLPF_SEL_BIT,\n                          BMI160_ACCEL_DLPF_SEL_LEN);\n}\n\n/** Get full-scale gyroscope range.\n * The gyr_range parameter allows setting the full-scale range of the gyro sensors,\n * as described in the table below.\n *\n * <pre>\n * 4 = +/-  125 degrees/sec\n * 3 = +/-  250 degrees/sec\n * 2 = +/-  500 degrees/sec\n * 1 = +/- 1000 degrees/sec\n * 0 = +/- 2000 degrees/sec\n * </pre>\n *\n * @return Current full-scale gyroscope range setting\n * @see BMI160_RA_GYRO_RANGE\n * @see BMI160GyroRange\n */\nuint8_t BMI160Class::getFullScaleGyroRange() {\n    return reg_read_bits(BMI160_RA_GYRO_RANGE,\n                         BMI160_GYRO_RANGE_SEL_BIT,\n                         BMI160_GYRO_RANGE_SEL_LEN);\n}\n\n/** Set full-scale gyroscope range.\n * @param range New full-scale gyroscope range value\n * @see getFullScaleGyroRange()\n */\nvoid BMI160Class::setFullScaleGyroRange(uint8_t range) {\n    reg_write_bits(BMI160_RA_GYRO_RANGE, range,\n                   BMI160_GYRO_RANGE_SEL_BIT,\n                   BMI160_GYRO_RANGE_SEL_LEN);\n}\n\n/** Get full-scale accelerometer range.\n * The FS_SEL parameter allows setting the full-scale range of the accelerometer\n * sensors, as described in the table below.\n *\n * <pre>\n *  3 = +/- 2g\n *  5 = +/- 4g\n *  8 = +/- 8g\n * 12 = +/- 16g\n * </pre>\n *\n * @return Current full-scale accelerometer range setting\n * @see BMI160_RA_ACCEL_RANGE\n * @see BMI160AccelRange\n */\nuint8_t BMI160Class::getFullScaleAccelRange() {\n    return reg_read_bits(BMI160_RA_ACCEL_RANGE,\n                         BMI160_ACCEL_RANGE_SEL_BIT,\n                         BMI160_ACCEL_RANGE_SEL_LEN);\n}\n\n/** Set full-scale accelerometer range.\n * @param range New full-scale accelerometer range setting\n * @see getFullScaleAccelRange()\n * @see BMI160AccelRange\n */\nvoid BMI160Class::setFullScaleAccelRange(uint8_t range) {\n    reg_write_bits(BMI160_RA_ACCEL_RANGE, range,\n                   BMI160_ACCEL_RANGE_SEL_BIT,\n                   BMI160_ACCEL_RANGE_SEL_LEN);\n}\n\n/** Get accelerometer offset compensation enabled value.\n * @see getXAccelOffset()\n * @see BMI160_RA_OFFSET_6\n */\nbool BMI160Class::getAccelOffsetEnabled() {\n    return !!(reg_read_bits(BMI160_RA_OFFSET_6,\n                            BMI160_ACC_OFFSET_EN,\n                            1));\n}\n\n/** Set accelerometer offset compensation enabled value.\n * @see getXAccelOffset()\n * @see BMI160_RA_OFFSET_6\n */\nvoid BMI160Class::setAccelOffsetEnabled(bool enabled) {\n    reg_write_bits(BMI160_RA_OFFSET_6, enabled ? 0x1 : 0,\n                   BMI160_ACC_OFFSET_EN,\n                   1);\n}\n\n/** Execute internal calibration to generate Accelerometer X-Axis offset value.\n * This populates the Accelerometer offset compensation value for the X-Axis only.\n * These can be retrieved using the getXAccelOffset() methods.\n * Note that this procedure may take up to 250ms to complete.\n *\n * IMPORTANT: The user MUST ensure NO movement and correct orientation of the\n * BMI160 device occurs while this auto-calibration process is active.\n * For example, to calibrate to a target of 0g on the X-axis, the BMI160 device\n * must be resting horizontally as shown in Section 5.2 of the BMI160 Data Sheet.\n *\n * To enable offset compensation, @see setAccelOffsetEnabled()\n *\n * @param target X-axis target value (0 = 0g, 1 = +1g, -1 = -1g)\n * @see setAccelOffsetEnabled()\n * @see getXAccelOffset()\n * @see BMI160_RA_FOC_CONF\n * @see BMI160_RA_CMD\n */\nvoid BMI160Class::autoCalibrateXAccelOffset(int target) {\n    uint8_t foc_conf;\n    if (target == 1)\n        foc_conf = (0x1 << BMI160_FOC_ACC_X_BIT);\n    else if (target == -1)\n        foc_conf = (0x2 << BMI160_FOC_ACC_X_BIT);\n    else if (target == 0)\n        foc_conf = (0x3 << BMI160_FOC_ACC_X_BIT);\n    else\n        return;  /* Invalid target value */\n\n    reg_write(BMI160_RA_FOC_CONF, foc_conf);\n    reg_write(BMI160_RA_CMD, BMI160_CMD_START_FOC);\n    while (!(reg_read_bits(BMI160_RA_STATUS,\n                           BMI160_STATUS_FOC_RDY,\n                           1)))\n        delay(1);\n}\n\n/** Execute internal calibration to generate Accelerometer Y-Axis offset value.\n * This populates the Accelerometer offset compensation value for the Y-Axis only.\n * These can be retrieved using the getYAccelOffset() methods.\n * Note that this procedure may take up to 250ms to complete.\n *\n * IMPORTANT: The user MUST ensure NO movement and correct orientation of the\n * BMI160 device occurs while this auto-calibration process is active.\n * For example, to calibrate to a target of 0g on the Y-axis, the BMI160 device\n * must be resting horizontally as shown in Section 5.2 of the BMI160 Data Sheet.\n *\n * To enable offset compensation, @see setAccelOffsetEnabled()\n *\n * @param target Y-axis target value (0 = 0g, 1 = +1g, -1 = -1g)\n * @see setAccelOffsetEnabled()\n * @see getYAccelOffset()\n * @see BMI160_RA_FOC_CONF\n * @see BMI160_RA_CMD\n */\nvoid BMI160Class::autoCalibrateYAccelOffset(int target) {\n    uint8_t foc_conf;\n    if (target == 1)\n        foc_conf = (0x1 << BMI160_FOC_ACC_Y_BIT);\n    else if (target == -1)\n        foc_conf = (0x2 << BMI160_FOC_ACC_Y_BIT);\n    else if (target == 0)\n        foc_conf = (0x3 << BMI160_FOC_ACC_Y_BIT);\n    else\n        return;  /* Invalid target value */\n\n    reg_write(BMI160_RA_FOC_CONF, foc_conf);\n    reg_write(BMI160_RA_CMD, BMI160_CMD_START_FOC);\n    while (!(reg_read_bits(BMI160_RA_STATUS,\n                           BMI160_STATUS_FOC_RDY,\n                           1)))\n        delay(1);\n}\n\n/** Execute internal calibration to generate Accelerometer Z-Axis offset value.\n * This populates the Accelerometer offset compensation value for the Z-Axis only.\n * These can be retrieved using the getZAccelOffset() methods.\n * Note that this procedure may take up to 250ms to complete.\n *\n * IMPORTANT: The user MUST ensure NO movement and correct orientation of the\n * BMI160 device occurs while this auto-calibration process is active.\n * For example, to calibrate to a target of +1g on the Z-axis, the BMI160 device\n * must be resting horizontally as shown in Section 5.2 of the BMI160 Data Sheet.\n *\n * To enable offset compensation, @see setAccelOffsetEnabled()\n *\n * @param target Z-axis target value (0 = 0g, 1 = +1g, -1 = -1g)\n * @see setAccelOffsetEnabled()\n * @see getZAccelOffset()\n * @see BMI160_RA_FOC_CONF\n * @see BMI160_RA_CMD\n */\nvoid BMI160Class::autoCalibrateZAccelOffset(int target) {\n    uint8_t foc_conf;\n    if (target == 1)\n        foc_conf = (0x1 << BMI160_FOC_ACC_Z_BIT);\n    else if (target == -1)\n        foc_conf = (0x2 << BMI160_FOC_ACC_Z_BIT);\n    else if (target == 0)\n        foc_conf = (0x3 << BMI160_FOC_ACC_Z_BIT);\n    else\n        return;  /* Invalid target value */\n\n    reg_write(BMI160_RA_FOC_CONF, foc_conf);\n    reg_write(BMI160_RA_CMD, BMI160_CMD_START_FOC);\n    while (!(reg_read_bits(BMI160_RA_STATUS,\n                           BMI160_STATUS_FOC_RDY,\n                           1)))\n        delay(1);\n}\n\n/** Get offset compensation value for accelerometer X-axis data.\n * The value is represented as an 8-bit two-complement number in\n * units of 3.9mg per LSB.\n * @see BMI160_RA_OFFSET_0\n */\nint8_t BMI160Class::getXAccelOffset() {\n    return reg_read(BMI160_RA_OFFSET_0);\n}\n\n/** Set offset compensation value for accelerometer X-axis data.\n * This is used for applying manual calibration constants if required.\n * For auto-calibration, @see autoCalibrateXAccelOffset().\n * @see getXAccelOffset()\n * @see BMI160_RA_OFFSET_0\n */\nvoid BMI160Class::setXAccelOffset(int8_t offset) {\n    reg_write(BMI160_RA_OFFSET_0, offset);\n    getAccelerationX(); /* Read and discard the next data value */\n}\n\n/** Get offset compensation value for accelerometer Y-axis data.\n * The value is represented as an 8-bit two-complement number in\n * units of 3.9mg per LSB.\n * @see BMI160_RA_OFFSET_1\n */\nint8_t BMI160Class::getYAccelOffset() {\n    return reg_read(BMI160_RA_OFFSET_1);\n}\n\n/** Set offset compensation value for accelerometer Y-axis data.\n * This is used for applying manual calibration constants if required.\n * For auto-calibration, @see autoCalibrateYAccelOffset().\n * @see getYAccelOffset()\n * @see BMI160_RA_OFFSET_1\n */\nvoid BMI160Class::setYAccelOffset(int8_t offset) {\n    reg_write(BMI160_RA_OFFSET_1, offset);\n    getAccelerationY(); /* Read and discard the next data value */\n}\n\n/** Get offset compensation value for accelerometer Z-axis data.\n * The value is represented as an 8-bit two-complement number in\n * units of 3.9mg per LSB.\n * @see BMI160_RA_OFFSET_2\n */\nint8_t BMI160Class::getZAccelOffset() {\n    return reg_read(BMI160_RA_OFFSET_2);\n}\n\n/** Set offset compensation value for accelerometer Z-axis data.\n * This is used for applying manual calibration constants if required.\n * For auto-calibration, @see autoCalibrateZAccelOffset().\n * @see getZAccelOffset()\n * @see BMI160_RA_OFFSET_2\n */\nvoid BMI160Class::setZAccelOffset(int8_t offset) {\n    reg_write(BMI160_RA_OFFSET_2, offset);\n    getAccelerationZ(); /* Read and discard the next data value */\n}\n\n/** Get gyroscope offset compensation enabled value.\n * @see getXGyroOffset()\n * @see BMI160_RA_OFFSET_6\n */\nbool BMI160Class::getGyroOffsetEnabled() {\n    return !!(reg_read_bits(BMI160_RA_OFFSET_6,\n                            BMI160_GYR_OFFSET_EN,\n                            1));\n}\n\n/** Set gyroscope offset compensation enabled value.\n * @see getXGyroOffset()\n * @see BMI160_RA_OFFSET_6\n */\nvoid BMI160Class::setGyroOffsetEnabled(bool enabled) {\n    reg_write_bits(BMI160_RA_OFFSET_6, enabled ? 0x1 : 0,\n                   BMI160_GYR_OFFSET_EN,\n                   1) ;\n}\n\n/** Execute internal calibration to generate Gyro offset values.\n * This populates the Gyro offset compensation values for all 3 axes.\n * These can be retrieved using the get[X/Y/Z]GyroOffset() methods.\n * Note that this procedure may take up to 250ms to complete.\n *\n * IMPORTANT: The user MUST ensure that NO rotation of the BMI160 device\n * occurs while this auto-calibration process is active.\n *\n * To enable offset compensation, @see setGyroOffsetEnabled()\n * @see setGyroOffsetEnabled()\n * @see getXGyroOffset()\n * @see getYGyroOffset()\n * @see getZGyroOffset()\n * @see BMI160_RA_FOC_CONF\n * @see BMI160_RA_CMD\n */\nvoid BMI160Class::autoCalibrateGyroOffset() {\n    uint8_t foc_conf = (1 << BMI160_FOC_GYR_EN);\n    reg_write(BMI160_RA_FOC_CONF, foc_conf);\n    reg_write(BMI160_RA_CMD, BMI160_CMD_START_FOC);\n    while (!(reg_read_bits(BMI160_RA_STATUS,\n                           BMI160_STATUS_FOC_RDY,\n                           1)))\n        delay(1);\n}\n\n/** Get offset compensation value for gyroscope X-axis data.\n * The value is represented as an 10-bit two-complement number in\n * units of 0.061 degrees/s per LSB (sign-extended for int16_t type).\n * @see BMI160_RA_OFFSET_3\n * @see BMI160_RA_OFFSET_6\n */\nint16_t BMI160Class::getXGyroOffset() {\n    int16_t offset = reg_read(BMI160_RA_OFFSET_3);\n    offset |= (int16_t)(reg_read_bits(BMI160_RA_OFFSET_6,\n                                      BMI160_GYR_OFFSET_X_MSB_BIT,\n                                      BMI160_GYR_OFFSET_X_MSB_LEN)) << 8;\n    return BMI160_SIGN_EXTEND(offset, 10);\n}\n\n/** Set offset compensation value for gyroscope X-axis data.\n * This is used for applying manual calibration constants if required.\n * For auto-calibration, @see autoCalibrateGyroOffset().\n * @see getXGyroOffset()\n * @see BMI160_RA_OFFSET_3\n * @see BMI160_RA_OFFSET_6\n */\nvoid BMI160Class::setXGyroOffset(int16_t offset) {\n    reg_write(BMI160_RA_OFFSET_3, offset);\n    reg_write_bits(BMI160_RA_OFFSET_6, offset >> 8,\n                   BMI160_GYR_OFFSET_X_MSB_BIT,\n                   BMI160_GYR_OFFSET_X_MSB_LEN);\n    getRotationX(); /* Read and discard the next data value */\n}\n\n/** Get offset compensation value for gyroscope Y-axis data.\n * The value is represented as an 10-bit two-complement number in\n * units of 0.061 degrees/s per LSB (sign-extended for int16_t type).\n * @see BMI160_RA_OFFSET_4\n * @see BMI160_RA_OFFSET_6\n */\nint16_t BMI160Class::getYGyroOffset() {\n    int16_t offset = reg_read(BMI160_RA_OFFSET_4);\n    offset |= (int16_t)(reg_read_bits(BMI160_RA_OFFSET_6,\n                                      BMI160_GYR_OFFSET_Y_MSB_BIT,\n                                      BMI160_GYR_OFFSET_Y_MSB_LEN)) << 8;\n    return BMI160_SIGN_EXTEND(offset, 10);\n}\n\n/** Set offset compensation value for gyroscope Y-axis data.\n * This is used for applying manual calibration constants if required.\n * For auto-calibration, @see autoCalibrateGyroOffset().\n * @see getYGyroOffset()\n * @see BMI160_RA_OFFSET_4\n * @see BMI160_RA_OFFSET_6\n */\nvoid BMI160Class::setYGyroOffset(int16_t offset) {\n    reg_write(BMI160_RA_OFFSET_4, offset);\n    reg_write_bits(BMI160_RA_OFFSET_6, offset >> 8,\n                   BMI160_GYR_OFFSET_Y_MSB_BIT,\n                   BMI160_GYR_OFFSET_Y_MSB_LEN);\n    getRotationY(); /* Read and discard the next data value */\n}\n\n/** Get offset compensation value for gyroscope Z-axis data.\n * The value is represented as an 10-bit two-complement number in\n * units of 0.061 degrees/s per LSB (sign-extended for int16_t type).\n * @see BMI160_RA_OFFSET_5\n * @see BMI160_RA_OFFSET_6\n */\nint16_t BMI160Class::getZGyroOffset() {\n    int16_t offset = reg_read(BMI160_RA_OFFSET_5);\n    offset |= (int16_t)(reg_read_bits(BMI160_RA_OFFSET_6,\n                                      BMI160_GYR_OFFSET_Z_MSB_BIT,\n                                      BMI160_GYR_OFFSET_Z_MSB_LEN)) << 8;\n    return BMI160_SIGN_EXTEND(offset, 10);\n}\n\n/** Set offset compensation value for gyroscope Z-axis data.\n * This is used for applying manual calibration constants if required.\n * For auto-calibration, @see autoCalibrateGyroOffset().\n * @see getZGyroOffset()\n * @see BMI160_RA_OFFSET_5\n * @see BMI160_RA_OFFSET_6\n */\nvoid BMI160Class::setZGyroOffset(int16_t offset) {\n    reg_write(BMI160_RA_OFFSET_5, offset);\n    reg_write_bits(BMI160_RA_OFFSET_6, offset >> 8,\n                   BMI160_GYR_OFFSET_Z_MSB_BIT,\n                   BMI160_GYR_OFFSET_Z_MSB_LEN);\n    getRotationZ(); /* Read and discard the next data value */\n}\n\n/** Get free-fall event acceleration threshold.\n * This register configures the detection threshold for Free Fall event\n * detection. The unit of int_low_th is 1LSB = 7.81mg (min: 3.91mg). Free Fall\n * is detected when the absolute value of the accelerometer measurements for the\n * three axes are each less than the detection threshold. This condition\n * triggers the Free-Fall (low-g) interrupt if the condition is maintained for\n * the duration specified in the int_low_dur field of the INT_LOWHIGH[0]\n * register (@see BMI160_RA_INT_LOWHIGH_0)\n *\n * For more details on the Free Fall detection interrupt, see Section 2.6.7 of the\n * BMI160 Data Sheet.\n *\n * @return Current free-fall acceleration threshold value (LSB = 7.81mg, 0 = 3.91mg)\n * @see BMI160_RA_INT_LOWHIGH_1\n */\nuint8_t BMI160Class::getFreefallDetectionThreshold() {\n    return reg_read(BMI160_RA_INT_LOWHIGH_1);\n}\n\n/** Set free-fall event acceleration threshold.\n * @param threshold New free-fall acceleration threshold value (LSB = 7.81mg, 0 = 3.91mg)\n * @see getFreefallDetectionThreshold()\n * @see BMI160_RA_INT_LOWHIGH_1\n */\nvoid BMI160Class::setFreefallDetectionThreshold(uint8_t threshold) {\n    reg_write(BMI160_RA_INT_LOWHIGH_1, threshold);\n}\n\n/** Get free-fall event duration threshold.\n * This register configures the duration threshold for Free Fall event\n * detection. The int_low_dur field of the INT_LOWHIGH[0] register has a unit\n * of 1 LSB = 2.5 ms (minimum 2.5ms).\n *\n * For more details on the Free Fall detection interrupt, see Section 2.6.7 of\n * the BMI160 Data Sheet.\n *\n * @return Current free-fall duration threshold value (LSB = 2.5ms, 0 = 2.5ms)\n * @see BMI160_RA_INT_LOWHIGH_0\n */\nuint8_t BMI160Class::getFreefallDetectionDuration() {\n    return reg_read(BMI160_RA_INT_LOWHIGH_0);\n}\n\n/** Set free-fall event duration threshold.\n * @param duration New free-fall duration threshold value (LSB = 2.5ms, 0 = 2.5ms)\n * @see getFreefallDetectionDuration()\n * @see BMI160_RA_INT_LOWHIGH_0\n */\nvoid BMI160Class::setFreefallDetectionDuration(uint8_t duration) {\n    reg_write(BMI160_RA_INT_LOWHIGH_0, duration);\n}\n\n/** Get shock event acceleration threshold.\n * This register configures the detection threshold for Shock event\n * detection. The unit of threshold is dependent on the accelerometer\n * sensitivity range (@see getFullScaleAccelRange()):\n *\n * <pre>\n * Full Scale Range | LSB Resolution\n * -----------------+----------------\n * +/- 2g           |  7.81 mg/LSB (0 =  3.91mg)\n * +/- 4g           | 15.63 mg/LSB (0 =  7.81mg)\n * +/- 8g           | 31.25 mg/LSB (0 = 15.63mg)\n * +/- 16g          | 62.50 mg/LSB (0 = 31.25mg)\n * </pre>\n *\n * Shock is detected when the absolute value of the accelerometer measurements\n * for any of the three axes exceeds the detection threshold. This condition\n * triggers the Shock (high-g) interrupt if the condition is maintained without\n * a sign-change for the duration specified in the int_high_dur field of the\n * INT_LOWHIGH[3] register (@see BMI160_RA_INT_LOWHIGH_3).\n *\n * For more details on the Shock (high-g) detection interrupt, see Section 2.6.8 of the\n * BMI160 Data Sheet.\n *\n * @return Current shock acceleration threshold value\n * @see BMI160_RA_INT_LOWHIGH_4\n */\nuint8_t BMI160Class::getShockDetectionThreshold() {\n    return reg_read(BMI160_RA_INT_LOWHIGH_4);\n}\n\n/** Set shock event acceleration threshold.\n * @param threshold New shock acceleration threshold value\n * @see getShockDetectionThreshold()\n * @see BMI160_RA_INT_LOWHIGH_4\n */\nvoid BMI160Class::setShockDetectionThreshold(uint8_t threshold) {\n    reg_write(BMI160_RA_INT_LOWHIGH_4, threshold);\n}\n\n/** Get shock event duration threshold.\n * This register configures the duration threshold for Shock event\n * detection. The int_high_dur field of the INT_LOWHIGH[3] register has a unit\n * of 1 LSB = 2.5 ms (minimum 2.5ms).\n *\n * For more details on the Shock detection interrupt, see Section 2.6.8 of\n * the BMI160 Data Sheet.\n *\n * @return Current shock duration threshold value (LSB = 2.5ms, 0 = 2.5ms)\n * @see BMI160_RA_INT_LOWHIGH_3\n */\nuint8_t BMI160Class::getShockDetectionDuration() {\n    return reg_read(BMI160_RA_INT_LOWHIGH_3);\n}\n\n/** Set free-fall event duration threshold.\n * @param duration New free-fall duration threshold value (LSB = 2.5ms, 0 = 2.5ms)\n * @see getFreefallDetectionDuration()\n * @see BMI160_RA_INT_LOWHIGH_3\n */\nvoid BMI160Class::setShockDetectionDuration(uint8_t duration) {\n    reg_write(BMI160_RA_INT_LOWHIGH_3, duration);\n}\n\n/** Get Step Detection mode.\n * Returns an enum value which corresponds to current mode\n * 0 = Normal Mode\n * 1 = Sensitive Mode\n * 2 = Robust Mode\n * 3 = Unkown Mode\n * For more details on the Step Detection, see Section\n * 2.11.37 of the BMI160 Data Sheet.\n *\n * @return Current configuration of the step detector\n * @see BMI160_RA_STEP_CONF_0\n * @see BMI160_RA_STEP_CONF_1\n */\nuint8_t BMI160Class::getStepDetectionMode() {\n    uint8_t ret_step_conf0, ret_min_step_buf;\n\n    ret_step_conf0 = reg_read(BMI160_RA_STEP_CONF_0);\n    ret_min_step_buf = reg_read(BMI160_RA_STEP_CONF_1);\n\n    if ((ret_step_conf0 == BMI160_RA_STEP_CONF_0_NOR) && (ret_min_step_buf == BMI160_RA_STEP_CONF_1_NOR))\n        return BMI160_STEP_MODE_NORMAL;\n    else if ((ret_step_conf0 == BMI160_RA_STEP_CONF_0_SEN) && (ret_min_step_buf == BMI160_RA_STEP_CONF_1_SEN))\n\treturn BMI160_STEP_MODE_SENSITIVE;\n    else if ((ret_step_conf0 == BMI160_RA_STEP_CONF_0_ROB) && (ret_min_step_buf == BMI160_RA_STEP_CONF_1_ROB))\n        return BMI160_STEP_MODE_ROBUST;\n    else\n        return BMI160_STEP_MODE_UNKNOWN;\n}\n\n/** Set Step Detection mode.\n * Sets the step detection mode to one of 3 predefined sensitivity settings:\n *\n *  @see BMI160_STEP_MODE_NORMAL (Recommended for most applications)\n *  @see BMI160_STEP_MODE_SENSITIVE\n *  @see BMI160_STEP_MODE_ROBUST\n *\n * Please refer to Section 2.11.37 of the BMI160 Data Sheet for more information\n * on Step Detection configuration.\n *\n * @return Set Step Detection mode\n * @see BMI160_RA_STEP_CONF_0\n * @see BMI160_RA_STEP_CONF_1\n * @see BMI160StepMode\n */\nvoid BMI160Class::setStepDetectionMode(BMI160StepMode mode) {\n    uint8_t step_conf0, min_step_buf;\n\n    /* Applying pre-defined values suggested in data-sheet Section 2.11.37 */\n    switch (mode) {\n    case BMI160_STEP_MODE_NORMAL:\n        step_conf0 = 0x15;\n        min_step_buf = 0x3;\n        break;\n    case BMI160_STEP_MODE_SENSITIVE:\n        step_conf0 = 0x2D;\n        min_step_buf = 0x0;\n        break;\n    case BMI160_STEP_MODE_ROBUST:\n        step_conf0 = 0x1D;\n        min_step_buf = 0x7;\n        break;\n    default:\n        /* Unrecognised mode option */\n        return;\n    };\n\n    reg_write(BMI160_RA_STEP_CONF_0, step_conf0);\n    reg_write_bits(BMI160_RA_STEP_CONF_1, min_step_buf,\n                   BMI160_STEP_BUF_MIN_BIT,\n                   BMI160_STEP_BUF_MIN_LEN);\n}\n\n\n/** Get Step Counter enabled status.\n * Once enabled and configured correctly (@see setStepDetectionMode()), the\n * BMI160 will increment a counter for every step detected by the accelerometer.\n * To retrieve the current step count, @see getStepCount().\n *\n * For more details on the Step Counting feature, see Section\n * 2.7 of the BMI160 Data Sheet.\n *\n * @return Current Step Counter enabled status\n * @see BMI160_RA_STEP_CONF_1\n * @see BMI160_STEP_CNT_EN_BIT\n */\nbool BMI160Class::getStepCountEnabled() {\n    return !!(reg_read_bits(BMI160_RA_STEP_CONF_1,\n                            BMI160_STEP_CNT_EN_BIT,\n                            1));\n}\n\n/** Set Step Counter enabled status.\n *\n * @return Set Step Counter enabled\n * @see getStepCountEnabled()\n * @see BMI160_RA_STEP_CONF_1\n * @see BMI160_STEP_CNT_EN_BIT\n */\nvoid BMI160Class::setStepCountEnabled(bool enabled) {\n    return reg_write_bits(BMI160_RA_STEP_CONF_1, enabled ? 0x1 : 0,\n                          BMI160_STEP_CNT_EN_BIT,\n                          1);\n}\n\n\n/** Get current number of detected step movements (Step Count).\n * Returns a step counter which is incremented when step movements are detected\n * (assuming Step Detection mode and Step Counter are configured/enabled).\n *\n * @return Number of steps as an unsigned 16-bit integer\n * @see setStepCountEnabled()\n * @see setStepDetectionMode()\n * @see BMI160_RA_STEP_CNT_L\n */\nuint16_t BMI160Class::getStepCount() {\n    uint8_t buffer[2];\n    buffer[0] = BMI160_RA_STEP_CNT_L;\n    serial_buffer_transfer(buffer, 1, 2);\n    return (((uint16_t)buffer[1]) << 8) | buffer[0];\n}\n\n/** Resets the current number of detected step movements (Step Count) to 0.\n *\n * @see getStepCount()\n * @see BMI160_RA_CMD\n */\nvoid BMI160Class::resetStepCount() {\n    reg_write(BMI160_RA_CMD, BMI160_CMD_STEP_CNT_CLR);\n}\n\n/** Get motion detection event acceleration threshold.\n * This register configures the detection threshold for Motion interrupt\n * generation in the INT_MOTION[1] register. The unit of threshold is\n * dependent on the accelerometer sensitivity range (@see\n * getFullScaleAccelRange()):\n *\n * <pre>\n * Full Scale Range | LSB Resolution\n * -----------------+----------------\n * +/- 2g           |  3.91 mg/LSB\n * +/- 4g           |  7.81 mg/LSB\n * +/- 8g           | 15.63 mg/LSB\n * +/- 16g          | 31.25 mg/LSB\n * </pre>\n *\n * Motion is detected when the difference between the absolute value of\n * consecutive accelerometer measurements for the 3 axes exceeds this Motion\n * detection threshold. This condition triggers the Motion interrupt if the\n * condition is maintained for the sample count interval specified in the\n * int_anym_dur field of the INT_MOTION[0] register (@see BMI160_RA_INT_MOTION_0)\n *\n * The Motion interrupt will indicate the axis and polarity of detected motion\n * in INT_STATUS[2] (@see BMI160_RA_INT_STATUS_2).\n *\n * For more details on the Motion detection interrupt, see Section 2.6.1 of the\n * BMI160 Data Sheet.\n *\n * @return Current motion detection acceleration threshold value\n * @see getMotionDetectionDuration()\n * @see BMI160_RA_INT_MOTION_1\n */\nuint8_t BMI160Class::getMotionDetectionThreshold() {\n    return reg_read(BMI160_RA_INT_MOTION_1);\n}\n\n/** Set motion detection event acceleration threshold.\n * @param threshold New motion detection acceleration threshold value\n * @see getMotionDetectionThreshold()\n * @see BMI160_RA_INT_MOTION_1\n */\nvoid BMI160Class::setMotionDetectionThreshold(uint8_t threshold) {\n    return reg_write(BMI160_RA_INT_MOTION_1, threshold);\n}\n\n/** Get motion detection event duration threshold.\n * This register configures the duration counter threshold for Motion interrupt\n * generation, as a number of consecutive samples (from 1-4). The time\n * between samples depends on the accelerometer Output Data Rate\n * (@see getAccelRate()).\n *\n * The Motion detection interrupt is triggered when the difference between\n * samples exceeds the Any-Motion interrupt threshold for the number of\n * consecutive samples specified here.\n *\n * For more details on the Motion detection interrupt, see Section 2.6.1 of the\n * BMI160 Data Sheet.\n *\n * @return Current motion detection duration threshold value (#samples [1-4])\n * @see getMotionDetectionThreshold()\n * @see BMI160_RA_INT_MOTION_0\n */\nuint8_t BMI160Class::getMotionDetectionDuration() {\n    return 1 + reg_read_bits(BMI160_RA_INT_MOTION_0,\n                             BMI160_ANYMOTION_DUR_BIT,\n                             BMI160_ANYMOTION_DUR_LEN);\n}\n\n/** Set motion detection event duration threshold.\n * @param duration New motion detection duration threshold value (#samples [1-4])\n * @see getMotionDetectionDuration()\n * @see BMI160_RA_INT_MOTION_0\n */\nvoid BMI160Class::setMotionDetectionDuration(uint8_t samples) {\n    reg_write_bits(BMI160_RA_INT_MOTION_0, samples - 1,\n                   BMI160_ANYMOTION_DUR_BIT,\n                   BMI160_ANYMOTION_DUR_LEN);\n}\n\n/** Get zero motion detection event acceleration threshold.\n * This register configures the detection threshold for Zero Motion interrupt\n * generation in the INT_MOTION[1] register. The unit of threshold is\n * dependent on the accelerometer sensitivity range\n * (@see getFullScaleAccelRange()) as follows:\n *\n * <pre>\n * Full Scale Range | LSB Resolution\n * -----------------+----------------\n * +/- 2g           |  3.91 mg/LSB\n * +/- 4g           |  7.81 mg/LSB\n * +/- 8g           | 15.63 mg/LSB\n * +/- 16g          | 31.25 mg/LSB\n * </pre>\n *\n * Zero Motion is detected when the difference between the value of\n * consecutive accelerometer measurements for each axis remains smaller than\n * this Motion detection threshold. This condition triggers the Zero Motion\n * interrupt if the condition is maintained for a time duration \n * specified in the int_slo_no_mot_dur field of the INT_MOTION[0] register (@see\n * BMI160_RA_INT_MOTION_0), and clears the interrupt when the condition is\n * then absent for the same duration.\n *\n * For more details on the Zero Motion detection interrupt, see Section 2.6.9 of\n * the BMI160 Data Sheet.\n *\n * @return Current zero motion detection acceleration threshold value\n * @see getZeroMotionDetectionDuration()\n * @see BMI160_RA_INT_MOTION_2\n */\nuint8_t BMI160Class::getZeroMotionDetectionThreshold() {\n    return reg_read(BMI160_RA_INT_MOTION_2);\n}\n\n/** Set zero motion detection event acceleration threshold.\n * @param threshold New zero motion detection acceleration threshold value\n * @see getZeroMotionDetectionThreshold()\n * @see BMI160_RA_INT_MOTION_2\n */\nvoid BMI160Class::setZeroMotionDetectionThreshold(uint8_t threshold) {\n    reg_write(BMI160_RA_INT_MOTION_2, threshold);\n}\n\n/** Get zero motion detection event duration threshold.\n * This register configures the duration time for Zero Motion interrupt\n * generation. A time range between 1.28s and 430.08s can be selected, but the\n * granularity of the timing reduces as the duration increases:\n *\n * <pre>\n * Duration           | Granularity\n * -------------------+----------------\n * [1.28 - 20.48]s    |  1.28s\n * [25.6 - 102.4]s    |  5.12s\n * [112.64 - 430.08]s | 10.24s\n * </pre>\n *\n * The Zero Motion interrupt is triggered when the Zero Motion condition is\n * maintained for the duration specified in this register.\n *\n * For more details on the Zero Motion detection interrupt, see Section 2.6.9 of\n * the BMI160 Data Sheet.\n *\n * @return Current zero motion detection duration threshold value\n *         @see BMI160ZeroMotionDuration for a list of possible values\n * @see getZeroMotionDetectionThreshold()\n * @see BMI160_RA_INT_MOTION_0\n * @see BMI160ZeroMotionDuration\n */\nuint8_t BMI160Class::getZeroMotionDetectionDuration() {\n    return reg_read_bits(BMI160_RA_INT_MOTION_0,\n                         BMI160_NOMOTION_DUR_BIT,\n                         BMI160_NOMOTION_DUR_LEN);\n}\n\n/** Set zero motion detection event duration threshold.\n *\n * This must be called at least once to enable zero-motion detection.\n *\n * @param duration New zero motion detection duration threshold value\n *        @see BMI160ZeroMotionDuration for a list of valid values\n * @see getZeroMotionDetectionDuration()\n * @see BMI160_RA_INT_MOTION_0\n * @see BMI160ZeroMotionDuration\n */\nvoid BMI160Class::setZeroMotionDetectionDuration(uint8_t duration) {\n    reg_write_bits(BMI160_RA_INT_MOTION_0, duration,\n                   BMI160_NOMOTION_DUR_BIT,\n                   BMI160_NOMOTION_DUR_LEN);\n}\n\n/** Get Tap event acceleration threshold.\n * This register configures the detection threshold for Tap event\n * detection. The threshold is expressed a 5-bit unsigned integer.\n * The unit of threshold is dependent on the accelerometer\n * sensitivity range (@see getFullScaleAccelRange()):\n *\n * <pre>\n * Full Scale Range | LSB Resolution\n * -----------------+----------------\n * +/- 2g           |  62.5 mg/LSB (0 =  31.25mg)\n * +/- 4g           | 125.0 mg/LSB (0 =  62.5mg)\n * +/- 8g           | 250.0 mg/LSB (0 = 125.0mg)\n * +/- 16g          | 500.0 mg/LSB (0 = 250.0mg)\n * </pre>\n *\n * A Tap is detected as a shock event which exceeds the detection threshold for\n * a specified duration.  A threshold between 0.7g and 1.5g in the 2g\n * measurement range is suggested for typical tap detection applications.\n * \n * For more details on the Tap detection interrupt, see Section 2.6.4 of the\n * BMI160 Data Sheet.\n *\n * @return Current shock acceleration threshold value\n * @see BMI160_RA_INT_TAP_1\n */\nuint8_t BMI160Class::getTapDetectionThreshold() {\n    return reg_read_bits(BMI160_RA_INT_TAP_1,\n                         BMI160_TAP_THRESH_BIT,\n                         BMI160_TAP_THRESH_LEN);\n}\n\n/** Set tap event acceleration threshold.\n * @param threshold New tap acceleration threshold value\n * @see getTapDetectionThreshold()\n * @see BMI160_RA_INT_TAP_1\n */\nvoid BMI160Class::setTapDetectionThreshold(uint8_t threshold) {\n    reg_write_bits(BMI160_RA_INT_TAP_1, threshold,\n                   BMI160_TAP_THRESH_BIT,\n                   BMI160_TAP_THRESH_LEN);\n}\n\n/** Get tap shock detection duration.\n * This register configures the duration for a tap event generation.\n *\n * The time will be returned as a 1-bit boolean, with the following\n * values (@see BMI160TapShockDuration)\n *\n * <pre>\n * duration specifier | duration threshold\n * -------------------+----------------\n *  0b0               |  50ms\n *  0b1               |  75ms\n * </pre>\n *\n * For more details on the Tap detection interrupt, see Section 2.6.4 of the\n * BMI160 Data Sheet.\n *\n * @return Current tap detection duration threshold value\n * @see BMI160_RA_INT_TAP_0\n * @see BMI160TapShockDuration\n */\nbool BMI160Class::getTapShockDuration() {\n    return !!(reg_read_bits(BMI160_RA_INT_TAP_0,\n                            BMI160_TAP_SHOCK_BIT,\n                            1));\n}\n\n/** Set tap shock detection event duration threshold.\n *\n * @param units New tap detection duration threshold value\n * @see getTapShockDetectionDuration()\n * @see BMI160_RA_INT_TAP_0\n */\nvoid BMI160Class::setTapShockDuration(bool duration) {\n    reg_write_bits(BMI160_RA_INT_TAP_0, duration ? 0x1 : 0,\n                   BMI160_TAP_SHOCK_BIT,\n                   1);\n}\n\n/** Get tap quiet duration threshold.\n * This register configures the quiet duration for double-tap event detection.\n *\n * The time will be returned as a 1-bit boolean, with the following\n * values (@see BMI160TapQuietDuration)\n *\n * <pre>\n * duration specifier | duration threshold\n * -------------------+----------------\n *  0b0               |  30ms\n *  0b1               |  20ms\n * </pre>\n *\n * For more details on the Tap detection interrupt, see Section 2.6.4 of the\n * BMI160 Data Sheet.\n *\n * @return Current tap quiet detection duration threshold value\n * @see BMI160_RA_INT_TAP_0\n * @see BMI160TapQuietDuration\n */\nbool BMI160Class::getTapQuietDuration() {\n    return !!(reg_read_bits(BMI160_RA_INT_TAP_0,\n                            BMI160_TAP_QUIET_BIT,\n                            1));\n}\n\n/** Set tap quiet duration threshold.\n *\n * @param units New tap detection duration threshold value\n * @see getTapQuietDuration()\n * @see BMI160_RA_INT_TAP_0\n */\nvoid BMI160Class::setTapQuietDuration(bool duration) {\n    reg_write_bits(BMI160_RA_INT_TAP_0, duration ? 0x1 : 0,\n                   BMI160_TAP_QUIET_BIT,\n                   1);\n}\n\n/** Get double-tap detection time window length.\n * This register configures the length of time window between 2 tap events for\n * double-tap event generation.\n *\n * The time will be returned as a 3-bit unsigned integer, with the following\n * values (@see BMI160DoubleTapDuration)\n *\n * <pre>\n * duration specifier | length of time window\n * -------------------+----------------\n *  0b000             |  50ms\n *  0b001             | 100ms\n *  0b010             | 150ms\n *  0b011             | 200ms\n *  0b100             | 250ms\n *  0b101             | 375ms\n *  0b110             | 500ms\n *  0b111             | 700ms\n * </pre>\n *\n * For more details on the Tap detection interrupt, see Section 2.6.4 of the\n * BMI160 Data Sheet.\n *\n * @return Current double-tap detection time window threshold value\n * @see BMI160_RA_INT_TAP_0\n * @see BMI160DoubleTapDuration\n */\nuint8_t BMI160Class::getDoubleTapDetectionDuration() {\n    return reg_read_bits(BMI160_RA_INT_TAP_0,\n                         BMI160_TAP_DUR_BIT,\n                         BMI160_TAP_DUR_LEN);\n}\n\n/** Set double-tap detection event duration threshold.\n *\n * @param duration New double-tap detection time window threshold value\n * @see getDoubleTapDetectionDuration()\n * @see BMI160_RA_INT_TAP_0\n */\nvoid BMI160Class::setDoubleTapDetectionDuration(uint8_t duration) {\n    reg_write_bits(BMI160_RA_INT_TAP_0, duration,\n                   BMI160_TAP_DUR_BIT,\n                   BMI160_TAP_DUR_LEN);\n}\n\n/** Get Free Fall interrupt enabled status.\n * Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see BMI160_RA_INT_EN_1\n * @see BMI160_LOW_G_EN_BIT\n **/\nbool BMI160Class::getIntFreefallEnabled() {\n    return !!(reg_read_bits(BMI160_RA_INT_EN_1,\n                            BMI160_LOW_G_EN_BIT,\n                            BMI160_LOW_G_EN_LEN));\n}\n\n/** Set Free Fall interrupt enabled status.\n * @param enabled New interrupt enabled status\n * @see getIntFreefallEnabled()\n * @see BMI160_RA_INT_EN_1\n * @see BMI160_LOW_G_EN_BIT\n **/\nvoid BMI160Class::setIntFreefallEnabled(bool enabled) {\n    reg_write_bits(BMI160_RA_INT_EN_1, enabled ? 0x1 : 0,\n                   BMI160_LOW_G_EN_BIT,\n                   BMI160_LOW_G_EN_LEN);\n}\n\n/** Get Shock interrupt enabled status.\n * Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see BMI160_RA_INT_EN_1\n * @see BMI160_HIGH_G_EN_BIT\n **/\nbool BMI160Class::getIntShockEnabled() {\n    return !!(reg_read_bits(BMI160_RA_INT_EN_1,\n                            BMI160_HIGH_G_EN_BIT,\n                            BMI160_HIGH_G_EN_LEN));\n}\n\n/** Set Shock interrupt enabled status.\n * @param enabled New interrupt enabled status\n * @see getIntShockEnabled()\n * @see BMI160_RA_INT_EN_1\n * @see BMI160_HIGH_G_EN_BIT\n **/\nvoid BMI160Class::setIntShockEnabled(bool enabled) {\n    reg_write_bits(BMI160_RA_INT_EN_1, enabled ? 0x7 : 0x0,\n                   BMI160_HIGH_G_EN_BIT,\n                   BMI160_HIGH_G_EN_LEN);\n}\n\n/** Get Step interrupt enabled status.\n * Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see BMI160_RA_INT_EN_2\n * @see BMI160_STEP_EN_BIT\n **/\nbool BMI160Class::getIntStepEnabled() {\n    return !!(reg_read_bits(BMI160_RA_INT_EN_2,\n                            BMI160_STEP_EN_BIT,\n                            1));\n}\n\n/** Set Step interrupt enabled status.\n * @param enabled New interrupt enabled status\n * @see getIntStepEnabled()\n * @see BMI160_RA_INT_EN_2\n * @see BMI160_STEP_EN_BIT\n **/\nvoid BMI160Class::setIntStepEnabled(bool enabled) {\n    reg_write_bits(BMI160_RA_INT_EN_2, enabled ? 0x1 : 0x0,\n                   BMI160_STEP_EN_BIT,\n                   1);\n}\n\n/** Get Motion Detection interrupt enabled status.\n * Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see BMI160_RA_INT_EN_0\n * @see BMI160_ANYMOTION_EN_BIT\n **/\nbool BMI160Class::getIntMotionEnabled() {\n    return !!(reg_read_bits(BMI160_RA_INT_EN_0,\n                            BMI160_ANYMOTION_EN_BIT,\n                            BMI160_ANYMOTION_EN_LEN));\n}\n\n/** Set Motion Detection interrupt enabled status.\n * @param enabled New interrupt enabled status\n * @see getIntMotionEnabled()\n * @see BMI160_RA_INT_EN_0\n * @see BMI160_ANYMOTION_EN_BIT\n **/\nvoid BMI160Class::setIntMotionEnabled(bool enabled) {\n    /* Enable for all 3 axes */\n    reg_write_bits(BMI160_RA_INT_EN_0, enabled ? 0x7 : 0x0,\n                   BMI160_ANYMOTION_EN_BIT,\n                   BMI160_ANYMOTION_EN_LEN);\n}\n\n/** Get Zero Motion Detection interrupt enabled status.\n * Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see BMI160_RA_INT_EN_2\n * @see BMI160_NOMOTION_EN_BIT\n **/\nbool BMI160Class::getIntZeroMotionEnabled() {\n    return !!(reg_read_bits(BMI160_RA_INT_EN_2,\n                            BMI160_NOMOTION_EN_BIT,\n                            BMI160_NOMOTION_EN_LEN));\n}\n\n/** Set Zero Motion Detection interrupt enabled status.\n * @param enabled New interrupt enabled status\n * @see getIntZeroMotionEnabled()\n * @see BMI160_RA_INT_EN_2\n * @see BMI160_NOMOTION_EN_BIT\n * @see BMI160_RA_INT_MOTION_3\n **/\nvoid BMI160Class::setIntZeroMotionEnabled(bool enabled) {\n    if (enabled) {\n        /* Select No-Motion detection mode */\n        reg_write_bits(BMI160_RA_INT_MOTION_3, 0x1,\n                       BMI160_NOMOTION_SEL_BIT,\n                       BMI160_NOMOTION_SEL_LEN);\n    }\n    /* Enable for all 3 axes */\n    reg_write_bits(BMI160_RA_INT_EN_2, enabled ? 0x7 : 0x0,\n                   BMI160_NOMOTION_EN_BIT,\n                   BMI160_NOMOTION_EN_LEN);\n}\n\n/** Get Tap Detection interrupt enabled status.\n * Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see BMI160_RA_INT_EN_0\n * @see BMI160_S_TAP_EN_BIT\n **/\nbool BMI160Class::getIntTapEnabled() {\n    return !!(reg_read_bits(BMI160_RA_INT_EN_0,\n                            BMI160_S_TAP_EN_BIT,\n                            1));\n}\n\n/** Set Tap Detection interrupt enabled status.\n * @param enabled New interrupt enabled status\n * @see getIntTapEnabled()\n * @see BMI160_RA_INT_EN_0\n * @see BMI160_S_TAP_EN_BIT\n **/\nvoid BMI160Class::setIntTapEnabled(bool enabled) {\n    reg_write_bits(BMI160_RA_INT_EN_0, enabled ? 0x1 : 0,\n                   BMI160_S_TAP_EN_BIT,\n                   1);\n}\n\n/** Get Tap Detection interrupt enabled status.\n * Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see BMI160_RA_INT_EN_0\n * @see BMI160_D_TAP_EN_BIT\n **/\nbool BMI160Class::getIntDoubleTapEnabled() {\n    return !!(reg_read_bits(BMI160_RA_INT_EN_0,\n                            BMI160_D_TAP_EN_BIT,\n                            1));\n}\n\n/** Set Tap Detection interrupt enabled status.\n * @param enabled New interrupt enabled status\n * @see getIntTapEnabled()\n * @see BMI160_RA_INT_EN_0\n * @see BMI160_D_TAP_EN_BIT\n **/\nvoid BMI160Class::setIntDoubleTapEnabled(bool enabled) {\n    reg_write_bits(BMI160_RA_INT_EN_0, enabled ? 0x1 : 0,\n                   BMI160_D_TAP_EN_BIT,\n                   1);\n}\n\n/** Get FIFO Buffer Full interrupt enabled status.\n * Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see BMI160_RA_INT_EN_1\n * @see BMI160_FFULL_EN_BIT\n **/\nbool BMI160Class::getIntFIFOBufferFullEnabled() {\n    return !!(reg_read_bits(BMI160_RA_INT_EN_1,\n                            BMI160_FFULL_EN_BIT,\n                            1));\n}\n\n/** Set FIFO Buffer Full interrupt enabled status.\n * @param enabled New interrupt enabled status\n * @see getIntFIFOBufferFullEnabled()\n * @see BMI160_RA_INT_EN_1\n * @see BMI160_FFULL_EN_BIT\n **/\nvoid BMI160Class::setIntFIFOBufferFullEnabled(bool enabled) {\n    reg_write_bits(BMI160_RA_INT_EN_1, enabled ? 0x1 : 0x0,\n                   BMI160_FFULL_EN_BIT,\n                   1);\n}\n\n/** Get Data Ready interrupt enabled setting.\n * This event occurs each time a write operation to all of the sensor registers\n * has been completed. Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see BMI160_RA_INT_EN_1\n * @see BMI160_DRDY_EN_BIT\n */\nbool BMI160Class::getIntDataReadyEnabled() {\n    return !!(reg_read_bits(BMI160_RA_INT_EN_1,\n                            BMI160_DRDY_EN_BIT,\n                            1));\n}\n\n/** Set Data Ready interrupt enabled status.\n * @param enabled New interrupt enabled status\n * @see getIntDataReadyEnabled()\n * @see BMI160_RA_INT_EN_1\n * @see BMI160_DRDY_EN_BIT\n */\nvoid BMI160Class::setIntDataReadyEnabled(bool enabled) {\n    reg_write_bits(BMI160_RA_INT_EN_1, enabled ? 0x1 : 0x0,\n                   BMI160_DRDY_EN_BIT,\n                   1);\n}\n\n/** Get accelerometer FIFO enabled value.\n * When set to 1, this bit enables accelerometer data samples to be\n * written into the FIFO buffer.\n * @return Current accelerometer FIFO enabled value\n * @see BMI160_RA_FIFO_CONFIG_1\n */\nbool BMI160Class::getAccelFIFOEnabled() {\n    return !!(reg_read_bits(BMI160_RA_FIFO_CONFIG_1,\n                            BMI160_FIFO_ACC_EN_BIT,\n                            1));\n}\n\n/** Set accelerometer FIFO enabled value.\n * @param enabled New accelerometer FIFO enabled value\n * @see getAccelFIFOEnabled()\n * @see BMI160_RA_FIFO_CONFIG_1\n */\nvoid BMI160Class::setAccelFIFOEnabled(bool enabled) {\n    reg_write_bits(BMI160_RA_FIFO_CONFIG_1, enabled ? 0x1 : 0,\n                   BMI160_FIFO_ACC_EN_BIT,\n                   1);\n}\n\n/** Get gyroscope FIFO enabled value.\n * When set to 1, this bit enables gyroscope data samples to be\n * written into the FIFO buffer.\n * @return Current gyroscope FIFO enabled value\n * @see BMI160_RA_FIFO_CONFIG_1\n */\nbool BMI160Class::getGyroFIFOEnabled() {\n    return !!(reg_read_bits(BMI160_RA_FIFO_CONFIG_1,\n                            BMI160_FIFO_GYR_EN_BIT,\n                            1));\n}\n\n/** Set gyroscope FIFO enabled value.\n * @param enabled New gyroscope FIFO enabled value\n * @see getGyroFIFOEnabled()\n * @see BMI160_RA_FIFO_CONFIG_1\n */\nvoid BMI160Class::setGyroFIFOEnabled(bool enabled) {\n    reg_write_bits(BMI160_RA_FIFO_CONFIG_1, enabled ? 0x1 : 0,\n                   BMI160_FIFO_GYR_EN_BIT,\n                   1);\n}\n\n/** Get current FIFO buffer size.\n * This value indicates the number of bytes stored in the FIFO buffer. This\n * number is in turn the number of bytes that can be read from the FIFO buffer.\n *\n * In \"headerless\" FIFO mode, it is directly proportional to the number of\n * samples available given the set of sensor data bound to be stored in the\n * FIFO. See @ref getFIFOHeaderModeEnabled().\n *\n * @return Current FIFO buffer size\n * @see BMI160_RA_FIFO_LENGTH_0\n */\nuint16_t BMI160Class::getFIFOCount() {\n    uint8_t buffer[2];\n    buffer[0] = BMI160_RA_FIFO_LENGTH_0;\n    serial_buffer_transfer(buffer, 1, 2);\n    return (((int16_t)buffer[1]) << 8) | buffer[0];\n}\n\n/** Reset the FIFO.\n * This command clears all data in the FIFO buffer.  It is recommended\n * to invoke this after reconfiguring the FIFO.\n * \n * @see BMI160_RA_CMD\n * @see BMI160_CMD_FIFO_FLUSH\n */\nvoid BMI160Class::resetFIFO() {\n    reg_write(BMI160_RA_CMD, BMI160_CMD_FIFO_FLUSH);\n}\n\n/** Reset the Interrupt controller.\n * This command clears interrupt status registers and latched interrupts.\n * \n * @see BMI160_RA_CMD\n * @see BMI160_CMD_FIFO_FLUSH\n */\nvoid BMI160Class::resetInterrupt() {\n    reg_write(BMI160_RA_CMD, BMI160_CMD_INT_RESET);\n}\n\n/** Get FIFO Header-Mode enabled status.\n * When this bit is set to 0, the FIFO header-mode is disabled, and frames\n * read from the FIFO will be headerless (raw sensor data only).\n * When this bit is set to 1, the FIFO header-mode is enabled, and frames\n * read from the FIFO will include headers.\n *\n * For more information on the FIFO modes and data formats, please refer\n * to Section 2.5 of the BMI160 Data Sheet.\n *\n * @return Current FIFO Header-Mode enabled status\n * @see BMI160_RA_FIFO_CONFIG_1\n * @see BMI160_FIFO_HEADER_EN_BIT\n */\nbool BMI160Class::getFIFOHeaderModeEnabled() {\n    return !!(reg_read_bits(BMI160_RA_FIFO_CONFIG_1,\n                            BMI160_FIFO_HEADER_EN_BIT,\n                            1));\n}\n\n/** Set FIFO Header-Mode enabled status.\n * @param enabled New FIFO Header-Mode enabled status\n * @see getFIFOHeaderModeEnabled()\n * @see BMI160_RA_FIFO_CONFIG_1\n * @see BMI160_FIFO_HEADER_EN_BIT\n */\nvoid BMI160Class::setFIFOHeaderModeEnabled(bool enabled) {\n    reg_write_bits(BMI160_RA_FIFO_CONFIG_1, enabled ? 0x1 : 0,\n                   BMI160_FIFO_HEADER_EN_BIT,\n                   1);\n}\n\n/** Get data frames from FIFO buffer.\n * This register is used to read and write data frames from the FIFO buffer.\n * Data is written to the FIFO in order of DATA register number (from lowest\n * to highest) corresponding to the FIFO data sources enabled (@see\n * getGyroFIFOEnabled() and getAccelFIFOEnabled()).\n *\n * The data frame format depends on the enabled data sources and also on\n * the FIFO header-mode setting (@see getFIFOHeaderModeEnabled()).\n *\n * It is strongly recommended, where possible, to read whole frames from the\n * FIFO.  Partially-read frames will be repeated until fully read out.\n *\n * If the FIFO buffer has filled to the point where subsequent writes may\n * cause data loss, the status bit ffull_int is automatically set to 1. This bit\n * is located in INT_STATUS[1]. When the FIFO buffer has overflowed, the oldest\n * data will be lost and new data will be written to the FIFO.\n *\n * If the FIFO buffer is empty, reading this register will return a magic number\n * (@see BMI160_FIFO_DATA_INVALID) until new data is available. The user should\n * check FIFO_LENGTH to ensure that the FIFO buffer is not read when empty (see\n * @getFIFOCount()).\n *\n * @return Data frames from FIFO buffer\n */\nvoid BMI160Class::getFIFOBytes(uint8_t *data, uint16_t length) {\n    if (length) {\n        data[0] = BMI160_RA_FIFO_DATA;\n        serial_buffer_transfer(data, 1, length);\n    }\n}\n\n/** Get full set of interrupt status bits from INT_STATUS[0] register.\n * Interrupts are typically cleared automatically.\n * Please refer to the BMI160 Data Sheet for more information.\n * @return Current interrupt status\n * @see BMI160_RA_INT_STATUS_0\n */\nuint8_t BMI160Class::getIntStatus0() {\n    return reg_read(BMI160_RA_INT_STATUS_0);\n}\n\n/** Get full set of interrupt status bits from INT_STATUS[1] register.\n * Interrupts are typically cleared automatically.\n * Please refer to the BMI160 Data Sheet for more information.\n * @return Current interrupt status\n * @see BMI160_RA_INT_STATUS_1\n */\nuint8_t BMI160Class::getIntStatus1() {\n    return reg_read(BMI160_RA_INT_STATUS_1);\n}\n\n/** Get full set of interrupt status bits from INT_STATUS[2] register.\n * Interrupts are typically cleared automatically.\n * Please refer to the BMI160 Data Sheet for more information.\n * @return Current interrupt status\n * @see BMI160_RA_INT_STATUS_2\n */\nuint8_t BMI160Class::getIntStatus2() {\n    return reg_read(BMI160_RA_INT_STATUS_2);\n}\n\n/** Get full set of interrupt status bits from INT_STATUS[3] register.\n * Interrupts are typically cleared automatically.\n * Please refer to the BMI160 Data Sheet for more information.\n * @return Current interrupt status\n * @see BMI160_RA_INT_STATUS_3\n */\nuint8_t BMI160Class::getIntStatus3() {\n    return reg_read(BMI160_RA_INT_STATUS_3);\n}\n\n/** Get Free Fall interrupt status.\n * This bit automatically sets to 1 when a Free Fall condition\n * is present, and clears when the condition is no longer present.\n *\n * For more details on the Free-Fall (Low-G) detection interrupt, see Section\n * 2.6.7 of the BMI160 Data Sheet.\n *\n * @return Current interrupt status\n * @see BMI160_RA_INT_STATUS_1\n * @see BMI160_LOW_G_INT_BIT\n */\nbool BMI160Class::getIntFreefallStatus() {\n    return !!(reg_read_bits(BMI160_RA_INT_STATUS_1,\n                            BMI160_LOW_G_INT_BIT,\n                            1));\n}\n\n/** Get Tap Detection interrupt status.\n * This bit automatically sets to 1 when a Tap Detection condition\n * is present, and clears when the condition is no longer present.\n *\n * For more details on the Tap detection interrupt, see Section 2.6.4 of the\n * BMI160 Data Sheet.\n *\n * @return Current interrupt status\n * @see BMI160_RA_INT_STATUS_0\n * @see BMI160_S_TAP_INT_BIT\n */\nbool BMI160Class::getIntTapStatus() {\n    return !!(reg_read_bits(BMI160_RA_INT_STATUS_0,\n                            BMI160_S_TAP_INT_BIT,\n                            1));\n}\n\n/** Get Double-Tap Detection interrupt status.\n * This bit automatically sets to 1 when a Double-Tap Detection condition\n * is present, and clears when the condition is no longer present.\n *\n * For more details on the Double-Tap detection interrupt, see Section 2.6.4 of the\n * BMI160 Data Sheet.\n *\n * @return Current interrupt status\n * @see BMI160_RA_INT_STATUS_0\n * @see BMI160_D_TAP_INT_BIT\n */\nbool BMI160Class::getIntDoubleTapStatus() {\n    return !!(reg_read_bits(BMI160_RA_INT_STATUS_0,\n                            BMI160_D_TAP_INT_BIT,\n                            1));\n}\n\n/** Get Shock interrupt status.\n * This bit automatically sets to 1 when a Shock (High-G) Detection condition\n * is present, and clears when the condition is no longer present.\n *\n * For more details on the Shock (High-G) detection interrupt, see Section\n * 2.6.8 of the BMI160 Data Sheet.\n *\n * @return Current interrupt status\n * @see BMI160_RA_INT_STATUS_1\n * @see BMI160_HIGH_G_INT_BIT\n */\nbool BMI160Class::getIntShockStatus() {\n    return !!(reg_read_bits(BMI160_RA_INT_STATUS_1,\n                            BMI160_HIGH_G_INT_BIT,\n                            1));\n}\n\n/** Check if shock interrupt was triggered by negative X-axis motion\n * @return Shock detection status\n * @see BMI160_RA_INT_STATUS_3\n * @see BMI160_HIGH_G_SIGN_BIT\n * @see BMI160_HIGH_G_1ST_X_BIT\n */\nbool BMI160Class::getXNegShockDetected() {\n    uint8_t status = reg_read(BMI160_RA_INT_STATUS_3);\n    return !!((status & (1 << BMI160_HIGH_G_SIGN_BIT)) &&\n              (status & (1 << BMI160_HIGH_G_1ST_X_BIT)));\n}\n\n/** Check if shock interrupt was triggered by positive X-axis motion\n * @return Shock detection status\n * @see BMI160_RA_INT_STATUS_3\n * @see BMI160_HIGH_G_SIGN_BIT\n * @see BMI160_HIGH_G_1ST_X_BIT\n */\nbool BMI160Class::getXPosShockDetected() {\n    uint8_t status = reg_read(BMI160_RA_INT_STATUS_3);\n    return !!(!(status & (1 << BMI160_HIGH_G_SIGN_BIT)) &&\n              (status & (1 << BMI160_HIGH_G_1ST_X_BIT)));\n}\n\n/** Check if shock interrupt was triggered by negative Y-axis motion\n * @return Shock detection status\n * @see BMI160_RA_INT_STATUS_3\n * @see BMI160_HIGH_G_SIGN_BIT\n * @see BMI160_HIGH_G_1ST_Y_BIT\n */\nbool BMI160Class::getYNegShockDetected() {\n    uint8_t status = reg_read(BMI160_RA_INT_STATUS_3);\n    return !!((status & (1 << BMI160_HIGH_G_SIGN_BIT)) &&\n              (status & (1 << BMI160_HIGH_G_1ST_Y_BIT)));\n}\n\n/** Check if shock interrupt was triggered by positive Y-axis motion\n * @return Shock detection status\n * @see BMI160_RA_INT_STATUS_3\n * @see BMI160_HIGH_G_SIGN_BIT\n * @see BMI160_HIGH_G_1ST_Y_BIT\n */\nbool BMI160Class::getYPosShockDetected() {\n    uint8_t status = reg_read(BMI160_RA_INT_STATUS_3);\n    return !!(!(status & (1 << BMI160_HIGH_G_SIGN_BIT)) &&\n              (status & (1 << BMI160_HIGH_G_1ST_Y_BIT)));\n}\n\n/** Check if shock interrupt was triggered by negative Z-axis motion\n * @return Shock detection status\n * @see BMI160_RA_INT_STATUS_3\n * @see BMI160_HIGH_G_SIGN_BIT\n * @see BMI160_HIGH_G_1ST_Z_BIT\n */\nbool BMI160Class::getZNegShockDetected() {\n    uint8_t status = reg_read(BMI160_RA_INT_STATUS_3);\n    return !!((status & (1 << BMI160_HIGH_G_SIGN_BIT)) &&\n              (status & (1 << BMI160_HIGH_G_1ST_Z_BIT)));\n}\n\n/** Check if shock interrupt was triggered by positive Z-axis motion\n * @return Shock detection status\n * @see BMI160_RA_INT_STATUS_3\n * @see BMI160_HIGH_G_SIGN_BIT\n * @see BMI160_HIGH_G_1ST_Z_BIT\n */\nbool BMI160Class::getZPosShockDetected() {\n    uint8_t status = reg_read(BMI160_RA_INT_STATUS_3);\n    return !!(!(status & (1 << BMI160_HIGH_G_SIGN_BIT)) &&\n              (status & (1 << BMI160_HIGH_G_1ST_Z_BIT)));\n}\n\n/** Get Step interrupt status.\n * This bit automatically sets to 1 when a Step Detection condition\n * is present, and clears when the condition is no longer present.\n *\n * For more details on the Step detection interrupt, see Section\n * 2.6.3 of the BMI160 Data Sheet.\n *\n * @return Current interrupt status\n * @see BMI160_RA_INT_STATUS_0\n * @see BMI160_STEP_INT_BIT\n */\nbool BMI160Class::getIntStepStatus() {\n    return !!(reg_read_bits(BMI160_RA_INT_STATUS_0,\n                            BMI160_STEP_INT_BIT,\n                            1));\n}\n\n/** Get Motion Detection interrupt status.\n * This bit automatically sets to 1 when a Motion Detection condition\n * is present, and clears when the condition is no longer present.\n *\n * For more details on the Motion detection interrupt, see Section 2.6.1 of the\n * BMI160 Data Sheet.\n *\n * @return Current interrupt status\n * @see BMI160_RA_INT_STATUS_0\n * @see BMI160_ANYMOTION_INT_BIT\n */\nbool BMI160Class::getIntMotionStatus() {\n    return !!(reg_read_bits(BMI160_RA_INT_STATUS_0,\n                            BMI160_ANYMOTION_INT_BIT,\n                            1));\n}\n\n/** Check if motion interrupt was triggered by negative X-axis motion\n * @return Motion detection status\n * @see BMI160_RA_INT_STATUS_2\n * @see BMI160_ANYMOTION_SIGN_BIT\n * @see BMI160_ANYMOTION_1ST_X_BIT\n */\nbool BMI160Class::getXNegMotionDetected() {\n    uint8_t status = reg_read(BMI160_RA_INT_STATUS_2);\n    return !!((status & (1 << BMI160_ANYMOTION_SIGN_BIT)) &&\n              (status & (1 << BMI160_ANYMOTION_1ST_X_BIT)));\n}\n\n/** Check if motion interrupt was triggered by positive X-axis motion\n * @return Motion detection status\n * @see BMI160_RA_INT_STATUS_2\n * @see BMI160_ANYMOTION_SIGN_BIT\n * @see BMI160_ANYMOTION_1ST_X_BIT\n */\nbool BMI160Class::getXPosMotionDetected() {\n    uint8_t status = reg_read(BMI160_RA_INT_STATUS_2);\n    return !!(!(status & (1 << BMI160_ANYMOTION_SIGN_BIT)) &&\n              (status & (1 << BMI160_ANYMOTION_1ST_X_BIT)));\n}\n\n/** Check if motion interrupt was triggered by negative Y-axis motion\n * @return Motion detection status\n * @see BMI160_RA_INT_STATUS_2\n * @see BMI160_ANYMOTION_SIGN_BIT\n * @see BMI160_ANYMOTION_1ST_Y_BIT\n */\nbool BMI160Class::getYNegMotionDetected() {\n    uint8_t status = reg_read(BMI160_RA_INT_STATUS_2);\n    return !!((status & (1 << BMI160_ANYMOTION_SIGN_BIT)) &&\n              (status & (1 << BMI160_ANYMOTION_1ST_Y_BIT)));\n}\n\n/** Check if motion interrupt was triggered by positive Y-axis motion\n * @return Motion detection status\n * @see BMI160_RA_INT_STATUS_2\n * @see BMI160_ANYMOTION_SIGN_BIT\n * @see BMI160_ANYMOTION_1ST_Y_BIT\n */\nbool BMI160Class::getYPosMotionDetected() {\n    uint8_t status = reg_read(BMI160_RA_INT_STATUS_2);\n    return !!(!(status & (1 << BMI160_ANYMOTION_SIGN_BIT)) &&\n              (status & (1 << BMI160_ANYMOTION_1ST_Y_BIT)));\n}\n\n/** Check if motion interrupt was triggered by negative Z-axis motion\n * @return Motion detection status\n * @see BMI160_RA_INT_STATUS_2\n * @see BMI160_ANYMOTION_SIGN_BIT\n * @see BMI160_ANYMOTION_1ST_Z_BIT\n */\nbool BMI160Class::getZNegMotionDetected() {\n    uint8_t status = reg_read(BMI160_RA_INT_STATUS_2);\n    return !!((status & (1 << BMI160_ANYMOTION_SIGN_BIT)) &&\n              (status & (1 << BMI160_ANYMOTION_1ST_Z_BIT)));\n}\n\n/** Check if motion interrupt was triggered by positive Z-axis motion\n * @return Motion detection status\n * @see BMI160_RA_INT_STATUS_2\n * @see BMI160_ANYMOTION_SIGN_BIT\n * @see BMI160_ANYMOTION_1ST_Z_BIT\n */\nbool BMI160Class::getZPosMotionDetected() {\n    uint8_t status = reg_read(BMI160_RA_INT_STATUS_2);\n    return !!(!(status & (1 << BMI160_ANYMOTION_SIGN_BIT)) &&\n              (status & (1 << BMI160_ANYMOTION_1ST_Z_BIT)));\n}\n\n/** Check if tap interrupt was triggered by negative X-axis tap\n * @return Tap detection status\n * @see BMI160_RA_INT_STATUS_2\n * @see BMI160_TAP_SIGN_BIT\n * @see BMI160_TAP_1ST_X_BIT\n */\nbool BMI160Class::getXNegTapDetected() {\n    uint8_t status = reg_read(BMI160_RA_INT_STATUS_2);\n    return !!((status & (1 << BMI160_TAP_SIGN_BIT)) &&\n              (status & (1 << BMI160_TAP_1ST_X_BIT)));\n}\n\n/** Check if tap interrupt was triggered by positive X-axis tap\n * @return Tap detection status\n * @see BMI160_RA_INT_STATUS_2\n * @see BMI160_TAP_SIGN_BIT\n * @see BMI160_TAP_1ST_X_BIT\n */\nbool BMI160Class::getXPosTapDetected() {\n    uint8_t status = reg_read(BMI160_RA_INT_STATUS_2);\n    return !!(!(status & (1 << BMI160_TAP_SIGN_BIT)) &&\n              (status & (1 << BMI160_TAP_1ST_X_BIT)));\n}\n\n/** Check if tap interrupt was triggered by negative Y-axis tap\n * @return Tap detection status\n * @see BMI160_RA_INT_STATUS_2\n * @see BMI160_TAP_SIGN_BIT\n * @see BMI160_TAP_1ST_Y_BIT\n */\nbool BMI160Class::getYNegTapDetected() {\n    uint8_t status = reg_read(BMI160_RA_INT_STATUS_2);\n    return !!((status & (1 << BMI160_TAP_SIGN_BIT)) &&\n              (status & (1 << BMI160_TAP_1ST_Y_BIT)));\n}\n\n/** Check if tap interrupt was triggered by positive Y-axis tap\n * @return Tap detection status\n * @see BMI160_RA_INT_STATUS_2\n * @see BMI160_TAP_SIGN_BIT\n * @see BMI160_TAP_1ST_Y_BIT\n */\nbool BMI160Class::getYPosTapDetected() {\n    uint8_t status = reg_read(BMI160_RA_INT_STATUS_2);\n    return !!(!(status & (1 << BMI160_TAP_SIGN_BIT)) &&\n              (status & (1 << BMI160_TAP_1ST_Y_BIT)));\n}\n\n/** Check if tap interrupt was triggered by negative Z-axis tap\n * @return Tap detection status\n * @see BMI160_RA_INT_STATUS_2\n * @see BMI160_TAP_SIGN_BIT\n * @see BMI160_TAP_1ST_Z_BIT\n */\nbool BMI160Class::getZNegTapDetected() {\n    uint8_t status = reg_read(BMI160_RA_INT_STATUS_2);\n    return !!((status & (1 << BMI160_TAP_SIGN_BIT)) &&\n              (status & (1 << BMI160_TAP_1ST_Z_BIT)));\n}\n\n/** Check if tap interrupt was triggered by positive Z-axis tap\n * @return Tap detection status\n * @see BMI160_RA_INT_STATUS_2\n * @see BMI160_TAP_SIGN_BIT\n * @see BMI160_TAP_1ST_Z_BIT\n */\nbool BMI160Class::getZPosTapDetected() {\n    uint8_t status = reg_read(BMI160_RA_INT_STATUS_2);\n    return !!(!(status & (1 << BMI160_TAP_SIGN_BIT)) &&\n              (status & (1 << BMI160_TAP_1ST_Z_BIT)));\n}\n\n/** Get Zero Motion Detection interrupt status.\n * This bit automatically sets to 1 when a Zero Motion Detection condition\n * is present, and clears when the condition is no longer present.\n *\n * For more details on the Motion detection interrupt, see Section 2.6.9 of the\n * BMI160 Data Sheet.\n *\n * @return Current interrupt status\n * @see BMI160_RA_INT_STATUS_1\n * @see BMI160_NOMOTION_INT_BIT\n */\nbool BMI160Class::getIntZeroMotionStatus() {\n    return !!(reg_read_bits(BMI160_RA_INT_STATUS_1,\n                            BMI160_NOMOTION_INT_BIT,\n                            1));\n}\n\n/** Get FIFO Buffer Full interrupt status.\n * This bit automatically sets to 1 when a FIFO Full condition has been\n * generated. The bit clears to 0 when the FIFO is not full.\n * @return Current interrupt status\n * @see BMI160_RA_INT_STATUS_1\n * @see BMI160_FFULL_INT_BIT\n */\nbool BMI160Class::getIntFIFOBufferFullStatus() {\n    return !!(reg_read_bits(BMI160_RA_INT_STATUS_1,\n                            BMI160_FFULL_INT_BIT,\n                            1));\n}\n\n/** Get Data Ready interrupt status.\n * This bit automatically sets to 1 when a Data Ready interrupt has been\n * generated. The bit clears to 0 after the data registers have been read.\n * @return Current interrupt status\n * @see BMI160_RA_INT_STATUS_1\n * @see BMI160_FFULL_INT_BIT\n */\nbool BMI160Class::getIntDataReadyStatus() {\n    return !!(reg_read_bits(BMI160_RA_INT_STATUS_1,\n                            BMI160_DRDY_INT_BIT,\n                            1));\n}\n\n/** Get interrupt logic level mode.\n * Will be set 0 for active-high, 1 for active-low.\n * @return Current interrupt mode (0=active-high, 1=active-low)\n * @see BMI160_RA_INT_OUT_CTRL\n * @see BMI160_INT1_LVL\n */\nbool BMI160Class::getInterruptMode() {\n    return !(reg_read_bits(BMI160_RA_INT_OUT_CTRL,\n                           BMI160_INT1_LVL,\n                           1));\n}\n\n/** Set interrupt logic level mode.\n * @param mode New interrupt mode (0=active-high, 1=active-low)\n * @see getInterruptMode()\n * @see BMI160_RA_INT_OUT_CTRL\n * @see BMI160_INT1_LVL\n */\nvoid BMI160Class::setInterruptMode(bool mode) {\n    reg_write_bits(BMI160_RA_INT_OUT_CTRL, mode ? 0x0 : 0x1,\n                   BMI160_INT1_LVL,\n                   1);\n}\n\n/** Get interrupt drive mode.\n * Will be set 0 for push-pull, 1 for open-drain.\n * @return Current interrupt drive mode (0=push-pull, 1=open-drain)\n * @see BMI160_RA_INT_OUT_CTRL\n * @see BMI160_INT1_OD\n */\nbool BMI160Class::getInterruptDrive() {\n    return !!(reg_read_bits(BMI160_RA_INT_OUT_CTRL,\n                            BMI160_INT1_OD,\n                            1));\n}\n\n/** Set interrupt drive mode.\n * @param drive New interrupt drive mode (0=push-pull, 1=open-drain)\n * @see getInterruptDrive()\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_INT_OPEN_BIT\n */\nvoid BMI160Class::setInterruptDrive(bool drive) {\n    reg_write_bits(BMI160_RA_INT_OUT_CTRL, drive ? 0x1 : 0x0,\n                   BMI160_INT1_OD,\n                   1);\n}\n\n/** Get interrupt latch mode.  The following options are available:\n *\n * <pre>\n * Latch Mode    | Interrupt Latching\n * --------------+-------------------------\n * 0             | non-latched\n * 1             | temporary, 312.5us pulse\n * 2             | temporary,   625us pulse\n * 3             | temporary,  1.25ms pulse\n * 4             | temporary,   2.5ms pulse\n * 5             | temporary,     5ms pulse\n * 6             | temporary,    10ms pulse\n * 7             | temporary,    20ms pulse\n * 8             | temporary,    40ms pulse\n * 9             | temporary,    80ms pulse\n * 10            | temporary,   160ms pulse\n * 11            | temporary,   320ms pulse\n * 12            | temporary,   640ms pulse\n * 13            | temporary,  1.28s pulse\n * 14            | temporary,  2.56s pulse\n * 15            | latched until cleared (@see resetInterrupt())\n * </pre>\n *\n * Note that latching does not apply to the following interrupt sources:\n * - Data Ready\n * - Orientation (including Flat) detection\n *\n * @return Current latch mode\n * @see BMI160_RA_INT_LATCH\n * @see BMI160InterruptLatchMode\n */\nuint8_t BMI160Class::getInterruptLatch() {\n    return reg_read_bits(BMI160_RA_INT_LATCH,\n                         BMI160_LATCH_MODE_BIT,\n                         BMI160_LATCH_MODE_LEN);\n}\n\n/** Set interrupt latch mode.\n * @param latch New latch mode\n * @see getInterruptLatch()\n * @see BMI160_RA_INT_LATCH\n * @see BMI160InterruptLatchMode\n */\nvoid BMI160Class::setInterruptLatch(uint8_t mode) {\n    reg_write_bits(BMI160_RA_INT_LATCH, mode,\n                   BMI160_LATCH_MODE_BIT,\n                   BMI160_LATCH_MODE_LEN);\n}\n\n/** Get interrupt enabled status.\n * @return Current interrupt enabled status\n * @see BMI160_RA_INT_OUT_CTRL\n * @see BMI160_INT1_OUTPUT_EN\n **/\nbool BMI160Class::getIntEnabled() {\n    return !!(reg_read_bits(BMI160_RA_INT_OUT_CTRL,\n                            BMI160_INT1_OUTPUT_EN,\n                            1));\n}\n\n/** Set interrupt enabled status.\n * @param enabled New interrupt enabled status\n * @see BMI160_RA_INT_OUT_CTRL\n * @see BMI160_INT1_OUTPUT_EN\n **/\nvoid BMI160Class::setIntEnabled(bool enabled) {\n    reg_write_bits(BMI160_RA_INT_OUT_CTRL, enabled ? 0x1 : 0,\n                   BMI160_INT1_OUTPUT_EN,\n                   1);\n}\n\n/** Get raw 6-axis motion sensor readings (accel/gyro).\n * Retrieves all currently available motion sensor values.\n * @param ax 16-bit signed integer container for accelerometer X-axis value\n * @param ay 16-bit signed integer container for accelerometer Y-axis value\n * @param az 16-bit signed integer container for accelerometer Z-axis value\n * @param gx 16-bit signed integer container for gyroscope X-axis value\n * @param gy 16-bit signed integer container for gyroscope Y-axis value\n * @param gz 16-bit signed integer container for gyroscope Z-axis value\n * @see getAcceleration()\n * @see getRotation()\n * @see BMI160_RA_GYRO_X_L\n */\nvoid BMI160Class::getMotion6(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz) {\n    uint8_t buffer[12];\n    buffer[0] = BMI160_RA_GYRO_X_L;\n    serial_buffer_transfer(buffer, 1, 12);\n    *gx = (((int16_t)buffer[1])  << 8) | buffer[0];\n    *gy = (((int16_t)buffer[3])  << 8) | buffer[2];\n    *gz = (((int16_t)buffer[5])  << 8) | buffer[4];\n    *ax = (((int16_t)buffer[7])  << 8) | buffer[6];\n    *ay = (((int16_t)buffer[9])  << 8) | buffer[8];\n    *az = (((int16_t)buffer[11]) << 8) | buffer[10];\n}\n\n/** Get 3-axis accelerometer readings.\n * These registers store the most recent accelerometer measurements.\n * Accelerometer measurements are written to these registers at the Output Data Rate\n * as configured by @see getAccelRate()\n *\n * The accelerometer measurement registers, along with the temperature\n * measurement registers, gyroscope measurement registers, and external sensor\n * data registers, are composed of two sets of registers: an internal register\n * set and a user-facing read register set.\n *\n * The data within the accelerometer sensors' internal register set is always\n * updated at the Output Data Rate. Meanwhile, the user-facing read register set\n * duplicates the internal register set's data values whenever the serial\n * interface is idle. This guarantees that a burst read of sensor registers will\n * read measurements from the same sampling instant. Note that if burst reads\n * are not used, the user is responsible for ensuring a set of single byte reads\n * correspond to a single sampling instant by checking the Data Ready interrupt.\n *\n * Each 16-bit accelerometer measurement has a full scale configured by\n * @setFullScaleAccelRange. For each full scale setting, the accelerometers'\n * sensitivity per LSB is shown in the table below:\n *\n * <pre>\n * Full Scale Range | LSB Sensitivity\n * -----------------+----------------\n * +/- 2g           | 8192 LSB/mg\n * +/- 4g           | 4096 LSB/mg\n * +/- 8g           | 2048 LSB/mg\n * +/- 16g          | 1024 LSB/mg\n * </pre>\n *\n * @param x 16-bit signed integer container for X-axis acceleration\n * @param y 16-bit signed integer container for Y-axis acceleration\n * @param z 16-bit signed integer container for Z-axis acceleration\n * @see BMI160_RA_ACCEL_X_L\n */\nvoid BMI160Class::getAcceleration(int16_t* x, int16_t* y, int16_t* z) {\n    uint8_t buffer[6];\n    buffer[0] = BMI160_RA_ACCEL_X_L;\n    serial_buffer_transfer(buffer, 1, 6);\n    *x = (((int16_t)buffer[1]) << 8) | buffer[0];\n    *y = (((int16_t)buffer[3]) << 8) | buffer[2];\n    *z = (((int16_t)buffer[5]) << 8) | buffer[4];\n}\n\n/** Get X-axis accelerometer reading.\n * @return X-axis acceleration measurement in 16-bit 2's complement format\n * @see getMotion6()\n * @see BMI160_RA_ACCEL_X_L\n */\nint16_t BMI160Class::getAccelerationX() {\n    uint8_t buffer[2];\n    buffer[0] = BMI160_RA_ACCEL_X_L;\n    serial_buffer_transfer(buffer, 1, 2);\n    return (((int16_t)buffer[1]) << 8) | buffer[0];\n}\n\n/** Get Y-axis accelerometer reading.\n * @return Y-axis acceleration measurement in 16-bit 2's complement format\n * @see getMotion6()\n * @see BMI160_RA_ACCEL_Y_L\n */\nint16_t BMI160Class::getAccelerationY() {\n    uint8_t buffer[2];\n    buffer[0] = BMI160_RA_ACCEL_Y_L;\n    serial_buffer_transfer(buffer, 1, 2);\n    return (((int16_t)buffer[1]) << 8) | buffer[0];\n}\n\n/** Get Z-axis accelerometer reading.\n * @return Z-axis acceleration measurement in 16-bit 2's complement format\n * @see getMotion6()\n * @see BMI160_RA_ACCEL_Z_L\n */\nint16_t BMI160Class::getAccelerationZ() {\n    uint8_t buffer[2];\n    buffer[0] = BMI160_RA_ACCEL_Z_L;\n    serial_buffer_transfer(buffer, 1, 2);\n    return (((int16_t)buffer[1]) << 8) | buffer[0];\n}\n\n/** Get current internal temperature as a signed 16-bit integer.\n *  The resolution is typically 1/2^9 degrees Celcius per LSB, at an\n *  offset of 23 degrees Celcius.  For example:\n *\n * <pre>\n * Value    | Temperature\n * ---------+----------------\n * 0x7FFF   | 87 - 1/2^9 degrees C\n * ...      | ...\n * 0x0000   | 23 degrees C\n * ...      | ...\n * 0x8001   | -41 + 1/2^9 degrees C\n * 0x8000   | Invalid\n *\n * @return Temperature reading in 16-bit 2's complement format\n * @see BMI160_RA_TEMP_L\n */\nint16_t BMI160Class::getTemperature() {\n    uint8_t buffer[2];\n    buffer[0] = BMI160_RA_TEMP_L;\n    serial_buffer_transfer(buffer, 1, 2);\n    return (((int16_t)buffer[1]) << 8) | buffer[0];\n}\n\n/** Get 3-axis gyroscope readings.\n * These gyroscope measurement registers, along with the accelerometer\n * measurement registers, temperature measurement registers, and external sensor\n * data registers, are composed of two sets of registers: an internal register\n * set and a user-facing read register set.\n * The data within the gyroscope sensors' internal register set is always\n * updated at the Output Data Rate. Meanwhile, the user-facing read register set\n * duplicates the internal register set's data values whenever the serial\n * interface is idle. This guarantees that a burst read of sensor registers will\n * read measurements from the same sampling instant. Note that if burst reads\n * are not used, the user is responsible for ensuring a set of single byte reads\n * correspond to a single sampling instant by checking the Data Ready interrupt.\n *\n * Each 16-bit gyroscope measurement has a full scale configured by\n * @setFullScaleGyroRange(). For each full scale setting, the gyroscopes'\n * sensitivity per LSB is shown in the table below:\n *\n * <pre>\n * Full Scale Range   | LSB Sensitivity\n * -------------------+----------------\n * +/- 125  degrees/s | 262.4 LSB/deg/s\n * +/- 250  degrees/s | 131.2 LSB/deg/s\n * +/- 500  degrees/s | 65.5  LSB/deg/s\n * +/- 1000 degrees/s | 32.8  LSB/deg/s\n * +/- 2000 degrees/s | 16.4  LSB/deg/s\n * </pre>\n *\n * @param x 16-bit signed integer container for X-axis rotation\n * @param y 16-bit signed integer container for Y-axis rotation\n * @param z 16-bit signed integer container for Z-axis rotation\n * @see getMotion6()\n * @see BMI160_RA_GYRO_X_L\n */\nvoid BMI160Class::getRotation(int16_t* x, int16_t* y, int16_t* z) {\n    uint8_t buffer[6];\n    buffer[0] = BMI160_RA_GYRO_X_L;\n    serial_buffer_transfer(buffer, 1, 6);\n    *x = (((int16_t)buffer[1]) << 8) | buffer[0];\n    *y = (((int16_t)buffer[3]) << 8) | buffer[2];\n    *z = (((int16_t)buffer[5]) << 8) | buffer[4];\n}\n\n/** Get X-axis gyroscope reading.\n * @return X-axis rotation measurement in 16-bit 2's complement format\n * @see getMotion6()\n * @see BMI160_RA_GYRO_X_L\n */\nint16_t BMI160Class::getRotationX() {\n    uint8_t buffer[2];\n    buffer[0] = BMI160_RA_GYRO_X_L;\n    serial_buffer_transfer(buffer, 1, 2);\n    return (((int16_t)buffer[1]) << 8) | buffer[0];\n}\n\n/** Get Y-axis gyroscope reading.\n * @return Y-axis rotation measurement in 16-bit 2's complement format\n * @see getMotion6()\n * @see BMI160_RA_GYRO_Y_L\n */\nint16_t BMI160Class::getRotationY() {\n    uint8_t buffer[2];\n    buffer[0] = BMI160_RA_GYRO_Y_L;\n    serial_buffer_transfer(buffer, 1, 2);\n    return (((int16_t)buffer[1]) << 8) | buffer[0];\n}\n\n/** Get Z-axis gyroscope reading.\n * @return Z-axis rotation measurement in 16-bit 2's complement format\n * @see getMotion6()\n * @see BMI160_RA_GYRO_Z_L\n */\nint16_t BMI160Class::getRotationZ() {\n    uint8_t buffer[2];\n    buffer[0] = BMI160_RA_GYRO_Z_L;\n    serial_buffer_transfer(buffer, 1, 2);\n    return (((int16_t)buffer[1]) << 8) | buffer[0];\n}\n\n/** Read a BMI160 register directly.\n * @param reg register address\n * @return 8-bit register value\n */\nuint8_t BMI160Class::getRegister(uint8_t reg) {\n    return reg_read(reg);\n}\n\n/** Write a BMI160 register directly.\n * @param reg register address\n * @param data 8-bit register value\n */\nvoid BMI160Class::setRegister(uint8_t reg, uint8_t data) {\n    reg_write(reg, data);\n}\n"},{"name":"BMI160Gen.cpp","type":"source","group":"other","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"#include \"BMI160Gen.h\"\n#include \"Wire.h\"\n\n//#define DEBUG\n\nbool BMI160GenClass::begin(Mode mode, const int arg1, const int arg2)\n{\n    this->mode = mode;\n    i2c_addr = arg1;\n    return CurieIMUClass::begin();\n}\n\nvoid BMI160GenClass::ss_init()\n{\n    i2c_init();\n}\n\nint BMI160GenClass::ss_xfer(uint8_t *buf, unsigned tx_cnt, unsigned rx_cnt)\n{\n    return i2c_xfer(buf, tx_cnt, rx_cnt);\n}\n\nvoid BMI160GenClass::i2c_init()\n{\n  Wire.begin();\n  Wire.beginTransmission(i2c_addr);\n  if( Wire.endTransmission() != 0 )\n      Serial.println(\"BMI160GenClass::i2c_init(): I2C failed.\");\n}\n\nint BMI160GenClass::i2c_xfer(uint8_t *buf, unsigned tx_cnt, unsigned rx_cnt)\n{\n  uint8_t *p;\n\n  Wire.beginTransmission(i2c_addr);\n  p = buf;\n  while (0 < tx_cnt) {\n    tx_cnt--;\n    Wire.write(*p++);\n  }\n  if( Wire.endTransmission() != 0 ) {\n      Serial.println(\"Wire.endTransmission() failed.\");\n  }\n  if (0 < rx_cnt) {\n    Wire.requestFrom(i2c_addr, rx_cnt);\n    p = buf;\n    while ( Wire.available() && 0 < rx_cnt) {\n      rx_cnt--;\n#ifdef DEBUG\n      int t = *p++ = Wire.read();\n      Serial.print(\" \");\n      Serial.print(t, HEX);\n#else\n      *p++ = Wire.read();;\n#endif // DEBUG\n    }\n  }\n\n  return (0);\n}\n"},{"name":"BMI160wrapper.cpp","type":"source","group":"other","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"#include \"BMI160Gen.h\"\n\nBMI160GenClass BMI160;\n\nextern \"C\" void BMI160Gyro_Init(void)\n{\n  BMI160.begin(BMI160GenClass::I2C_MODE, 0x69);\n}\n\nextern \"C\" void BMI160Gyro_Read(int* pfData)\n{\n\tint gx, gy, gz;         // raw gyro values\n\t// read raw gyro measurements from device\n\tBMI160.readGyro(gx, gy, gz);\n\t\n    pfData[0]=gx;\n    pfData[1]=gy;\n    pfData[2]=gz;\n}\n\n"},{"name":"BMP180wrapper.cpp","type":"source","group":"other","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"// BMP180wrapper.cpp\n\n#include \"Wire.h\"\n#include \"Adafruit_BMP085.h\"\n\nAdafruit_BMP085 bmp; // I2C\n\nextern \"C\" void BMP180_Init(void)\n{\n\tbmp.begin();\n}\n\nextern \"C\" void BMP180_Read(float* pfData)\n{\n    pfData[0]=bmp.readPressure();\n\tpfData[1]=bmp.readAltitude();\n\tpfData[2]=bmp.readTemperature();\n}\n"},{"name":"BMP280wrapper.cpp","type":"source","group":"other","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"// BMP280wrapper.cpp\n\n#include \"Wire.h\"\n#include \"Adafruit_BMP280.h\"\n\nAdafruit_BMP280 bmp; // I2C\n\nextern \"C\" void BMP280_Init(void)\n{\n\tbmp.begin();\n}\n\nextern \"C\" void BMP280_Read(float* pfData)\n{\n    pfData[0]=bmp.readPressure();\n\tpfData[1]=bmp.readAltitude(1013.25);\n\tpfData[2]=bmp.readTemperature();\n}\n"},{"name":"CurieIMU.cpp","type":"source","group":"other","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright (c) 2015 Intel Corporation.  All rights reserved.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n *\n */\n\n#include \"CurieIMU.h\"\n//#include \"internal/ss_spi.h\"\n#if defined(BMI160GEN_USE_CURIEIMU)\n#include \"interrupt.h\"\n#else\n#define interrupt_lock() (0)\n#define interrupt_unlock(flags) while (0) {}\n#define soc_gpio_mask_interrupt(a, b) while (0) {}\n#define soc_gpio_unmask_interrupt(a, b) while (0) {}\n#endif\n\n#define CURIE_IMU_CHIP_ID 0xD1\n\n#define BMI160_GPIN_AON_PIN 4\n\n/******************************************************************************/\n\n/** Power on and prepare for general usage.\n * This will prepare the SPI communication interface for accessing the BMI160\n * on the Curie module, before calling BMI160::initialize() to activate the\n * BMI160 accelerometer and gyroscpoe with default settings.\n */\nbool CurieIMUClass::begin()\n{\n#if defined(BMI160GEN_USE_CURIEIMU)\n    /* Configure pin-mux settings on the Intel Curie module to \n     * enable SPI mode usage */\n    SET_PIN_MODE(35, QRK_PMUX_SEL_MODEA); // SPI1_SS_MISO \n    SET_PIN_MODE(36, QRK_PMUX_SEL_MODEA); // SPI1_SS_MOSI\n    SET_PIN_MODE(37, QRK_PMUX_SEL_MODEA); // SPI1_SS_SCK\n    SET_PIN_MODE(38, QRK_PMUX_SEL_MODEA); // SPI1_SS_CS_B[0]\n#endif\n \n    ss_init();\n\n    /* Perform a dummy read from 0x7f to switch to spi interface */\n    uint8_t dummy_reg = 0x7F;\n    serial_buffer_transfer(&dummy_reg, 1, 1);\n\n    /* The SPI interface is ready - now invoke the base class initialization */\n    BMI160Class::initialize();\n\n    /** Verify the SPI connection.\n     * MakgetGyroRatee sure the device is connected and responds as expected.\n     * @return True if connection is valid, false otherwise\n     */\n    return (CURIE_IMU_CHIP_ID == getDeviceID());\n}\n\nint CurieIMUClass::getGyroRate()\n{\n    int rate;\n\n    switch(BMI160Class::getGyroRate()) {\n        case BMI160_GYRO_RATE_25HZ:\n            rate = 25;\n            break;\n\n        case BMI160_GYRO_RATE_50HZ:\n            rate = 50;\n            break;\n\n        case BMI160_GYRO_RATE_100HZ:\n            rate = 100;\n            break;\n\n        case BMI160_GYRO_RATE_200HZ:\n            rate = 200;\n            break;\n\n        case BMI160_GYRO_RATE_400HZ:\n            rate = 400;\n            break;\n\n        case BMI160_GYRO_RATE_800HZ:\n            rate = 800;\n            break;\n\n        case BMI160_GYRO_RATE_1600HZ:\n            rate = 1600;\n            break;\n\n        case BMI160_GYRO_RATE_3200HZ:\n        default:\n            rate = 3200;\n            break;\n    }\n\n    return rate;\n}\n\nvoid CurieIMUClass::setGyroRate(int rate)\n{\n    BMI160GyroRate bmiRate;\n\n    if (rate <= 25) {\n        bmiRate = BMI160_GYRO_RATE_25HZ;\n    } else if (rate <= 50) {\n        bmiRate = BMI160_GYRO_RATE_50HZ;\n    } else if (rate <= 100) {\n        bmiRate = BMI160_GYRO_RATE_100HZ;\n    } else if (rate <= 200) {\n        bmiRate = BMI160_GYRO_RATE_200HZ;\n    } else if (rate <= 400) {\n        bmiRate = BMI160_GYRO_RATE_400HZ;\n    } else if (rate <= 800) {\n        bmiRate = BMI160_GYRO_RATE_800HZ;\n    } else if (rate <= 1600) {\n        bmiRate = BMI160_GYRO_RATE_1600HZ;\n    } else {\n        bmiRate = BMI160_GYRO_RATE_3200HZ;\n    }\n\n    BMI160Class::setGyroRate(bmiRate);\n}\n\nfloat CurieIMUClass::getAccelerometerRate()\n{\n    float rate;\n\n    switch(BMI160Class::getAccelRate()) {\n        case BMI160_ACCEL_RATE_25_2HZ:\n            rate = 12.5;\n            break;\n\n        case BMI160_ACCEL_RATE_25HZ:\n            rate = 25;\n            break;\n\n        case BMI160_ACCEL_RATE_50HZ:\n            rate = 50;\n            break;\n\n        case BMI160_ACCEL_RATE_100HZ:\n            rate = 100;\n            break;\n\n        case BMI160_ACCEL_RATE_200HZ:\n            rate = 200;\n            break;\n\n        case BMI160_ACCEL_RATE_400HZ:\n            rate = 400;\n            break;\n\n        case BMI160_ACCEL_RATE_800HZ:\n            rate = 800;\n            break;\n\n        case BMI160_ACCEL_RATE_1600HZ:\n        default:\n            rate = 1600;\n            break;\n    }\n\n    return rate;\n}\n\nvoid CurieIMUClass::setAccelerometerRate(float rate)\n{\n    BMI160AccelRate bmiRate;\n\n    if (rate <= 12.5) {\n        bmiRate = BMI160_ACCEL_RATE_25_2HZ;\n    } else if (rate <= 25) {\n        bmiRate = BMI160_ACCEL_RATE_25HZ;\n    } else if (rate <= 50) {\n        bmiRate = BMI160_ACCEL_RATE_50HZ;\n    } else if (rate <= 100) {\n        bmiRate = BMI160_ACCEL_RATE_100HZ;\n    } else if (rate <= 200) {\n        bmiRate = BMI160_ACCEL_RATE_200HZ;\n    } else if (rate <= 400) {\n        bmiRate = BMI160_ACCEL_RATE_400HZ;\n    } else if (rate <= 800) {\n        bmiRate = BMI160_ACCEL_RATE_800HZ;\n    } else {\n        bmiRate = BMI160_ACCEL_RATE_1600HZ;\n    }\n\n    setAccelRate(bmiRate);\n}\n\nint CurieIMUClass::getGyroRange()\n{\n    int range;\n\n    switch (getFullScaleGyroRange()) {\n        case BMI160_GYRO_RANGE_2000:\n            range = 2000;\n            break;\n\n        case BMI160_GYRO_RANGE_1000:\n            range = 1000;\n            break;\n\n        case BMI160_GYRO_RANGE_500:\n            range = 500;\n            break;\n\n        case BMI160_GYRO_RANGE_250:\n            range = 250;\n            break;\n\n        case BMI160_GYRO_RANGE_125:\n        default:\n            range = 125;\n            break;\n    }\n\n    return range;\n}\n\nvoid CurieIMUClass::setGyroRange(int range)\n{\n    BMI160GyroRange bmiRange;\n\n    if (range >= 2000) {\n        bmiRange = BMI160_GYRO_RANGE_2000;\n    } else if (range >= 1000) {\n        bmiRange = BMI160_GYRO_RANGE_1000;\n    } else if (range >= 500) {\n        bmiRange = BMI160_GYRO_RANGE_500;\n    } else if (range >= 250) {\n        bmiRange = BMI160_GYRO_RANGE_250;\n    } else {\n        bmiRange = BMI160_GYRO_RANGE_125;\n    }\n\n    setFullScaleGyroRange(bmiRange);\n}\n\nint CurieIMUClass::getAccelerometerRange()\n{\n    int range;\n\n    switch (getFullScaleAccelRange()) {\n        case BMI160_ACCEL_RANGE_2G:\n            range = 2;\n            break;\n\n        case BMI160_ACCEL_RANGE_4G:\n            range = 4;\n            break;\n\n        case BMI160_ACCEL_RANGE_8G:\n            range = 8;\n            break;\n\n        case BMI160_ACCEL_RANGE_16G:\n        default:\n            range = 16;\n            break;\n    }\n\n    return range;\n}\n\nvoid CurieIMUClass::setAccelerometerRange(int range)\n{\n    BMI160AccelRange bmiRange;\n\n    if (range <= 2) {\n        bmiRange = BMI160_ACCEL_RANGE_2G;\n    } else if (range <= 4) {\n        bmiRange = BMI160_ACCEL_RANGE_4G;\n    } else if (range <= 8) {\n        bmiRange = BMI160_ACCEL_RANGE_8G;\n    } else {\n        bmiRange = BMI160_ACCEL_RANGE_16G;\n    }\n\n    setFullScaleAccelRange(bmiRange);\n}\n\nvoid CurieIMUClass::autoCalibrateGyroOffset()\n{\n    BMI160Class::autoCalibrateGyroOffset();\n\n    setGyroOffsetEnabled(true);\n}\n\nvoid CurieIMUClass::autoCalibrateAccelerometerOffset(int axis, int target)\n{\n    switch (axis) {\n        case X_AXIS:\n            autoCalibrateXAccelOffset(target);\n            break;\n\n        case Y_AXIS:\n            autoCalibrateYAccelOffset(target);\n            break;\n\n        case Z_AXIS:\n            autoCalibrateZAccelOffset(target);\n            break;\n\n        default:\n            break;\n    }\n\n    setAccelOffsetEnabled(true);\n}\n\nvoid CurieIMUClass::noGyroOffset()\n{\n    setGyroOffsetEnabled(false);\n}\n\nvoid CurieIMUClass::noAccelerometerOffset()\n{\n    setAccelOffsetEnabled(false);\n}\n\nbool CurieIMUClass::gyroOffsetEnabled()\n{\n    return getGyroOffsetEnabled();\n}\n\nbool CurieIMUClass::accelerometerOffsetEnabled()\n{\n    return getAccelOffsetEnabled();\n}\n\nfloat CurieIMUClass::getGyroOffset(int axis)\n{\n    int bmiOffset;\n\n    if (axis == X_AXIS) {\n        bmiOffset = getXGyroOffset();\n    } else if (axis == Y_AXIS) {\n        bmiOffset = getYGyroOffset();\n    } else if (axis == Z_AXIS) {\n        bmiOffset = getZGyroOffset();\n    } else {\n        return -1;\n    }\n\n    return (bmiOffset * 0.061);\n}\n\nfloat CurieIMUClass::getAccelerometerOffset(int axis)\n{\n    int bmiOffset;\n\n    if (axis == X_AXIS) {\n        bmiOffset = getXAccelOffset();\n    } else if (axis == Y_AXIS) {\n        bmiOffset = getYAccelOffset();\n    } else if (axis == Z_AXIS) {\n        bmiOffset = getZAccelOffset();\n    } else {\n        return -1;\n    }\n\n    return (bmiOffset * 3.9);\n}\n\nvoid CurieIMUClass::setGyroOffset(int axis, float offset)\n{\n    int bmiOffset = offset / 0.061;\n\n    if (bmiOffset < -512) {\n        bmiOffset = -512;\n    } else if (bmiOffset > 511) {\n        bmiOffset = 511;\n    }\n\n    if (axis == X_AXIS) {\n        setXGyroOffset(bmiOffset);\n    } else if (axis == Y_AXIS) {\n        setYGyroOffset(bmiOffset);\n    } else if (axis == Z_AXIS) {\n        setZGyroOffset(bmiOffset);\n    }\n\n    setGyroOffsetEnabled(true);\n}\n\nvoid CurieIMUClass::setAccelerometerOffset(int axis, float offset)\n{\n    int bmiOffset = offset / 3.9;\n\n    if (bmiOffset < -128) {\n        bmiOffset = -128;\n    } else if (bmiOffset > 127) {\n        bmiOffset = 127;\n    }\n\n    if (axis == X_AXIS) {\n        setXAccelOffset(bmiOffset);\n    } else if (axis == Y_AXIS) {\n        setYAccelOffset(bmiOffset);\n    } else if (axis == Z_AXIS) {\n        setZAccelOffset(bmiOffset);\n    }\n\n    setAccelOffsetEnabled(true);\n}\n\nfloat CurieIMUClass::getDetectionThreshold(int feature)\n{\n    switch (feature) {\n        case CURIE_IMU_FREEFALL:\n            return getFreefallDetectionThreshold();\n\n        case CURIE_IMU_SHOCK:\n            return getShockDetectionThreshold();\n\n        case CURIE_IMU_MOTION:\n            return getMotionDetectionThreshold();\n\n        case CURIE_IMU_ZERO_MOTION:\n            return getZeroMotionDetectionThreshold();\n\n        case CURIE_IMU_TAP:\n            return getTapDetectionThreshold();\n\n        case CURIE_IMU_STEP:\n        case CURIE_IMU_TAP_SHOCK:\n        case CURIE_IMU_TAP_QUIET:\n        case CURIE_IMU_DOUBLE_TAP:\n        case CURIE_IMU_FIFO_FULL:\n        case CURIE_IMU_DATA_READY:\n        default:\n            return -1;\n    }\n}\n\nvoid CurieIMUClass::setDetectionThreshold(int feature, float threshold)\n{\n    switch (feature) {\n        case CURIE_IMU_FREEFALL:\n            setFreefallDetectionThreshold(threshold);\n            break;\n\n        case CURIE_IMU_SHOCK:\n            setShockDetectionThreshold(threshold);\n            break;\n\n        case CURIE_IMU_MOTION:\n            setMotionDetectionThreshold(threshold);\n            break;\n\n        case CURIE_IMU_ZERO_MOTION:\n            setZeroMotionDetectionThreshold(threshold);\n            break;\n\n        case CURIE_IMU_TAP:\n            setTapDetectionThreshold(threshold);\n            break;\n\n        case CURIE_IMU_STEP:\n        case CURIE_IMU_TAP_SHOCK:\n        case CURIE_IMU_TAP_QUIET:\n        case CURIE_IMU_DOUBLE_TAP:\n        case CURIE_IMU_FIFO_FULL:\n        case CURIE_IMU_DATA_READY:\n        default:\n            break;\n    }\n}\n\nfloat CurieIMUClass::getDetectionDuration(int feature)\n{\n    switch (feature) {\n        case CURIE_IMU_FREEFALL:\n            return getFreefallDetectionDuration();\n\n        case CURIE_IMU_SHOCK:\n            return getShockDetectionDuration();\n\n        case CURIE_IMU_MOTION:\n            return getMotionDetectionDuration();\n\n        case CURIE_IMU_TAP_SHOCK:\n            return getTapShockDuration();\n\n        case CURIE_IMU_ZERO_MOTION:\n            return getZeroMotionDetectionDuration();\n\n        case CURIE_IMU_TAP_QUIET:\n            return getTapQuietDuration();\n\n        case CURIE_IMU_DOUBLE_TAP:\n            return getDoubleTapDetectionDuration();\n\n        case CURIE_IMU_TAP:\n        case CURIE_IMU_STEP:\n        case CURIE_IMU_FIFO_FULL:\n        case CURIE_IMU_DATA_READY:\n        default:\n            return -1;\n    }\n}\n\nfloat CurieIMUClass::getFreefallDetectionThreshold()\n{\n    int bmiThreshold = BMI160Class::getFreefallDetectionThreshold();\n\n    return (bmiThreshold * 7.81) + 3.91;\n}\n\nvoid CurieIMUClass::setFreefallDetectionThreshold(float threshold)\n{\n    int bmiThreshold = (threshold - 3.91) / 7.81;\n\n    if (bmiThreshold < 0) {\n        bmiThreshold = 0;\n    } else if (bmiThreshold > 255) {\n        bmiThreshold = 255;\n    }\n\n    BMI160Class::setFreefallDetectionThreshold(bmiThreshold);\n}\n\nfloat CurieIMUClass::getShockDetectionThreshold()\n{\n    int bmiThreshold = BMI160Class::getShockDetectionThreshold();\n    float step;\n    float min;\n\n    switch (getAccelerometerRange()) {\n        case 2:\n            step = 7.81;\n            min = 3.91;\n            break;\n\n        case 4:\n            step = 15.63;\n            min = 7.81;\n            break;\n\n        case 8:\n            step = 31.25;\n            min = 15.63;\n            break;\n\n        case 16:\n        default:\n            step = 62.50;\n            min = 31.25;\n            break;\n    }\n\n    return (bmiThreshold * step) + min;\n}\n\nvoid CurieIMUClass::setShockDetectionThreshold(float threshold)\n{\n    int bmiThreshold;\n\n    switch (getAccelerometerRange()) {\n        case 2:\n            bmiThreshold = (threshold - 3.91) / 7.81;\n            break;\n\n        case 4:\n            bmiThreshold = (threshold - 7.81) / 15.6;\n            break;\n\n        case 8:\n            bmiThreshold = (threshold - 15.63) / 31.25;\n            break;\n\n        case 16:\n        default:\n            bmiThreshold = (threshold - 31.25) / 62.50;\n            break;\n    }\n\n    if (bmiThreshold < 0) {\n        bmiThreshold = 0;\n    } else if (bmiThreshold > 255) {\n        bmiThreshold = 255;\n    }\n\n    BMI160Class::setShockDetectionThreshold(bmiThreshold);\n}\n\nfloat CurieIMUClass::getMotionDetectionThreshold()\n{\n    int bmiThreshold = BMI160Class::getMotionDetectionThreshold();\n    float step;\n\n    switch (getAccelerometerRange()) {\n        case 2:\n            step = 3.91;\n            break;\n\n        case 4:\n            step = 7.81;\n            break;\n\n        case 8:\n            step = 15.63;\n            break;\n\n        case 16:\n        default:\n            step = 31.25;\n            break;\n    }\n\n    return (bmiThreshold * step);\n}\n\nvoid CurieIMUClass::setMotionDetectionThreshold(float threshold)\n{\n    int bmiThreshold;\n\n    switch (getAccelerometerRange()) {\n        case 2:\n            bmiThreshold = threshold / 3.91;\n            break;\n\n        case 4:\n            bmiThreshold = threshold / 7.81;\n            break;\n\n        case 8:\n            bmiThreshold = threshold / 15.63;\n            break;\n\n        case 16:\n        default:\n            bmiThreshold = threshold / 31.25;\n            break;\n    }\n\n    if (bmiThreshold < 0) {\n        bmiThreshold = 0;\n    } else if (bmiThreshold > 255) {\n        bmiThreshold = 255;\n    }\n\n    BMI160Class::setMotionDetectionThreshold(bmiThreshold);\n}\n\nfloat CurieIMUClass::getZeroMotionDetectionThreshold()\n{\n    int bmiThreshold = BMI160Class::getZeroMotionDetectionThreshold();\n    float step;\n\n    switch (getAccelerometerRange()) {\n        case 2:\n            step = 3.91;\n            break;\n\n        case 4:\n            step = 7.81;\n            break;\n\n        case 8:\n            step = 15.63;\n            break;\n\n        case 16:\n        default:\n            step = 31.25;\n            break;\n    }\n\n    return (bmiThreshold * step);\n}\n\nvoid CurieIMUClass::setZeroMotionDetectionThreshold(float threshold)\n{\n    int bmiThreshold;\n\n    switch (getAccelerometerRange()) {\n        case 2:\n            bmiThreshold = threshold / 3.91;\n            break;\n\n        case 4:\n            bmiThreshold = threshold / 7.81;\n            break;\n\n        case 8:\n            bmiThreshold = threshold / 15.63;\n            break;\n\n        case 16:\n        default:\n            bmiThreshold = threshold / 31.25;\n            break;\n    }\n\n    if (bmiThreshold < 0) {\n        bmiThreshold = 0;\n    } else if (bmiThreshold > 255) {\n        bmiThreshold = 255;\n    }\n\n    BMI160Class::setZeroMotionDetectionThreshold(bmiThreshold);\n}\n\nfloat CurieIMUClass::getTapDetectionThreshold()\n{\n    int bmiThreshold = BMI160Class::getTapDetectionThreshold();\n    float step;\n    float min;\n\n    switch (getAccelerometerRange()) {\n        case 2:\n            step = 62.5;\n            min = 31.25;\n            break;\n\n        case 4:\n            step = 125.0;\n            min = 62.5;\n            break;\n\n        case 8:\n            step = 250.0;\n            min = 125.0;\n            break;\n\n        case 16:\n        default:\n            step = 500.0;\n            min = 250.0;\n            break;\n    }\n\n    return (bmiThreshold * step) + min;\n}\n\nvoid CurieIMUClass::setTapDetectionThreshold(float threshold)\n{\n    int bmiThreshold;\n\n    switch (getAccelerometerRange()) {\n        case 2:\n            bmiThreshold = (threshold - 31.25) / 62.5;\n            break;\n\n        case 4:\n            bmiThreshold = (threshold - 62.5) / 125.0;\n            break;\n\n        case 8:\n            bmiThreshold = (threshold - 125.0) / 250.0;\n            break;\n\n        case 16:\n        default:\n            bmiThreshold = (threshold - 2500) / 500.0;\n            break;\n    }\n\n    if (bmiThreshold < 0) {\n        bmiThreshold = 0;\n    } else if (bmiThreshold > 255) {\n        bmiThreshold = 255;\n    }\n\n    BMI160Class::setTapDetectionThreshold(bmiThreshold);\n}\n\nvoid CurieIMUClass::setDetectionDuration(int feature, float value)\n{\n    switch (feature) {\n        case CURIE_IMU_FREEFALL:\n            setFreefallDetectionDuration(value);\n            break;\n\n        case CURIE_IMU_SHOCK:\n            setShockDetectionDuration(value);\n            break;\n\n        case CURIE_IMU_MOTION:\n            setMotionDetectionDuration(value);\n            break;\n\n        case CURIE_IMU_TAP_SHOCK:\n            setTapShockDuration(value);\n            break;\n\n        case CURIE_IMU_ZERO_MOTION:\n            setZeroMotionDetectionThreshold(value);\n            break;\n\n        case CURIE_IMU_TAP_QUIET:\n            setTapQuietDuration(value);\n            break;\n\n        case CURIE_IMU_DOUBLE_TAP:\n            setDoubleTapDetectionDuration(value);\n            break;\n\n        case CURIE_IMU_TAP:\n        case CURIE_IMU_STEP:\n        case CURIE_IMU_FIFO_FULL:\n        case CURIE_IMU_DATA_READY:\n        default:\n            break;\n    }\n}\n\nfloat CurieIMUClass::getFreefallDetectionDuration()\n{\n    int bmiDuration = BMI160Class::getFreefallDetectionDuration();\n\n    return ((bmiDuration + 1) * 2.5);\n}\n\nvoid CurieIMUClass::setFreefallDetectionDuration(float duration)\n{\n    int bmiDuration = (duration - 2.5) / 2.5;\n\n    if (bmiDuration < 0) {\n        bmiDuration = 0;\n    } else if (bmiDuration > 255) {\n        bmiDuration = 255;\n    }\n\n    BMI160Class::setFreefallDetectionDuration(bmiDuration);\n}\n\nint CurieIMUClass::getShockDetectionDuration()\n{\n    int duration;\n\n    switch (BMI160Class::getShockDetectionDuration()) {\n        case BMI160_TAP_SHOCK_DURATION_50MS:\n            duration = 50;\n            break;\n\n        case BMI160_TAP_SHOCK_DURATION_75MS:\n        default:\n            duration = 75;\n            break;\n    }\n\n    return duration;\n}\nvoid CurieIMUClass::setShockDetectionDuration(int duration)\n{\n    BMI160TapShockDuration bmiDuration;\n\n    if (duration <= 50) {\n        bmiDuration = BMI160_TAP_SHOCK_DURATION_50MS;\n    } else {\n        bmiDuration = BMI160_TAP_SHOCK_DURATION_75MS;\n    }\n\n    BMI160Class::setShockDetectionDuration(bmiDuration);\n}\n\nfloat CurieIMUClass::getMotionDetectionDuration()\n{\n    int bmiDuration = BMI160Class::getMotionDetectionDuration();\n\n    return (bmiDuration / getAccelerometerRate());\n\n\n}\nvoid CurieIMUClass::setMotionDetectionDuration(float duration)\n{\n    int bmiDuration = (duration * getAccelerometerRate());\n\n    if (bmiDuration < 1) {\n        bmiDuration = 1;\n    } else if (bmiDuration > 4) {\n        bmiDuration = 4;\n    }\n\n    BMI160Class::setMotionDetectionDuration(bmiDuration);\n}\n\nfloat CurieIMUClass::getZeroMotionDetectionDuration()\n{\n    float duration;\n\n    switch (BMI160Class::getZeroMotionDetectionDuration()) {\n        case BMI160_ZERO_MOTION_DURATION_1_28S:\n            duration = 1.28;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_2_56S:\n            duration = 2.56;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_3_84S:\n            duration = 3.84;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_5_12S:\n            duration = 5.12;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_6_40S:\n            duration = 6.40;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_7_68S:\n            duration = 7.68;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_8_96S:\n            duration = 8.96;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_10_24S:\n            duration = 10.24;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_11_52S:\n            duration = 11.52;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_12_80S:\n            duration = 12.80;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_14_08S:\n            duration = 14.08;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_15_36S:\n            duration = 15.36;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_16_64S:\n            duration = 16.64;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_17_92S:\n            duration = 17.92;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_19_20S:\n            duration = 19.20;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_20_48S:\n            duration = 20.48;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_25_60S:\n            duration = 25.60;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_30_72S:\n            duration = 30.72;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_35_84S:\n            duration = 35.84;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_40_96S:\n            duration = 40.96;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_46_08S:\n            duration = 46.08;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_51_20S:\n            duration = 51.20;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_56_32S:\n            duration = 56.32;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_61_44S:\n            duration = 61.44;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_66_56S:\n            duration = 66.56;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_71_68S:\n            duration = 71.68;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_76_80S:\n            duration = 76.80;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_81_92S:\n            duration = 81.92;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_87_04S:\n            duration = 87.04;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_92_16S:\n            duration = 92.16;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_97_28S:\n            duration = 97.28;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_102_40S:\n            duration = 102.40;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_112_64S:\n            duration = 112.64;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_122_88S:\n            duration = 122.88;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_133_12S:\n            duration = 133.12;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_143_36S:\n            duration = 143.36;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_153_60S:\n            duration = 153.60;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_163_84S:\n            duration = 163.84;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_174_08S:\n            duration = 174.08;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_184_32S:\n            duration = 184.32;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_194_56S:\n            duration = 194.56;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_204_80S:\n            duration = 204.80;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_215_04S:\n            duration = 215.04;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_225_28S:\n            duration = 225.28;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_235_52S:\n            duration = 235.52;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_245_76S:\n            duration = 245.76;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_256_00S:\n            duration = 256.00;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_266_24S:\n            duration = 266.24;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_276_48S:\n            duration = 276.48;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_286_72S:\n            duration = 286.72;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_296_96S:\n            duration = 296.96;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_307_20S:\n            duration = 307.20;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_317_44S:\n            duration = 317.44;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_327_68S:\n            duration = 327.68;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_337_92S:\n            duration = 337.92;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_348_16S:\n            duration = 348.16;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_358_40S:\n            duration = 358.40;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_368_64S:\n            duration = 368.64;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_378_88S:\n            duration = 378.88;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_389_12S:\n            duration = 389.12;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_399_36S:\n            duration = 399.36;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_409_60S:\n            duration = 409.60;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_419_84S:\n            duration = 419.84;\n            break;\n\n        case BMI160_ZERO_MOTION_DURATION_430_08S:\n        default:\n            duration = 430.08;\n            break;\n    }\n\n    return duration;\n}\nvoid CurieIMUClass::setZeroMotionDetectionDuration(float duration)\n{\n    BMI160ZeroMotionDuration bmiDuration;\n\n    if (duration <= 1.28) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_1_28S;\n    } else if (duration <= 2.56) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_2_56S;\n    } else if (duration <= 3.84) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_3_84S;\n    } else if (duration <= 5.12) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_5_12S;\n    } else if (duration <= 6.40) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_6_40S;\n    } else if (duration <= 7.68) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_7_68S;\n    } else if (duration <= 8.96) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_8_96S;\n    } else if (duration <= 10.24) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_10_24S;\n    } else if (duration <= 11.52) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_11_52S;\n    } else if (duration <= 12.80) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_12_80S;\n    } else if (duration <= 14.08) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_14_08S;\n    } else if (duration <= 15.36) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_15_36S;\n    } else if (duration <= 16.64) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_16_64S;\n    } else if (duration <= 17.92) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_17_92S;\n    } else if (duration <= 19.20) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_19_20S;\n    } else if (duration <= 20.48) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_20_48S;\n    } else if (duration <= 25.60) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_25_60S;\n    } else if (duration <= 30.72) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_30_72S;\n    } else if (duration <= 35.84) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_35_84S;\n    } else if (duration <= 40.96) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_40_96S;\n    } else if (duration <= 46.08) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_46_08S;\n    } else if (duration <= 51.20) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_51_20S;\n    } else if (duration <= 56.32) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_56_32S;\n    } else if (duration <= 61.44) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_61_44S;\n    } else if (duration <= 66.56) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_66_56S;\n    } else if (duration <= 71.68) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_71_68S;\n    } else if (duration <= 76.80) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_76_80S;\n    } else if (duration <= 81.92) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_81_92S;\n    } else if (duration <= 87.04) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_87_04S;\n    } else if (duration <= 92.16) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_92_16S;\n    } else if (duration <= 97.28) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_97_28S;\n    } else if (duration <= 102.40) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_102_40S;\n    } else if (duration <= 112.64) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_112_64S;\n    } else if (duration <= 122.88) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_122_88S;\n    } else if (duration <= 133.12) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_133_12S;\n    } else if (duration <= 143.36) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_143_36S;\n    } else if (duration <= 153.60) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_153_60S;\n    } else if (duration <= 163.84) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_163_84S;\n    } else if (duration <= 174.08) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_174_08S;\n    } else if (duration <= 184.32) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_184_32S;\n    } else if (duration <= 194.56) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_194_56S;\n    } else if (duration <= 204.80) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_204_80S;\n    } else if (duration <= 215.04) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_215_04S;\n    } else if (duration <= 225.28) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_225_28S;\n    } else if (duration <= 235.52) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_235_52S;\n    } else if (duration <= 245.76) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_245_76S;\n    } else if (duration <= 256.00) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_256_00S;\n    } else if (duration <= 266.24) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_266_24S;\n    } else if (duration <= 276.48) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_276_48S;\n    } else if (duration <= 286.72) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_286_72S;\n    } else if (duration <= 296.96) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_296_96S;\n    } else if (duration <= 307.20) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_307_20S;\n    } else if (duration <= 317.44) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_317_44S;\n    } else if (duration <= 327.68) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_327_68S;\n    } else if (duration <= 337.92) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_337_92S;\n    } else if (duration <= 348.16) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_348_16S;\n    } else if (duration <= 358.40) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_358_40S;\n    } else if (duration <= 368.64) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_368_64S;\n    } else if (duration <= 378.88) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_378_88S;\n    } else if (duration <= 389.12) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_389_12S;\n    } else if (duration <= 399.36) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_399_36S;\n    } else if (duration <= 409.60) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_409_60S;\n    } else if (duration <= 419.84) {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_419_84S;\n    } else {\n        bmiDuration = BMI160_ZERO_MOTION_DURATION_430_08S;\n    }\n\n    BMI160Class::setZeroMotionDetectionDuration(bmiDuration);\n}\n\nint CurieIMUClass::getTapShockDuration()\n{\n    int duration;\n\n    switch (BMI160Class::getTapShockDuration()) {\n        case BMI160_TAP_SHOCK_DURATION_50MS:\n            duration = 50;\n            break;\n\n        case BMI160_TAP_SHOCK_DURATION_75MS:\n        default:\n            duration = 75;\n            break;\n    }\n\n    return duration;\n}\n\nvoid CurieIMUClass::setTapShockDuration(int duration)\n{\n    BMI160TapShockDuration bmiDuration;\n\n    if (duration <= 50) {\n        bmiDuration = BMI160_TAP_SHOCK_DURATION_50MS;\n    } else {\n        bmiDuration = BMI160_TAP_SHOCK_DURATION_75MS;\n    }\n\n    BMI160Class::setTapShockDuration(bmiDuration);\n}\n\nint CurieIMUClass::getTapQuietDuration()\n{\n    int duration;\n\n    switch (BMI160Class::getTapQuietDuration()) {\n        case BMI160_TAP_QUIET_DURATION_30MS:\n            duration = 30;\n            break;\n\n        case BMI160_TAP_QUIET_DURATION_20MS:\n        default:\n            duration = 20;\n            break;\n    }\n\n    return duration;\n}\n\nvoid CurieIMUClass::setTapQuietDuration(int duration)\n{\n    BMI160TapQuietDuration bmiDuration;\n\n    if (duration >= 30) {\n        bmiDuration = BMI160_TAP_QUIET_DURATION_30MS;\n    } else {\n        bmiDuration = BMI160_TAP_QUIET_DURATION_20MS;\n    }\n\n    BMI160Class::setTapQuietDuration(bmiDuration);\n}\n\nint CurieIMUClass::getDoubleTapDetectionDuration()\n{\n    int duration;\n\n    switch (BMI160Class::getDoubleTapDetectionDuration()) {\n        case BMI160_DOUBLE_TAP_DURATION_50MS:\n            duration = 50;\n            break;\n\n        case BMI160_DOUBLE_TAP_DURATION_100MS:\n            duration = 100;\n            break;\n\n        case BMI160_DOUBLE_TAP_DURATION_150MS:\n            duration = 150;\n            break;\n\n        case BMI160_DOUBLE_TAP_DURATION_200MS:\n            duration = 200;\n            break;\n\n        case BMI160_DOUBLE_TAP_DURATION_250MS:\n            duration = 250;\n            break;\n\n        case BMI160_DOUBLE_TAP_DURATION_375MS:\n            duration = 375;\n            break;\n\n        case BMI160_DOUBLE_TAP_DURATION_500MS:\n            duration = 500;\n            break;\n\n        case BMI160_DOUBLE_TAP_DURATION_700MS:\n        default:\n            duration = 700;\n            break;\n    }\n\n    return duration;\n}\nvoid CurieIMUClass::setDoubleTapDetectionDuration(int duration)\n{\n    BMI160DoubleTapDuration bmiDuration;\n\n    if (duration <= 50) {\n        bmiDuration = BMI160_DOUBLE_TAP_DURATION_50MS;\n    } else if (duration <= 100) {\n        bmiDuration = BMI160_DOUBLE_TAP_DURATION_100MS;\n    } else if (duration <= 150) {\n        bmiDuration = BMI160_DOUBLE_TAP_DURATION_150MS;\n    } else if (duration <= 200) {\n        bmiDuration = BMI160_DOUBLE_TAP_DURATION_200MS;\n    } else if (duration <= 250) {\n        bmiDuration = BMI160_DOUBLE_TAP_DURATION_250MS;\n    } else if (duration <= 375) {\n        bmiDuration = BMI160_DOUBLE_TAP_DURATION_375MS;\n    } else if (duration <= 500) {\n        bmiDuration = BMI160_DOUBLE_TAP_DURATION_500MS;\n    } else {\n        bmiDuration = BMI160_DOUBLE_TAP_DURATION_700MS;\n    }\n\n    BMI160Class::setDoubleTapDetectionDuration(bmiDuration);\n}\n\n#if defined(BMI160GEN_USE_CURIEIMU)\nvoid CurieIMUClass::interrupts(int feature)\n{\n    enableInterrupt(feature, true);\n}\n\nvoid CurieIMUClass::noInterrupts(int feature)\n{\n    enableInterrupt(feature, false);\n}\n#endif // defined(BMI160GEN_USE_CURIEIMU)\n\nvoid CurieIMUClass::enableInterrupt(int feature, bool enabled)\n{\n    switch (feature) {\n        case CURIE_IMU_FREEFALL:\n            setIntFreefallEnabled(enabled);\n            break;\n\n        case CURIE_IMU_SHOCK:\n            setIntShockEnabled(enabled);\n            break;\n\n        case CURIE_IMU_STEP:\n            setIntStepEnabled(enabled);\n            break;\n\n        case CURIE_IMU_MOTION:\n            setIntMotionEnabled(enabled);\n            break;\n\n        case CURIE_IMU_ZERO_MOTION:\n            setIntZeroMotionEnabled(enabled);\n            break;\n\n       case CURIE_IMU_TAP:\n            setIntTapEnabled(enabled);\n            break;\n\n        case CURIE_IMU_DOUBLE_TAP:\n            setIntDoubleTapEnabled(enabled);\n            break;\n\n        case CURIE_IMU_FIFO_FULL:\n            setIntFIFOBufferFullEnabled(enabled);\n            break;\n\n        case CURIE_IMU_DATA_READY:\n            setIntDataReadyEnabled(enabled);\n            break;\n\n        case CURIE_IMU_TAP_QUIET:\n        case CURIE_IMU_TAP_SHOCK:\n        default:\n            break;\n    }\n}\n\nbool CurieIMUClass::interruptsEnabled(int feature)\n{\n    switch (feature) {\n        case CURIE_IMU_FREEFALL:\n            return getIntFreefallEnabled();\n\n        case CURIE_IMU_SHOCK:\n            return getIntShockEnabled();\n\n        case CURIE_IMU_STEP:\n            return getIntStepEnabled();\n\n        case CURIE_IMU_MOTION:\n            return getIntMotionEnabled();\n\n        case CURIE_IMU_ZERO_MOTION:\n            return getIntZeroMotionEnabled();\n\n       case CURIE_IMU_TAP:\n            return getIntTapEnabled();\n\n        case CURIE_IMU_DOUBLE_TAP:\n            return getIntDoubleTapEnabled();\n\n        case CURIE_IMU_FIFO_FULL:\n            return getIntFIFOBufferFullEnabled();\n\n        case CURIE_IMU_DATA_READY:\n            return getIntDataReadyEnabled();\n\n        case CURIE_IMU_TAP_QUIET:\n        case CURIE_IMU_TAP_SHOCK:\n        default:\n            return false;\n    }\n}\n\nbool CurieIMUClass::getInterruptStatus(int feature)\n{\n    switch (feature) {\n        case CURIE_IMU_FREEFALL:\n            return getIntFreefallStatus();\n\n        case CURIE_IMU_SHOCK:\n            return getIntShockStatus();\n\n        case CURIE_IMU_STEP:\n            return getIntStepStatus();\n\n        case CURIE_IMU_MOTION:\n            return getIntMotionStatus();\n\n        case CURIE_IMU_ZERO_MOTION:\n            return getIntZeroMotionStatus();\n\n        case CURIE_IMU_TAP:\n            return getIntTapStatus();\n\n        case CURIE_IMU_DOUBLE_TAP:\n            return getIntDoubleTapStatus();\n\n        case CURIE_IMU_FIFO_FULL:\n            return getIntFIFOBufferFullStatus();\n\n        case CURIE_IMU_DATA_READY:\n            return getIntDataReadyStatus();\n\n        case CURIE_IMU_TAP_QUIET:\n        case CURIE_IMU_TAP_SHOCK:\n        default:\n            return false;\n    }\n}\n\nCurieIMUStepMode CurieIMUClass::getStepDetectionMode()\n{\n    return (CurieIMUStepMode)BMI160Class::getStepDetectionMode();\n}\n\nvoid CurieIMUClass::setStepDetectionMode(int mode)\n{\n    BMI160Class::setStepDetectionMode((BMI160StepMode)mode);\n}\n\nvoid CurieIMUClass::readMotionSensor(int& ax, int& ay, int& az, int& gx, int& gy, int& gz)\n{\n    int16_t sax, say, saz, sgx, sgy, sgz;\n\n    getMotion6(&sax, &say, &saz, &sgx, &sgy, &sgz);\n\n    ax = sax;\n    ay = say;\n    az = saz;\n    gx = sgx;\n    gy = sgy;\n    gz = sgz;\n}\n\nvoid CurieIMUClass::readAccelerometer(int& x, int& y, int& z)\n{\n    int16_t sx, sy, sz;\n\n    getAcceleration(&sx, &sy, &sz);\n\n    x = sx;\n    y = sy;\n    z = sz;\n}\n\nvoid CurieIMUClass::readGyro(int& x, int& y, int& z)\n{\n    int16_t sx, sy, sz;\n\n    getRotation(&sx, &sy, &sz);\n\n    x = sx;\n    y = sy;\n    z = sz;\n}\n\nint CurieIMUClass::readAccelerometer(int axis)\n{\n    if (axis == X_AXIS) {\n        return getAccelerationX();\n    } else if (axis == Y_AXIS) {\n        return getAccelerationY();\n    } else if (axis == Z_AXIS) {\n        return getAccelerationZ();\n    }\n\n    return 0; \n}\n\nint CurieIMUClass::readGyro(int axis)\n{\n    if (axis == X_AXIS) {\n        return getRotationX();\n    } else if (axis == Y_AXIS) {\n        return getRotationY();\n    } else if (axis == Z_AXIS) {\n        return getRotationZ();\n    }\n\n    return 0;\n}\n\nint CurieIMUClass::readTemperature()\n{\n    return getTemperature();\n}\n\nbool CurieIMUClass::shockDetected(int axis, int direction)\n{\n    if (direction == POSITIVE) {\n        if (axis == X_AXIS) {\n            return getXPosShockDetected();\n        } else if (axis == Y_AXIS) {\n            return getYPosShockDetected();\n        } else if (axis == Z_AXIS) {\n            return getZPosShockDetected();\n        }\n    } else if (direction == NEGATIVE) {\n        if (axis == X_AXIS) {\n            return getXNegShockDetected();\n        } else if (axis == Y_AXIS) {\n            return getYNegShockDetected();\n        } else if (axis == Z_AXIS) {\n            return getZNegShockDetected();\n        }\n    }\n\n    return false;\n}\n\nbool CurieIMUClass::motionDetected(int axis, int direction)\n{\n    if (direction == POSITIVE) {\n        if (axis == X_AXIS) {\n            return getXPosMotionDetected();\n        } else if (axis == Y_AXIS) {\n            return getYPosMotionDetected();\n        } else if (axis == Z_AXIS) {\n            return getZPosMotionDetected();\n        }\n    } else if (direction == NEGATIVE) {\n        if (axis == X_AXIS) {\n            return getXNegMotionDetected();\n        } else if (axis == Y_AXIS) {\n            return getYNegMotionDetected();\n        } else if (axis == Z_AXIS) {\n            return getZNegMotionDetected();\n        }\n    }\n\n    return false;\n}\n\nbool CurieIMUClass::tapDetected(int axis, int direction)\n{\n    if (direction == POSITIVE) {\n        if (axis == X_AXIS) {\n            return getXPosTapDetected();\n        } else if (axis == Y_AXIS) {\n            return getYPosTapDetected();\n        } else if (axis == Z_AXIS) {\n            return getZPosTapDetected();\n        }\n    } else if (direction == NEGATIVE) {\n        if (axis == X_AXIS) {\n            return getXNegTapDetected();\n        } else if (axis == Y_AXIS) {\n            return getYNegTapDetected();\n        } else if (axis == Z_AXIS) {\n            return getZNegTapDetected();\n        }\n    }\n\n    return false;\n}\n\nbool CurieIMUClass::stepsDetected()\n{\n    return getIntStepStatus();\n}\n\nvoid CurieIMUClass::ss_init() {\n}\n\nint CurieIMUClass::ss_xfer(uint8_t *buf, unsigned tx_cnt, unsigned rx_cnt)\n{\n    return false;\n}\n\n/** Provides a serial buffer transfer implementation for the BMI160 base class\n *  to use for accessing device registers.  This implementation uses the SPI\n *  bus on the Intel Curie module to communicate with the BMI160.\n */\nint CurieIMUClass::serial_buffer_transfer(uint8_t *buf, unsigned tx_cnt, unsigned rx_cnt)\n{\n    int flags, status;\n\n    /* Lock interrupts here to\n     * - avoid concurrent access to the SPI bus\n     * - avoid delays in SPI transfer due to unrelated interrupts\n     */\n    flags = interrupt_lock();\n    status = ss_xfer(buf, tx_cnt, rx_cnt);\n    interrupt_unlock(flags);\n\n    return status;\n}\n\n/** Interrupt handler for interrupts from PIN1 on the BMI160\n *  Calls a user callback if available.  The user callback is\n *  responsible for checking the source of the interrupt using\n *  the relevant API functions from the BMI160Class base class.\n */\nvoid bmi160_pin1_isr(void)\n{\n    soc_gpio_mask_interrupt(SOC_GPIO_AON, BMI160_GPIN_AON_PIN);\n    if (CurieIMU._user_callback)\n        CurieIMU._user_callback();\n    soc_gpio_unmask_interrupt(SOC_GPIO_AON, BMI160_GPIN_AON_PIN);\n}\n\n/** Stores a user callback, and enables PIN1 interrupts from the\n *  BMI160 module.\n */\nvoid CurieIMUClass::attachInterrupt(void (*callback)(void))\n{\n#if defined(BMI160GEN_USE_CURIEIMU)\n    gpio_cfg_data_t cfg;\n\n    _user_callback = callback;\n\n    memset(&cfg, 0, sizeof(gpio_cfg_data_t));\n    cfg.gpio_type = GPIO_INTERRUPT;\n    cfg.int_type = EDGE;\n    cfg.int_polarity = ACTIVE_LOW;\n    cfg.int_debounce = DEBOUNCE_ON;\n    cfg.gpio_cb = bmi160_pin1_isr;\n    soc_gpio_set_config(SOC_GPIO_AON, BMI160_GPIN_AON_PIN, &cfg);\n#endif\n\n    setInterruptMode(1);  // Active-Low\n    setInterruptDrive(0); // Push-Pull\n    setInterruptLatch(BMI160_LATCH_MODE_10_MS); // 10ms pulse\n    setIntEnabled(true);\n}\n\n/** Disables PIN1 interrupts from the BMI160 module.\n */\nvoid CurieIMUClass::detachInterrupt(void)\n{\n    setIntEnabled(false);\n\n#if defined(BMI160GEN_USE_CURIEIMU)\n    soc_gpio_deconfig(SOC_GPIO_AON, BMI160_GPIN_AON_PIN);\n#endif\n}\n\n/* Pre-instantiated Object for this class */\nCurieIMUClass CurieIMU;\n"},{"name":"DataStartString.cpp","type":"source","group":"other","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"#include <Arduino.h>\n#include \"DataStartString.h\"\n\n// Digital I/O initialization\nextern \"C\" void Send_Data_Start_String()\n{\n\t\n//#ifdef _RTT_USE_SERIAL0_\nSerial.write(\"***Data Start***\");\n//#endif\n\n}\n"},{"name":"HCSR04wrapper.cpp","type":"source","group":"other","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"// HCSR04wrapper.cpp\n\n#include \"NewPing.h\"\n\n// setup for max of 3 sonar readings:\nNewPing sonar1(0,0,0); // NewPing setup of pins and maximum distance.\nNewPing sonar2(0,0,0); // NewPing setup of pins and maximum distance.\nNewPing sonar3(0,0,0); // NewPing setup of pins and maximum distance.\n\nextern \"C\" void HCSR04Sonar_Init(int trigger_pin, int echo_pin, int Sonar  )\n{\n    //uint8_t trigger_pin=7;\n    //uint8_t echo_pin=8;\n    int max_cm_distance=200;\n    switch (Sonar){\n        case 1:\n            sonar1._triggerBit = digitalPinToBitMask(trigger_pin); // Get the port register bitmask for the trigger pin.\n            sonar1._echoBit = digitalPinToBitMask(echo_pin);       // Get the port register bitmask for the echo pin.\n            sonar1._triggerOutput = portOutputRegister(digitalPinToPort(trigger_pin)); // Get the output port register for the trigger pin.\n            sonar1._echoInput = portInputRegister(digitalPinToPort(echo_pin));         // Get the input port register for the echo pin.\n            sonar1._triggerMode = (uint8_t *) portModeRegister(digitalPinToPort(trigger_pin)); // Get the port mode register for the trigger pin.\n            sonar1._maxEchoTime = min(max_cm_distance, MAX_SENSOR_DISTANCE) * US_ROUNDTRIP_CM + (US_ROUNDTRIP_CM / 2); // Calculate the maximum distance in uS.\n            break;\n        case 2:\n            sonar2._triggerBit = digitalPinToBitMask(trigger_pin); // Get the port register bitmask for the trigger pin.\n            sonar2._echoBit = digitalPinToBitMask(echo_pin);       // Get the port register bitmask for the echo pin.\n            sonar2._triggerOutput = portOutputRegister(digitalPinToPort(trigger_pin)); // Get the output port register for the trigger pin.\n            sonar2._echoInput = portInputRegister(digitalPinToPort(echo_pin));         // Get the input port register for the echo pin.\n            sonar2._triggerMode = (uint8_t *) portModeRegister(digitalPinToPort(trigger_pin)); // Get the port mode register for the trigger pin.\n            sonar2._maxEchoTime = min(max_cm_distance, MAX_SENSOR_DISTANCE) * US_ROUNDTRIP_CM + (US_ROUNDTRIP_CM / 2); // Calculate the maximum distance in uS.\n            break;\n        case 3:\n            sonar3._triggerBit = digitalPinToBitMask(trigger_pin); // Get the port register bitmask for the trigger pin.\n            sonar3._echoBit = digitalPinToBitMask(echo_pin);       // Get the port register bitmask for the echo pin.\n            sonar3._triggerOutput = portOutputRegister(digitalPinToPort(trigger_pin)); // Get the output port register for the trigger pin.\n            sonar3._echoInput = portInputRegister(digitalPinToPort(echo_pin));         // Get the input port register for the echo pin.\n            sonar3._triggerMode = (uint8_t *) portModeRegister(digitalPinToPort(trigger_pin)); // Get the port mode register for the trigger pin.\n            sonar3._maxEchoTime = min(max_cm_distance, MAX_SENSOR_DISTANCE) * US_ROUNDTRIP_CM + (US_ROUNDTRIP_CM / 2); // Calculate the maximum distance in uS.\n            break;\n    }\n    \n#if DISABLE_ONE_PIN == true\n    *_triggerMode |= _triggerBit; // Set trigger pin to output.\n#endif\n    \n}\n\nextern \"C\" int HCSR04Sonar_Read(int Sonar)\n{\n    switch (Sonar){\n        case 1:\n            return sonar1.ping_cm();// US_ROUNDTRIP_CM;\n            break;\n        case 2:\n            return sonar2.ping_cm();// US_ROUNDTRIP_CM;\n            break;\n        case 3:\n            return sonar3.ping_cm();// US_ROUNDTRIP_CM;\n            break;\n    }\n    \n}\n\n"},{"name":"HMC58X3.cpp","type":"source","group":"other","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/*\nHMC58X3.cpp - Interface a Honeywell HMC58X3 or HMC5883L magnetometer to an Arduino via i2c\nCopyright (C) 2011 Fabio Varesano <fvaresano@yahoo.it>\n\nBased on:\nhttp://www.arduino.cc/cgi-bin/yabb2/YaBB.pl?num=1274748346\n Modification/extension of the following by E.J.Muller\nhttp://eclecti.cc/hardware/hmc5843-magnetometer-library-for-arduino\n Copyright (c) 2009 Nirav Patel, \n\nThe above were based on:\nhttp://www.sparkfun.com/datasheets/Sensors/Magneto/HMC58X3-v11.c\nhttp://www.atmel.com/dyn/resources/prod_documents/doc2545.pdf\n\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the version 3 GNU General Public License as\npublished by the Free Software Foundation.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*/\n\n//#define DEBUG (1)\n\n#include <HMC58X3.h>\n//#include <DebugUtils.h>\n#define DEBUG_PRINT\n\n\n/*!\n    Counts/milli-gauss per gain for the self test bias current.\n*/\n#if defined(ISHMC5843)\n  const int counts_per_milligauss[8]={  \n    1620,\n    1300,\n     970,\n     780,\n     530,\n     460,\n     390,\n     280\n  };\n#else // HMC5883L\n  const int counts_per_milligauss[8]={  \n    1370,\n    1090,\n    820,\n    660,\n    440,\n    390,\n    330,\n    230\n  };\n#endif\n\n/* PUBLIC METHODS */\n\nHMC58X3::HMC58X3() { \n  \n  x_scale=1.0F;\n  y_scale=1.0F;\n  z_scale=1.0F;\n}\n\n\nvoid HMC58X3::init(bool setmode) {\n  // note that we don't initialize Wire here. \n  // You'll have to do that in setup() in your Arduino program\n  delay(5); // you need to wait at least 5ms after power on to initialize\n  if (setmode) {\n    setMode(0);\n  }\n  \n  writeReg(HMC58X3_R_CONFA, 0x70); // 8 samples averaged, 75Hz frequency, no artificial bias.\n  writeReg(HMC58X3_R_CONFB, 0xA0);\n  writeReg(HMC58X3_R_MODE, 0x00);\n}\n\n\nvoid HMC58X3::setMode(unsigned char mode) {\n  if (mode > 2) {\n    return;\n  }\n  \n  writeReg(HMC58X3_R_MODE, mode);\n  delay(100);\n}\n\n/*\n    Calibrate which has a few weaknesses.\n    1. Uses wrong gain for first reading.\n    2. Uses max instead of max of average when normalizing the axis to one another.\n    3. Doesn't use neg bias. (possible improvement in measurement).\n*/\nvoid HMC58X3::calibrate(unsigned char gain) {\n  x_scale=1; // get actual values\n  y_scale=1;\n  z_scale=1;\n  writeReg(HMC58X3_R_CONFA, 0x010 + HMC_POS_BIAS); // Reg A DOR=0x010 + MS1,MS0 set to pos bias\n  setGain(gain);\n  float x, y, z, mx=0, my=0, mz=0, t=10;\n  \n  for (int i=0; i<(int)t; i++) { \n    setMode(1);\n    getValues(&x,&y,&z);\n    if (x>mx) mx=x;\n    if (y>my) my=y;\n    if (z>mz) mz=z;\n  }\n  \n  float max=0;\n  if (mx>max) max=mx;\n  if (my>max) max=my;\n  if (mz>max) max=mz;\n  x_max=mx;\n  y_max=my;\n  z_max=mz;\n  x_scale=max/mx; // calc scales\n  y_scale=max/my;\n  z_scale=max/mz;\n\n  writeReg(HMC58X3_R_CONFA, 0x010); // set RegA/DOR back to default\n}   // calibrate().\n\n/*!\n    \\brief Calibrate using the self test operation.\n  \n    Average the values using bias mode to obtain the scale factors.\n\n    \\param gain [in] Gain setting for the sensor. See data sheet.\n    \\param n_samples [in] Number of samples to average together while applying the positive and negative bias.\n    \\return Returns false if any of the following occurs:\n        # Invalid input parameters. (gain>7 or n_samples=0).\n        # Id registers are wrong for the compiled device. Unfortunately, we can't distinguish between HMC5843 and HMC5883L.\n        # Calibration saturates during the positive or negative bias on any of the readings.\n        # Readings are outside of the expected range for bias current. \n*/\nbool HMC58X3::calibrate(unsigned char gain,unsigned int n_samples) \n{\n    int xyz[3];                     // 16 bit integer values for each axis.\n    long int xyz_total[3]={0,0,0};  // 32 bit totals so they won't overflow.\n    bool bret=true;                 // Function return value.  Will return false if the wrong identifier is returned, saturation is detected or response is out of range to self test bias.\n    char id[3];                     // Three identification registers should return 'H43'.\n    long int low_limit, high_limit;                                    \n    /*\n        Make sure we are talking to the correct device.\n        Hard to believe Honeywell didn't change the identifier.\n    */\n    if ((8>gain) && (0<n_samples)) // Notice this allows gain setting of 7 which the data sheet warns against.\n    {\n        getID(id);\n        if (('H' == id[0]) && ('4' == id[1]) && ('3' == id[2]))\n        {   /*\n                Use the positive bias current to impose a known field on each axis.\n                This field depends on the device and the axis.\n            */\n            writeReg(HMC58X3_R_CONFA, 0x010 + HMC_POS_BIAS); // Reg A DOR=0x010 + MS1,MS0 set to pos bias\n            /*\n                Note that the  very first measurement after a gain change maintains the same gain as the previous setting. \n                The new gain setting is effective from the second measurement and on.\n            */\n            setGain(gain);                      \n            setMode(1);                         // Change to single measurement mode.\n            getRaw(&xyz[0],&xyz[1],&xyz[2]);    // Get the raw values and ignore since this reading may use previous gain.\n\n            for (unsigned int i=0; i<n_samples; i++) \n            { \n                setMode(1);\n                getRaw(&xyz[0],&xyz[1],&xyz[2]);   // Get the raw values in case the scales have already been changed.\n                /*\n                    Since the measurements are noisy, they should be averaged rather than taking the max.\n                */\n                xyz_total[0]+=xyz[0];\n                xyz_total[1]+=xyz[1];\n                xyz_total[2]+=xyz[2];\n                /*\n                    Detect saturation.\n                */\n                if (-(1<<12) >= min(xyz[0],min(xyz[1],xyz[2])))\n                {\n                    DEBUG_PRINT(\"HMC58x3 Self test saturated. Increase range.\");\n                    bret=false;\n                    break;  // Breaks out of the for loop.  No sense in continuing if we saturated.\n                }\n            }\n            /*\n                Apply the negative bias. (Same gain)\n            */\n            writeReg(HMC58X3_R_CONFA, 0x010 + HMC_NEG_BIAS); // Reg A DOR=0x010 + MS1,MS0 set to negative bias.\n            for (unsigned int i=0; i<n_samples; i++) \n            { \n                setMode(1);\n                getRaw(&xyz[0],&xyz[1],&xyz[2]);   // Get the raw values in case the scales have already been changed.\n                /*\n                    Since the measurements are noisy, they should be averaged.\n                */\n                xyz_total[0]-=xyz[0];\n                xyz_total[1]-=xyz[1];\n                xyz_total[2]-=xyz[2];\n                /*\n                    Detect saturation.\n                */\n                if (-(1<<12) >= min(xyz[0],min(xyz[1],xyz[2])))\n                {\n                    DEBUG_PRINT(\"HMC58x3 Self test saturated. Increase range.\");\n                    bret=false;\n                    break;  // Breaks out of the for loop.  No sense in continuing if we saturated.\n                }\n            }\n            /*\n                Compare the values against the expected self test bias gauss.\n                Notice, the same limits are applied to all axis.\n            */\n            low_limit =SELF_TEST_LOW_LIMIT *counts_per_milligauss[gain]*2*n_samples;\n            high_limit=SELF_TEST_HIGH_LIMIT*counts_per_milligauss[gain]*2*n_samples;\n\n            if ((true==bret) && \n                (low_limit <= xyz_total[0]) && (high_limit >= xyz_total[0]) &&\n                (low_limit <= xyz_total[1]) && (high_limit >= xyz_total[1]) &&\n                (low_limit <= xyz_total[2]) && (high_limit >= xyz_total[2]) )\n            {   /*\n                    Successful calibration.\n                    Normalize the scale factors so all axis return the same range of values for the bias field.\n                    Factor of 2 is from summation of total of n_samples from both positive and negative bias.\n                */\n                x_scale=(counts_per_milligauss[gain]*(HMC58X3_X_SELF_TEST_GAUSS*2))/(xyz_total[0]/n_samples);\n                y_scale=(counts_per_milligauss[gain]*(HMC58X3_Y_SELF_TEST_GAUSS*2))/(xyz_total[1]/n_samples);\n                z_scale=(counts_per_milligauss[gain]*(HMC58X3_Z_SELF_TEST_GAUSS*2))/(xyz_total[2]/n_samples);\n            }else\n            {\n                DEBUG_PRINT(\"HMC58x3 Self test out of range.\");\n                bret=false;\n            }\n            writeReg(HMC58X3_R_CONFA, 0x010); // set RegA/DOR back to default.\n        }else\n        {\n            #if defined(ISHMC5843)\n                DEBUG_PRINT(\"HMC5843 failed id check.\");\n            #else\n                DEBUG_PRINT(\"HMC5883L failed id check.\");\n            #endif\n            bret=false;\n        }\n    }else\n    {   /*\n            Bad input parameters.\n        */\n        DEBUG_PRINT(\"HMC58x3 Bad parameters.\");\n        bret=false;\n    }\n    return(bret);\n}   //  calibrate().\n\n// set data output rate\n// 0-6, 4 default, normal operation assumed\nvoid HMC58X3::setDOR(unsigned char DOR) {\n  if (DOR>6) return;\n  writeReg(HMC58X3_R_CONFA,DOR<<2);\n}\n\n\nvoid HMC58X3::setGain(unsigned char gain) { \n  // 0-7, 1 default\n  if (gain > 7) return;\n  writeReg(HMC58X3_R_CONFB, gain << 5);\n}\n\n\nvoid HMC58X3::writeReg(unsigned char reg, unsigned char val) {\n  Wire.beginTransmission(HMC58X3_ADDR);\n  Wire.write(reg);        // send register address\n  Wire.write(val);        // send value to write\n  Wire.endTransmission(); //end transmission\n}\n\n\nvoid HMC58X3::getValues(int *x,int *y,int *z) {\n  float fx,fy,fz;\n  getValues(&fx,&fy,&fz);\n  *x= (int) (fx + 0.5);\n  *y= (int) (fy + 0.5);\n  *z= (int) (fz + 0.5);\n}\n\n\nvoid HMC58X3::getValues(float *x,float *y,float *z) {\n  int xr,yr,zr;\n  \n  getRaw(&xr, &yr, &zr);\n  *x= ((float) xr) / x_scale;\n  *y = ((float) yr) / y_scale;\n  *z = ((float) zr) / z_scale;\n}\n\n\nvoid HMC58X3::getRaw(int *x,int *y,int *z) {\n  Wire.beginTransmission(HMC58X3_ADDR);\n  Wire.write(HMC58X3_R_XM); // will start from DATA X MSB and fetch all the others\n  Wire.endTransmission();\n  \n  Wire.beginTransmission(HMC58X3_ADDR);\n  Wire.requestFrom(HMC58X3_ADDR, 6);\n  if(6 == Wire.available()) {\n    // read out the 3 values, 2 bytes each.\n    *x = (Wire.read() << 8) | Wire.read();\n    #ifdef ISHMC5843\n      *y = (Wire.read() << 8) | Wire.read();\n      *z = (Wire.read() << 8) | Wire.read();\n    #else // the Z registers comes before the Y registers in the HMC5883L\n      *z = (Wire.read() << 8) | Wire.read();\n      *y = (Wire.read() << 8) | Wire.read();\n    #endif\n    // the HMC58X3 will automatically wrap around on the next request\n  }\n  Wire.endTransmission();\n}\n\n\nvoid HMC58X3::getValues(float *xyz) {\n  getValues(&xyz[0], &xyz[1], &xyz[2]);\n}\n\n/*! \n    \\brief Retrieve the value of the three ID registers.    \n\n    Note:  Both the HMC5843 and HMC5883L have the same 'H43' identification register values. (Looks like someone at Honeywell screwed up.)\n\n    \\param id [out] Returns the three id register values.\n*/\nvoid HMC58X3::getID(char id[3]) \n{\n  Wire.beginTransmission(HMC58X3_ADDR);\n  Wire.write(HMC58X3_R_IDA);             // Will start reading registers starting from Identification Register A.\n  Wire.endTransmission();\n  \n  Wire.beginTransmission(HMC58X3_ADDR);\n  Wire.requestFrom(HMC58X3_ADDR, 3);\n  if(3 == Wire.available()) \n  {\n    id[0] = Wire.read();\n    id[1] = Wire.read();\n    id[2] = Wire.read();\n  }else\n  {\n      id[0]=0;  \n      id[1]=0;\n      id[2]=0;\n  }\n  Wire.endTransmission();\n}   // getID()."},{"name":"HMC58X3wrapper.cpp","type":"source","group":"other","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"\n#include \"Wire.h\"\n#include \"twi.h\"\n#include \"I2Cdev.h\"\n#include \"HMC58X3.h\"\n\nHMC58X3 magn;\nint ix,iy,iz;\n\n#include \"MPU6050.h\"\n\nextern \"C\" void HMC58X3_Init(void)\n{\n    Wire.begin();\n    magn.init(1);\n\t\n\t//  Enable I2C bypass on MPU6050 so the compass can be accessed\n\tI2Cdev::writeBit(MPU6050_DEFAULT_ADDRESS, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_I2C_MST_EN_BIT, false);\n\tI2Cdev::writeBit(MPU6050_DEFAULT_ADDRESS, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_I2C_BYPASS_EN_BIT, true);\n\tI2Cdev::writeBit(MPU6050_DEFAULT_ADDRESS, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, false);\n}\n\nextern \"C\" void HMC58X3_Read(float* pfData)\n{\n\tmagn.getRaw(&ix,&iy,&iz);\n    pfData[0]=ix;\n    pfData[1]=iy;\n    pfData[2]=iz;\n}\n"},{"name":"I2Cdev.cpp","type":"source","group":"legacy","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/../../../MATLAB Add-Ons/Collections/Rensselaer Arduino Support Package Library (RASPLib)/RASPlib/src","tag":"","groupDisplay":"Other files","code":"// I2Cdev library collection - Main I2C device class\n// Abstracts bit and byte I2C R/W functions into a convenient class\n// 6/9/2012 by Jeff Rowberg <jeff@rowberg.net>\n//\n// Changelog:\n//     2012-06-09 - fix major issue with reading > 32 bytes at a time with Arduino Wire\n//                - add compiler warnings when using outdated or IDE or limited I2Cdev implementation\n//     2011-11-01 - fix write*Bits mask calculation (thanks sasquatch @ Arduino forums)\n//     2011-10-03 - added automatic Arduino version detection for ease of use\n//     2011-10-02 - added Gene Knight's NBWire TwoWire class implementation with small modifications\n//     2011-08-31 - added support for Arduino 1.0 Wire library (methods are different from 0.x)\n//     2011-08-03 - added optional timeout parameter to read* methods to easily change from default\n//     2011-08-02 - added support for 16-bit registers\n//                - fixed incorrect Doxygen comments on some methods\n//                - added timeout value for read operations (thanks mem @ Arduino forums)\n//     2011-07-30 - changed read/write function structures to return success or byte counts\n//                - made all methods static for multi-device memory savings\n//     2011-07-28 - initial release\n\n/* ============================================\nI2Cdev device library code is placed under the MIT license\nCopyright (c) 2012 Jeff Rowberg\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n===============================================\n*/\n\n#include \"I2Cdev.h\"\n\n#if I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE\n\n    #ifdef I2CDEV_IMPLEMENTATION_WARNINGS\n        #if ARDUINO < 100\n            #warning Using outdated Arduino IDE with Wire library is functionally limiting.\n            #warning Arduino IDE v1.0.1+ with I2Cdev Fastwire implementation is recommended.\n            #warning This I2Cdev implementation does not support:\n            #warning - Repeated starts conditions\n            #warning - Timeout detection (some Wire requests block forever)\n        #elif ARDUINO == 100\n            #warning Using outdated Arduino IDE with Wire library is functionally limiting.\n            #warning Arduino IDE v1.0.1+ with I2Cdev Fastwire implementation is recommended.\n            #warning This I2Cdev implementation does not support:\n            #warning - Repeated starts conditions\n            #warning - Timeout detection (some Wire requests block forever)\n        #elif ARDUINO > 100\n            /*\n            #warning Using current Arduino IDE with Wire library is functionally limiting.\n            #warning Arduino IDE v1.0.1+ with I2CDEV_BUILTIN_FASTWIRE implementation is recommended.\n            #warning This I2Cdev implementation does not support:\n            #warning - Timeout detection (some Wire requests block forever)\n            */\n        #endif\n    #endif\n\n#elif I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE\n\n    #error The I2CDEV_BUILTIN_FASTWIRE implementation is known to be broken right now. Patience, Iago!\n\n#elif I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE\n\n    #ifdef I2CDEV_IMPLEMENTATION_WARNINGS\n        #warning Using I2CDEV_BUILTIN_NBWIRE implementation may adversely affect interrupt detection.\n        #warning This I2Cdev implementation does not support:\n        #warning - Repeated starts conditions\n    #endif\n\n    // NBWire implementation based heavily on code by Gene Knight <Gene@Telobot.com>\n    // Originally posted on the Arduino forum at http://arduino.cc/forum/index.php/topic,70705.0.html\n    // Originally offered to the i2cdevlib project at http://arduino.cc/forum/index.php/topic,68210.30.html\n    TwoWire Wire;\n\n#endif\n\n\n/** Default constructor.\n */\nI2Cdev::I2Cdev() {\n}\n\n/** Read a single bit from an 8-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to read from\n * @param bitNum Bit position to read (0-7)\n * @param data Container for single bit value\n * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)\n * @return Status of read operation (true = success)\n */\nint8_t I2Cdev::readBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t *data, uint16_t timeout) {\n    uint8_t b;\n    uint8_t count = readByte(devAddr, regAddr, &b, timeout);\n    *data = b & (1 << bitNum);\n    return count;\n}\n\n/** Read a single bit from a 16-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to read from\n * @param bitNum Bit position to read (0-15)\n * @param data Container for single bit value\n * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)\n * @return Status of read operation (true = success)\n */\nint8_t I2Cdev::readBitW(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint16_t *data, uint16_t timeout) {\n    uint16_t b;\n    uint8_t count = readWord(devAddr, regAddr, &b, timeout);\n    *data = b & (1 << bitNum);\n    return count;\n}\n\n/** Read multiple bits from an 8-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to read from\n * @param bitStart First bit position to read (0-7)\n * @param length Number of bits to read (not more than 8)\n * @param data Container for right-aligned value (i.e. '101' read from any bitStart position will equal 0x05)\n * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)\n * @return Status of read operation (true = success)\n */\nint8_t I2Cdev::readBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t *data, uint16_t timeout) {\n    // 01101001 read byte\n    // 76543210 bit numbers\n    //    xxx   args: bitStart=4, length=3\n    //    010   masked\n    //   -> 010 shifted\n    uint8_t count, b;\n    if ((count = readByte(devAddr, regAddr, &b, timeout)) != 0) {\n        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);\n        b &= mask;\n        b >>= (bitStart - length + 1);\n        *data = b;\n    }\n    return count;\n}\n\n/** Read multiple bits from a 16-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to read from\n * @param bitStart First bit position to read (0-15)\n * @param length Number of bits to read (not more than 16)\n * @param data Container for right-aligned value (i.e. '101' read from any bitStart position will equal 0x05)\n * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)\n * @return Status of read operation (1 = success, 0 = failure, -1 = timeout)\n */\nint8_t I2Cdev::readBitsW(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint16_t *data, uint16_t timeout) {\n    // 1101011001101001 read byte\n    // fedcba9876543210 bit numbers\n    //    xxx           args: bitStart=12, length=3\n    //    010           masked\n    //           -> 010 shifted\n    uint8_t count;\n    uint16_t w;\n    if ((count = readWord(devAddr, regAddr, &w, timeout)) != 0) {\n        uint16_t mask = ((1 << length) - 1) << (bitStart - length + 1);\n        w &= mask;\n        w >>= (bitStart - length + 1);\n        *data = w;\n    }\n    return count;\n}\n\n/** Read single byte from an 8-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to read from\n * @param data Container for byte value read from device\n * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)\n * @return Status of read operation (true = success)\n */\nint8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout) {\n    return readBytes(devAddr, regAddr, 1, data, timeout);\n}\n\n/** Read single word from a 16-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to read from\n * @param data Container for word value read from device\n * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)\n * @return Status of read operation (true = success)\n */\nint8_t I2Cdev::readWord(uint8_t devAddr, uint8_t regAddr, uint16_t *data, uint16_t timeout) {\n    return readWords(devAddr, regAddr, 1, data, timeout);\n}\n\n/** Read multiple bytes from an 8-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr First register regAddr to read from\n * @param length Number of bytes to read\n * @param data Buffer to store read data in\n * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)\n * @return Number of bytes read (-1 indicates failure)\n */\nint8_t I2Cdev::readBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t *data, uint16_t timeout) {\n    #ifdef I2CDEV_SERIAL_DEBUG\n        Serial.print(\"I2C (0x\");\n        Serial.print(devAddr, HEX);\n        Serial.print(\") reading \");\n        Serial.print(length, DEC);\n        Serial.print(\" bytes from 0x\");\n        Serial.print(regAddr, HEX);\n        Serial.print(\"...\");\n    #endif\n\n    int8_t count = 0;\n    uint32_t t1 = millis();\n\n    #if (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE)\n\n        #if (ARDUINO < 100)\n            // Arduino v00xx (before v1.0), Wire library\n\n            // I2C/TWI subsystem uses internal buffer that breaks with large data requests\n            // so if user requests more than BUFFER_LENGTH bytes, we have to do it in\n            // smaller chunks instead of all at once\n            for (uint8_t k = 0; k < length; k += min(length, BUFFER_LENGTH)) {\n                Wire.beginTransmission(devAddr);\n                Wire.send(regAddr);\n                Wire.endTransmission();\n                Wire.beginTransmission(devAddr);\n                Wire.requestFrom(devAddr, (uint8_t)min(length - k, BUFFER_LENGTH));\n\n                for (; Wire.available() && (timeout == 0 || millis() - t1 < timeout); count++) {\n                    data[count] = Wire.receive();\n                    #ifdef I2CDEV_SERIAL_DEBUG\n                        Serial.print(data[count], HEX);\n                        if (count + 1 < length) Serial.print(\" \");\n                    #endif\n                }\n\n                Wire.endTransmission();\n            }\n        #elif (ARDUINO == 100)\n            // Arduino v1.0.0, Wire library\n            // Adds standardized write() and read() stream methods instead of send() and receive()\n\n            // I2C/TWI subsystem uses internal buffer that breaks with large data requests\n            // so if user requests more than BUFFER_LENGTH bytes, we have to do it in\n            // smaller chunks instead of all at once\n            for (uint8_t k = 0; k < length; k += min(length, BUFFER_LENGTH)) {\n                Wire.beginTransmission(devAddr);\n                Wire.write(regAddr);\n                Wire.endTransmission();\n                Wire.beginTransmission(devAddr);\n                Wire.requestFrom(devAddr, (uint8_t)min(length - k, BUFFER_LENGTH));\n        \n                for (; Wire.available() && (timeout == 0 || millis() - t1 < timeout); count++) {\n                    data[count] = Wire.read();\n                    #ifdef I2CDEV_SERIAL_DEBUG\n                        Serial.print(data[count], HEX);\n                        if (count + 1 < length) Serial.print(\" \");\n                    #endif\n                }\n        \n                Wire.endTransmission();\n            }\n        #elif (ARDUINO > 100)\n            // Arduino v1.0.1+, Wire library\n            // Adds official support for repeated start condition, yay!\n\n            // I2C/TWI subsystem uses internal buffer that breaks with large data requests\n            // so if user requests more than BUFFER_LENGTH bytes, we have to do it in\n            // smaller chunks instead of all at once\n            for (uint8_t k = 0; k < length; k += min(length, BUFFER_LENGTH)) {\n                Wire.beginTransmission(devAddr);\n                Wire.write(regAddr);\n                Wire.endTransmission();\n                Wire.beginTransmission(devAddr);\n                Wire.requestFrom(devAddr, (uint8_t)min(length - k, BUFFER_LENGTH));\n        \n                for (; Wire.available() && (timeout == 0 || millis() - t1 < timeout); count++) {\n                    data[count] = Wire.read();\n                    #ifdef I2CDEV_SERIAL_DEBUG\n                        Serial.print(data[count], HEX);\n                        if (count + 1 < length) Serial.print(\" \");\n                    #endif\n                }\n        \n                Wire.endTransmission();\n            }\n        #endif\n\n    #elif (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE)\n        // Fastwire library (STILL UNDER DEVELOPMENT, NON-FUNCTIONAL!)\n\n        // no loop required for fastwire\n        uint8_t status = Fastwire::readBuf(devAddr, regAddr, data, length);\n        if (status == 0) {\n            count = length; // success\n        } else {\n            count = -1; // error\n        }\n\n    #endif\n\n    // check for timeout\n    if (timeout > 0 && millis() - t1 >= timeout && count < length) count = -1; // timeout\n\n    #ifdef I2CDEV_SERIAL_DEBUG\n        Serial.print(\". Done (\");\n        Serial.print(count, DEC);\n        Serial.println(\" read).\");\n    #endif\n\n    return count;\n}\n\n/** Read multiple words from a 16-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr First register regAddr to read from\n * @param length Number of words to read\n * @param data Buffer to store read data in\n * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)\n * @return Number of words read (0 indicates failure)\n */\nint8_t I2Cdev::readWords(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint16_t *data, uint16_t timeout) {\n    #ifdef I2CDEV_SERIAL_DEBUG\n        Serial.print(\"I2C (0x\");\n        Serial.print(devAddr, HEX);\n        Serial.print(\") reading \");\n        Serial.print(length, DEC);\n        Serial.print(\" words from 0x\");\n        Serial.print(regAddr, HEX);\n        Serial.print(\"...\");\n    #endif\n\n    int8_t count = 0;\n    uint32_t t1 = millis();\n\n    #if (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE)\n\n        #if (ARDUINO < 100)\n            // Arduino v00xx (before v1.0), Wire library\n\n            // I2C/TWI subsystem uses internal buffer that breaks with large data requests\n            // so if user requests more than BUFFER_LENGTH bytes, we have to do it in\n            // smaller chunks instead of all at once\n            for (uint8_t k = 0; k < length * 2; k += min(length * 2, BUFFER_LENGTH)) {\n                Wire.beginTransmission(devAddr);\n                Wire.send(regAddr);\n                Wire.endTransmission();\n                Wire.beginTransmission(devAddr);\n                Wire.requestFrom(devAddr, (uint8_t)(length * 2)); // length=words, this wants bytes\n    \n                bool msb = true; // starts with MSB, then LSB\n                for (; Wire.available() && count < length && (timeout == 0 || millis() - t1 < timeout);) {\n                    if (msb) {\n                        // first byte is bits 15-8 (MSb=15)\n                        data[count] = Wire.receive() << 8;\n                    } else {\n                        // second byte is bits 7-0 (LSb=0)\n                        data[count] |= Wire.receive();\n                        #ifdef I2CDEV_SERIAL_DEBUG\n                            Serial.print(data[count], HEX);\n                            if (count + 1 < length) Serial.print(\" \");\n                        #endif\n                        count++;\n                    }\n                    msb = !msb;\n                }\n\n                Wire.endTransmission();\n            }\n        #elif (ARDUINO == 100)\n            // Arduino v1.0.0, Wire library\n            // Adds standardized write() and read() stream methods instead of send() and receive()\n    \n            // I2C/TWI subsystem uses internal buffer that breaks with large data requests\n            // so if user requests more than BUFFER_LENGTH bytes, we have to do it in\n            // smaller chunks instead of all at once\n            for (uint8_t k = 0; k < length * 2; k += min(length * 2, BUFFER_LENGTH)) {\n                Wire.beginTransmission(devAddr);\n                Wire.write(regAddr);\n                Wire.endTransmission();\n                Wire.beginTransmission(devAddr);\n                Wire.requestFrom(devAddr, (uint8_t)(length * 2)); // length=words, this wants bytes\n    \n                bool msb = true; // starts with MSB, then LSB\n                for (; Wire.available() && count < length && (timeout == 0 || millis() - t1 < timeout);) {\n                    if (msb) {\n                        // first byte is bits 15-8 (MSb=15)\n                        data[count] = Wire.read() << 8;\n                    } else {\n                        // second byte is bits 7-0 (LSb=0)\n                        data[count] |= Wire.read();\n                        #ifdef I2CDEV_SERIAL_DEBUG\n                            Serial.print(data[count], HEX);\n                            if (count + 1 < length) Serial.print(\" \");\n                        #endif\n                        count++;\n                    }\n                    msb = !msb;\n                }\n        \n                Wire.endTransmission();\n            }\n        #elif (ARDUINO > 100)\n            // Arduino v1.0.1+, Wire library\n            // Adds official support for repeated start condition, yay!\n\n            // I2C/TWI subsystem uses internal buffer that breaks with large data requests\n            // so if user requests more than BUFFER_LENGTH bytes, we have to do it in\n            // smaller chunks instead of all at once\n            for (uint8_t k = 0; k < length * 2; k += min(length * 2, BUFFER_LENGTH)) {\n                Wire.beginTransmission(devAddr);\n                Wire.write(regAddr);\n                Wire.endTransmission();\n                Wire.beginTransmission(devAddr);\n                Wire.requestFrom(devAddr, (uint8_t)(length * 2)); // length=words, this wants bytes\n        \n                bool msb = true; // starts with MSB, then LSB\n                for (; Wire.available() && count < length && (timeout == 0 || millis() - t1 < timeout);) {\n                    if (msb) {\n                        // first byte is bits 15-8 (MSb=15)\n                        data[count] = Wire.read() << 8;\n                    } else {\n                        // second byte is bits 7-0 (LSb=0)\n                        data[count] |= Wire.read();\n                        #ifdef I2CDEV_SERIAL_DEBUG\n                            Serial.print(data[count], HEX);\n                            if (count + 1 < length) Serial.print(\" \");\n                        #endif\n                        count++;\n                    }\n                    msb = !msb;\n                }\n        \n                Wire.endTransmission();\n            }\n        #endif\n\n    #elif (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE)\n        // Fastwire library (STILL UNDER DEVELOPMENT, NON-FUNCTIONAL!)\n\n        // no loop required for fastwire\n        uint16_t intermediate[(uint8_t)length];\n        uint8_t status = Fastwire::readBuf(devAddr, regAddr, (uint8_t *)intermediate, (uint8_t)(length * 2));\n        if (status == 0) {\n            count = length; // success\n            for (uint8_t i = 0; i < length; i++) {\n                data[i] = (intermediate[2*i] << 8) | intermediate[2*i + 1];\n            }\n        } else {\n            count = -1; // error\n        }\n\n    #endif\n\n    if (timeout > 0 && millis() - t1 >= timeout && count < length) count = -1; // timeout\n\n    #ifdef I2CDEV_SERIAL_DEBUG\n        Serial.print(\". Done (\");\n        Serial.print(count, DEC);\n        Serial.println(\" read).\");\n    #endif\n    \n    return count;\n}\n\n/** write a single bit in an 8-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to write to\n * @param bitNum Bit position to write (0-7)\n * @param value New bit value to write\n * @return Status of operation (true = success)\n */\nbool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data) {\n    uint8_t b;\n    readByte(devAddr, regAddr, &b);\n    b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));\n    return writeByte(devAddr, regAddr, b);\n}\n\n/** write a single bit in a 16-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to write to\n * @param bitNum Bit position to write (0-15)\n * @param value New bit value to write\n * @return Status of operation (true = success)\n */\nbool I2Cdev::writeBitW(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint16_t data) {\n    uint16_t w;\n    readWord(devAddr, regAddr, &w);\n    w = (data != 0) ? (w | (1 << bitNum)) : (w & ~(1 << bitNum));\n    return writeWord(devAddr, regAddr, w);\n}\n\n/** Write multiple bits in an 8-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to write to\n * @param bitStart First bit position to write (0-7)\n * @param length Number of bits to write (not more than 8)\n * @param data Right-aligned value to write\n * @return Status of operation (true = success)\n */\nbool I2Cdev::writeBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data) {\n    //      010 value to write\n    // 76543210 bit numbers\n    //    xxx   args: bitStart=4, length=3\n    // 00011100 mask byte\n    // 10101111 original value (sample)\n    // 10100011 original & ~mask\n    // 10101011 masked | value\n    uint8_t b;\n    if (readByte(devAddr, regAddr, &b) != 0) {\n        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);\n        data <<= (bitStart - length + 1); // shift data into correct position\n        data &= mask; // zero all non-important bits in data\n        b &= ~(mask); // zero all important bits in existing byte\n        b |= data; // combine data with existing byte\n        return writeByte(devAddr, regAddr, b);\n    } else {\n        return false;\n    }\n}\n\n/** Write multiple bits in a 16-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to write to\n * @param bitStart First bit position to write (0-15)\n * @param length Number of bits to write (not more than 16)\n * @param data Right-aligned value to write\n * @return Status of operation (true = success)\n */\nbool I2Cdev::writeBitsW(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint16_t data) {\n    //              010 value to write\n    // fedcba9876543210 bit numbers\n    //    xxx           args: bitStart=12, length=3\n    // 0001110000000000 mask byte\n    // 1010111110010110 original value (sample)\n    // 1010001110010110 original & ~mask\n    // 1010101110010110 masked | value\n    uint16_t w;\n    if (readWord(devAddr, regAddr, &w) != 0) {\n        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);\n        data <<= (bitStart - length + 1); // shift data into correct position\n        data &= mask; // zero all non-important bits in data\n        w &= ~(mask); // zero all important bits in existing word\n        w |= data; // combine data with existing word\n        return writeWord(devAddr, regAddr, w);\n    } else {\n        return false;\n    }\n}\n\n/** Write single byte to an 8-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register address to write to\n * @param data New byte value to write\n * @return Status of operation (true = success)\n */\nbool I2Cdev::writeByte(uint8_t devAddr, uint8_t regAddr, uint8_t data) {\n    return writeBytes(devAddr, regAddr, 1, &data);\n}\n\n/** Write single word to a 16-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register address to write to\n * @param data New word value to write\n * @return Status of operation (true = success)\n */\nbool I2Cdev::writeWord(uint8_t devAddr, uint8_t regAddr, uint16_t data) {\n    return writeWords(devAddr, regAddr, 1, &data);\n}\n\n/** Write multiple bytes to an 8-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr First register address to write to\n * @param length Number of bytes to write\n * @param data Buffer to copy new data from\n * @return Status of operation (true = success)\n */\nbool I2Cdev::writeBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t* data) {\n    #ifdef I2CDEV_SERIAL_DEBUG\n        Serial.print(\"I2C (0x\");\n        Serial.print(devAddr, HEX);\n        Serial.print(\") writing \");\n        Serial.print(length, DEC);\n        Serial.print(\" bytes to 0x\");\n        Serial.print(regAddr, HEX);\n        Serial.print(\"...\");\n    #endif\n    uint8_t status = 0;\n    #if ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO < 100) || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE)\n        Wire.beginTransmission(devAddr);\n        Wire.send((uint8_t) regAddr); // send address\n    #elif (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100)\n        Wire.beginTransmission(devAddr);\n        Wire.write((uint8_t) regAddr); // send address\n    #endif\n    for (uint8_t i = 0; i < length; i++) {\n        #if ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO < 100) || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE)\n            Wire.send((uint8_t) data[i]);\n        #elif (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100)\n            Wire.write((uint8_t) data[i]);\n        #elif (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE)\n            status = Fastwire::write(devAddr, regAddr, data[i]);\n            Serial.println(status);\n        #endif\n        #ifdef I2CDEV_SERIAL_DEBUG\n            Serial.print(data[i], HEX);\n            if (i + 1 < length) Serial.print(\" \");\n        #endif\n    }\n    #if ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO < 100) || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE)\n        Wire.endTransmission();\n    #elif (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100)\n        status = Wire.endTransmission();\n    #endif\n    #ifdef I2CDEV_SERIAL_DEBUG\n        Serial.println(\". Done.\");\n    #endif\n    return status == 0;\n}\n\n/** Write multiple words to a 16-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr First register address to write to\n * @param length Number of words to write\n * @param data Buffer to copy new data from\n * @return Status of operation (true = success)\n */\nbool I2Cdev::writeWords(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint16_t* data) {\n    #ifdef I2CDEV_SERIAL_DEBUG\n        Serial.print(\"I2C (0x\");\n        Serial.print(devAddr, HEX);\n        Serial.print(\") writing \");\n        Serial.print(length, DEC);\n        Serial.print(\" words to 0x\");\n        Serial.print(regAddr, HEX);\n        Serial.print(\"...\");\n    #endif\n    uint8_t status = 0;\n    #if ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO < 100) || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE)\n        Wire.beginTransmission(devAddr);\n        Wire.send(regAddr); // send address\n    #elif (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100)\n        Wire.beginTransmission(devAddr);\n        Wire.write(regAddr); // send address\n    #endif\n    for (uint8_t i = 0; i < length * 2; i++) {\n        #if ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO < 100) || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE)\n            Wire.send((uint8_t)(data[i++] >> 8)); // send MSB\n            Wire.send((uint8_t)data[i]);          // send LSB\n        #elif (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100)\n            Wire.write((uint8_t)(data[i++] >> 8)); // send MSB\n            Wire.write((uint8_t)data[i]);          // send LSB\n        #elif (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE)\n            status = Fastwire::write(devAddr, regAddr, (uint8_t)(data[i++] >> 8));\n            status = Fastwire::write(devAddr, regAddr + 1, (uint8_t)data[i]);\n        #endif\n        #ifdef I2CDEV_SERIAL_DEBUG\n            Serial.print(data[i], HEX);\n            if (i + 1 < length) Serial.print(\" \");\n        #endif\n    }\n    #if ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO < 100) || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE)\n        Wire.endTransmission();\n    #elif (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100)\n        status = Wire.endTransmission();\n    #endif\n    #ifdef I2CDEV_SERIAL_DEBUG\n        Serial.println(\". Done.\");\n    #endif\n    return status == 0;\n}\n\n/** Default timeout value for read operations.\n * Set this to 0 to disable timeout detection.\n */\nuint16_t I2Cdev::readTimeout = I2CDEV_DEFAULT_READ_TIMEOUT;\n\n#if I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE\n    /*\n    FastWire 0.2\n    This is a library to help faster programs to read I2C devices.\n    Copyright(C) 2011 Francesco Ferrara\n    occhiobello at gmail dot com\n    */\n\n    boolean Fastwire::waitInt() {\n        int l = 250;\n        while (!(TWCR & (1 << TWINT)) && l-- > 0);\n        return l > 0;\n    }\n\n    void Fastwire::setup(int khz, boolean pullup) {\n        TWCR = 0;\n        #if defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) || defined(__AVR_ATmega328P__)\n            // activate internal pull-ups for twi (PORTC bits 4 & 5)\n            // as per note from atmega8 manual pg167\n            if (pullup) PORTC |= ((1 << 4) | (1 << 5));\n            else        PORTC &= ~((1 << 4) | (1 << 5));\n        #elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644__)\n            // activate internal pull-ups for twi (PORTC bits 0 & 1)\n            if (pullup) PORTC |= ((1 << 0) | (1 << 1));\n            else        PORTC &= ~((1 << 0) | (1 << 1));\n        #else\n            // activate internal pull-ups for twi (PORTD bits 0 & 1)\n            // as per note from atmega128 manual pg204\n            if (pullup) PORTD |= ((1 << 0) | (1 << 1));\n            else        PORTD &= ~((1 << 0) | (1 << 1));\n        #endif\n\n        TWSR = 0; // no prescaler => prescaler = 1\n        TWBR = ((16000L / khz) - 16) / 2; // change the I2C clock rate\n        TWCR = 1 << TWEN; // enable twi module, no interrupt\n    }\n\n    byte Fastwire::write(byte device, byte address, byte value) {\n        byte twst, retry;\n\n        retry = 2;\n        do {\n            TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO) | (1 << TWSTA);\n            if (!waitInt()) return 1;\n            twst = TWSR & 0xF8;\n            if (twst != TW_START && twst != TW_REP_START) return 2;\n\n            TWDR = device & 0xFE; // send device address without read bit (1)\n            TWCR = (1 << TWINT) | (1 << TWEN);\n            if (!waitInt()) return 3;\n            twst = TWSR & 0xF8;\n        } while (twst == TW_MT_SLA_NACK && retry-- > 0);\n        if (twst != TW_MT_SLA_ACK) return 4;\n\n        TWDR = address; // send data to the previously addressed device\n        TWCR = (1 << TWINT) | (1 << TWEN);\n        if (!waitInt()) return 5;\n        twst = TWSR & 0xF8;\n        if (twst != TW_MT_DATA_ACK) return 6;\n\n        TWDR = value; // send data to the previously addressed device\n        TWCR = (1 << TWINT) | (1 << TWEN);\n        if (!waitInt()) return 7;\n        twst = TWSR & 0xF8;\n        if (twst != TW_MT_DATA_ACK) return 8;\n\n        return 0;\n    }\n\n    byte Fastwire::readBuf(byte device, byte address, byte *data, byte num) {\n        byte twst, retry;\n\n        retry = 2;\n        do {\n            TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO) | (1 << TWSTA);\n            if (!waitInt()) return 16;\n            twst = TWSR & 0xF8;\n            if (twst != TW_START && twst != TW_REP_START) return 17;\n\n            TWDR = device & 0xfe; // send device address to write\n            TWCR = (1 << TWINT) | (1 << TWEN);\n            if (!waitInt()) return 18;\n            twst = TWSR & 0xF8;\n        } while (twst == TW_MT_SLA_NACK && retry-- > 0);\n        if (twst != TW_MT_SLA_ACK) return 19;\n\n        TWDR = address; // send data to the previously addressed device\n        TWCR = (1 << TWINT) | (1 << TWEN);\n        if (!waitInt()) return 20;\n        twst = TWSR & 0xF8;\n        if (twst != TW_MT_DATA_ACK) return 21;\n\n        /***/\n\n        retry = 2;\n        do {\n            TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO) | (1 << TWSTA);\n            if (!waitInt()) return 22;\n            twst = TWSR & 0xF8;\n            if (twst != TW_START && twst != TW_REP_START) return 23;\n\n            TWDR = device | 0x01; // send device address with the read bit (1)\n            TWCR = (1 << TWINT) | (1 << TWEN);\n            if (!waitInt()) return 24;\n            twst = TWSR & 0xF8;\n        } while (twst == TW_MR_SLA_NACK && retry-- > 0);\n        if (twst != TW_MR_SLA_ACK) return 25;\n\n        for(uint8_t i = 0; i < num; i++) {\n            if (i == num - 1)\n               TWCR = (1 << TWINT) | (1 << TWEN);\n            else\n                TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWEA);\n            if (!waitInt()) return 26;\n            twst = TWSR & 0xF8;\n            if (twst != TW_MR_DATA_ACK && twst != TW_MR_DATA_NACK) return twst;\n            data[i] = TWDR;\n        }\n\n        return 0;\n   }\n#endif\n\n#if I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE\n    // NBWire implementation based heavily on code by Gene Knight <Gene@Telobot.com>\n    // Originally posted on the Arduino forum at http://arduino.cc/forum/index.php/topic,70705.0.html\n    // Originally offered to the i2cdevlib project at http://arduino.cc/forum/index.php/topic,68210.30.html\n\n    /*\n    call this version 1.0\n    \n    Offhand, the only funky part that I can think of is in nbrequestFrom, where the buffer\n    length and index are set *before* the data is actually read. The problem is that these\n    are variables local to the TwoWire object, and by the time we actually have read the\n    data, and know what the length actually is, we have no simple access to the object's \n    variables. The actual bytes read *is* given to the callback function, though.\n    \n    The ISR code for a slave receiver is commented out. I don't have that setup, and can't\n    verify it at this time. Save it for 2.0!\n    \n    The handling of the read and write processes here is much like in the demo sketch code: \n    the process is broken down into sequential functions, where each registers the next as a\n    callback, essentially.\n    \n    For example, for the Read process, twi_read00 just returns if TWI is not yet in a \n    ready state. When there's another interrupt, and the interface *is* ready, then it\n    sets up the read, starts it, and registers twi_read01 as the function to call after\n    the *next* interrupt. twi_read01, then, just returns if the interface is still in a\n    \"reading\" state. When the reading is done, it copies the information to the buffer,\n    cleans up, and calls the user-requested callback function with the actual number of \n    bytes read.\n    \n    The writing is similar.\n    \n    Questions, comments and problems can go to Gene@Telobot.com.\n    \n    Thumbs Up!\n    Gene Knight\n    \n    */\n    \n    uint8_t TwoWire::rxBuffer[NBWIRE_BUFFER_LENGTH];\n    uint8_t TwoWire::rxBufferIndex = 0;\n    uint8_t TwoWire::rxBufferLength = 0;\n    \n    uint8_t TwoWire::txAddress = 0;\n    uint8_t TwoWire::txBuffer[NBWIRE_BUFFER_LENGTH];\n    uint8_t TwoWire::txBufferIndex = 0;\n    uint8_t TwoWire::txBufferLength = 0;\n    \n    //uint8_t TwoWire::transmitting = 0;\n    void (*TwoWire::user_onRequest)(void);\n    void (*TwoWire::user_onReceive)(int);\n    \n    static volatile uint8_t twi_transmitting;\n    static volatile uint8_t twi_state;\n    static uint8_t twi_slarw;\n    static volatile uint8_t twi_error;\n    static uint8_t twi_masterBuffer[TWI_BUFFER_LENGTH];\n    static volatile uint8_t twi_masterBufferIndex;\n    static uint8_t twi_masterBufferLength;\n    static uint8_t twi_rxBuffer[TWI_BUFFER_LENGTH];\n    static volatile uint8_t twi_rxBufferIndex;\n    //static volatile uint8_t twi_Interrupt_Continue_Command;\n    static volatile uint8_t twi_Return_Value;\n    static volatile uint8_t twi_Done;\n    void (*twi_cbendTransmissionDone)(int);\n    void (*twi_cbreadFromDone)(int);\n    \n    void twi_init() {\n        // initialize state\n        twi_state = TWI_READY;\n\n        // activate internal pull-ups for twi\n        // as per note from atmega8 manual pg167\n        sbi(PORTC, 4);\n        sbi(PORTC, 5);\n\n        // initialize twi prescaler and bit rate\n        cbi(TWSR, TWPS0); // TWI Status Register - Prescaler bits\n        cbi(TWSR, TWPS1);\n\n        /* twi bit rate formula from atmega128 manual pg 204\n        SCL Frequency = CPU Clock Frequency / (16 + (2 * TWBR))\n        note: TWBR should be 10 or higher for master mode\n        It is 72 for a 16mhz Wiring board with 100kHz TWI */\n\n        TWBR = ((CPU_FREQ / TWI_FREQ) - 16) / 2; // bitrate register\n        // enable twi module, acks, and twi interrupt\n\n        TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA);\n\n        /* TWEN - TWI Enable Bit\n        TWIE - TWI Interrupt Enable\n        TWEA - TWI Enable Acknowledge Bit\n        TWINT - TWI Interrupt Flag\n        TWSTA - TWI Start Condition\n        */\n    }\n    \n    typedef struct {\n        uint8_t address;\n        uint8_t* data;\n        uint8_t length;\n        uint8_t wait;\n        uint8_t i;\n    } twi_Write_Vars;\n\n    twi_Write_Vars *ptwv = 0;\n    static void (*fNextInterruptFunction)(void) = 0;\n    \n    void twi_Finish(byte bRetVal) {\n        if (ptwv) {\n            free(ptwv);\n            ptwv = 0;\n        }\n        twi_Done = 0xFF;\n        twi_Return_Value = bRetVal;\n        fNextInterruptFunction = 0;\n    }\n    \n    uint8_t twii_WaitForDone(uint16_t timeout) {\n        uint32_t endMillis = millis() + timeout;\n        while (!twi_Done && (timeout == 0 || millis() < endMillis)) continue;\n        return twi_Return_Value;\n    }\n    \n    void twii_SetState(uint8_t ucState) {\n        twi_state = ucState;\n    }\n\n    void twii_SetError(uint8_t ucError) {\n        twi_error = ucError ;\n    }\n\n    void twii_InitBuffer(uint8_t ucPos, uint8_t ucLength) {\n        twi_masterBufferIndex = 0;\n        twi_masterBufferLength = ucLength;\n    }\n\n    void twii_CopyToBuf(uint8_t* pData, uint8_t ucLength) {\n        uint8_t i;\n        for (i = 0; i < ucLength; ++i) {\n            twi_masterBuffer[i] = pData[i];\n        }\n    }\n\n    void twii_CopyFromBuf(uint8_t *pData, uint8_t ucLength) {\n        uint8_t i;\n        for (i = 0; i < ucLength; ++i) {\n            pData[i] = twi_masterBuffer[i];\n        }\n    }\n\n    void twii_SetSlaRW(uint8_t ucSlaRW) {\n        twi_slarw = ucSlaRW;\n    }\n\n    void twii_SetStart() {\n        TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTA);\n    }\n\n    void twi_write01() {\n        if (TWI_MTX == twi_state) return; // blocking test\n        twi_transmitting = 0 ;\n        if (twi_error == 0xFF)\n            twi_Finish (0);    // success\n        else if (twi_error == TW_MT_SLA_NACK)\n            twi_Finish (2);    // error: address send, nack received\n        else if (twi_error == TW_MT_DATA_NACK)\n            twi_Finish (3);    // error: data send, nack received\n        else\n            twi_Finish (4);    // other twi error\n        if (twi_cbendTransmissionDone) return twi_cbendTransmissionDone(twi_Return_Value);\n        return;\n    }\n    \n    \n    void twi_write00() {\n        if (TWI_READY != twi_state) return; // blocking test\n        if (TWI_BUFFER_LENGTH < ptwv -> length) {\n            twi_Finish(1); // end write with error 1\n            return;\n        }\n        twi_Done = 0x00; // show as working\n        twii_SetState(TWI_MTX); // to transmitting\n        twii_SetError(0xFF); // to No Error\n        twii_InitBuffer(0, ptwv -> length); // pointer and length\n        twii_CopyToBuf(ptwv -> data, ptwv -> length); // get the data\n        twii_SetSlaRW((ptwv -> address << 1) | TW_WRITE); // write command\n        twii_SetStart(); // start the cycle\n        fNextInterruptFunction = twi_write01; // next routine\n        return twi_write01();\n    }\n    \n    void twi_writeTo(uint8_t address, uint8_t* data, uint8_t length, uint8_t wait) {\n        uint8_t i;\n        ptwv = (twi_Write_Vars *)malloc(sizeof(twi_Write_Vars));\n        ptwv -> address = address;\n        ptwv -> data = data;\n        ptwv -> length = length;\n        ptwv -> wait = wait;\n        fNextInterruptFunction = twi_write00;\n        return twi_write00();\n    }\n\n    void twi_read01() {\n        if (TWI_MRX == twi_state) return; // blocking test\n        if (twi_masterBufferIndex < ptwv -> length) ptwv -> length = twi_masterBufferIndex;\n        twii_CopyFromBuf(ptwv -> data, ptwv -> length);\n        twi_Finish(ptwv -> length);\n        if (twi_cbreadFromDone) return twi_cbreadFromDone(twi_Return_Value);\n        return;\n    }\n    \n    void twi_read00() {\n        if (TWI_READY != twi_state) return; // blocking test\n        if (TWI_BUFFER_LENGTH < ptwv -> length) twi_Finish(0); // error return\n        twi_Done = 0x00; // show as working\n        twii_SetState(TWI_MRX); // reading\n        twii_SetError(0xFF); // reset error\n        twii_InitBuffer(0, ptwv -> length - 1); // init to one less than length\n        twii_SetSlaRW((ptwv -> address << 1) | TW_READ); // read command\n        twii_SetStart(); // start cycle\n        fNextInterruptFunction = twi_read01;\n        return twi_read01();\n    }\n\n    void twi_readFrom(uint8_t address, uint8_t* data, uint8_t length) {\n        uint8_t i;\n\n        ptwv = (twi_Write_Vars *)malloc(sizeof(twi_Write_Vars));\n        ptwv -> address = address;\n        ptwv -> data = data;\n        ptwv -> length = length;\n        fNextInterruptFunction = twi_read00;\n        return twi_read00();\n    }\n\n    void twi_reply(uint8_t ack) {\n        // transmit master read ready signal, with or without ack\n        if (ack){\n            TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);\n        } else {\n            TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);\n        }\n    }\n    \n    void twi_stop(void) {\n        // send stop condition\n        TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);\n    \n        // wait for stop condition to be exectued on bus\n        // TWINT is not set after a stop condition!\n        while (TWCR & _BV(TWSTO)) {\n            continue;\n        }\n    \n        // update twi state\n        twi_state = TWI_READY;\n    }\n\n    void twi_releaseBus(void) {\n        // release bus\n        TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);\n    \n        // update twi state\n        twi_state = TWI_READY;\n    }\n    \n    SIGNAL(TWI_vect) {\n        switch (TW_STATUS) {\n            // All Master\n            case TW_START:     // sent start condition\n            case TW_REP_START: // sent repeated start condition\n                // copy device address and r/w bit to output register and ack\n                TWDR = twi_slarw;\n                twi_reply(1);\n                break;\n    \n            // Master Transmitter\n            case TW_MT_SLA_ACK:  // slave receiver acked address\n            case TW_MT_DATA_ACK: // slave receiver acked data\n                // if there is data to send, send it, otherwise stop\n                if (twi_masterBufferIndex < twi_masterBufferLength) {\n                    // copy data to output register and ack\n                    TWDR = twi_masterBuffer[twi_masterBufferIndex++];\n                    twi_reply(1);\n                } else {\n                    twi_stop();\n                }\n                break;\n\n            case TW_MT_SLA_NACK:  // address sent, nack received\n                twi_error = TW_MT_SLA_NACK;\n                twi_stop();\n                break;\n\n            case TW_MT_DATA_NACK: // data sent, nack received\n                twi_error = TW_MT_DATA_NACK;\n                twi_stop();\n                break;\n\n            case TW_MT_ARB_LOST: // lost bus arbitration\n                twi_error = TW_MT_ARB_LOST;\n                twi_releaseBus();\n                break;\n    \n            // Master Receiver\n            case TW_MR_DATA_ACK: // data received, ack sent\n                // put byte into buffer\n                twi_masterBuffer[twi_masterBufferIndex++] = TWDR;\n\n            case TW_MR_SLA_ACK:  // address sent, ack received\n                // ack if more bytes are expected, otherwise nack\n                if (twi_masterBufferIndex < twi_masterBufferLength) {\n                    twi_reply(1);\n                } else {\n                    twi_reply(0);\n                }\n                break;\n\n            case TW_MR_DATA_NACK: // data received, nack sent\n                // put final byte into buffer\n                twi_masterBuffer[twi_masterBufferIndex++] = TWDR;\n\n            case TW_MR_SLA_NACK: // address sent, nack received\n                twi_stop();\n                break;\n\n        // TW_MR_ARB_LOST handled by TW_MT_ARB_LOST case\n\n        // Slave Receiver (NOT IMPLEMENTED YET)\n        /*\n            case TW_SR_SLA_ACK:   // addressed, returned ack\n            case TW_SR_GCALL_ACK: // addressed generally, returned ack\n            case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack\n            case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack\n                // enter slave receiver mode\n                twi_state = TWI_SRX;\n\n                // indicate that rx buffer can be overwritten and ack\n                twi_rxBufferIndex = 0;\n                twi_reply(1);\n                break;\n\n            case TW_SR_DATA_ACK:       // data received, returned ack\n            case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack\n                // if there is still room in the rx buffer\n                if (twi_rxBufferIndex < TWI_BUFFER_LENGTH) {\n                    // put byte in buffer and ack\n                    twi_rxBuffer[twi_rxBufferIndex++] = TWDR;\n                    twi_reply(1);\n                } else {\n                    // otherwise nack\n                    twi_reply(0);\n                }\n                break;\n\n            case TW_SR_STOP: // stop or repeated start condition received\n                // put a null char after data if there's room\n                if (twi_rxBufferIndex < TWI_BUFFER_LENGTH) {\n                    twi_rxBuffer[twi_rxBufferIndex] = 0;\n                }\n\n                // sends ack and stops interface for clock stretching\n                twi_stop();\n\n                // callback to user defined callback\n                twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);\n\n                // since we submit rx buffer to \"wire\" library, we can reset it\n                twi_rxBufferIndex = 0;\n\n                // ack future responses and leave slave receiver state\n                twi_releaseBus();\n                break;\n\n            case TW_SR_DATA_NACK:       // data received, returned nack\n            case TW_SR_GCALL_DATA_NACK: // data received generally, returned nack\n                // nack back at master\n                twi_reply(0);\n                break;\n\n            // Slave Transmitter\n            case TW_ST_SLA_ACK:          // addressed, returned ack\n            case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack\n                // enter slave transmitter mode\n                twi_state = TWI_STX;\n\n                // ready the tx buffer index for iteration\n                twi_txBufferIndex = 0;\n\n                // set tx buffer length to be zero, to verify if user changes it\n                twi_txBufferLength = 0;\n\n                // request for txBuffer to be filled and length to be set\n                // note: user must call twi_transmit(bytes, length) to do this\n                twi_onSlaveTransmit();\n\n                // if they didn't change buffer & length, initialize it\n                if (0 == twi_txBufferLength) {\n                    twi_txBufferLength = 1;\n                    twi_txBuffer[0] = 0x00;\n                }\n                \n                // transmit first byte from buffer, fall through\n\n            case TW_ST_DATA_ACK: // byte sent, ack returned\n                // copy data to output register\n                TWDR = twi_txBuffer[twi_txBufferIndex++];\n\n                // if there is more to send, ack, otherwise nack\n                if (twi_txBufferIndex < twi_txBufferLength) {\n                    twi_reply(1);\n                } else {\n                    twi_reply(0);\n                }\n                break;\n\n            case TW_ST_DATA_NACK: // received nack, we are done\n            case TW_ST_LAST_DATA: // received ack, but we are done already!\n                // ack future responses\n                twi_reply(1);\n                // leave slave receiver state\n                twi_state = TWI_READY;\n                break;\n            */\n\n            // all\n            case TW_NO_INFO:   // no state information\n                break;\n\n            case TW_BUS_ERROR: // bus error, illegal stop/start\n                twi_error = TW_BUS_ERROR;\n                twi_stop();\n                break;\n        }\n\n        if (fNextInterruptFunction) return fNextInterruptFunction();\n    }\n\n    TwoWire::TwoWire() { }\n    \n    void TwoWire::begin(void) {\n        rxBufferIndex = 0;\n        rxBufferLength = 0;\n    \n        txBufferIndex = 0;\n        txBufferLength = 0;\n\n        twi_init();\n    }\n    \n    void TwoWire::beginTransmission(uint8_t address) {\n        //beginTransmission((uint8_t)address);\n\n        // indicate that we are transmitting\n        twi_transmitting = 1;\n        \n        // set address of targeted slave\n        txAddress = address;\n        \n        // reset tx buffer iterator vars\n        txBufferIndex = 0;\n        txBufferLength = 0;\n    }\n    \n    uint8_t TwoWire::endTransmission(uint16_t timeout) {\n        // transmit buffer (blocking)\n        //int8_t ret =\n        twi_cbendTransmissionDone = NULL;\n        twi_writeTo(txAddress, txBuffer, txBufferLength, 1);\n        int8_t ret = twii_WaitForDone(timeout);\n\n        // reset tx buffer iterator vars\n        txBufferIndex = 0;\n        txBufferLength = 0;\n\n        // indicate that we are done transmitting\n        // twi_transmitting = 0;\n        return ret;\n    }\n\n    void TwoWire::nbendTransmission(void (*function)(int)) {\n        twi_cbendTransmissionDone = function;\n        twi_writeTo(txAddress, txBuffer, txBufferLength, 1);\n        return;\n    }\n    \n    void TwoWire::send(uint8_t data) {\n        if (twi_transmitting) {\n            // in master transmitter mode\n            // don't bother if buffer is full\n            if (txBufferLength >= NBWIRE_BUFFER_LENGTH) {\n                return;\n            }\n\n            // put byte in tx buffer\n            txBuffer[txBufferIndex] = data;\n            ++txBufferIndex;\n\n            // update amount in buffer\n            txBufferLength = txBufferIndex;\n        } else {\n            // in slave send mode\n            // reply to master\n            //twi_transmit(&data, 1);\n        }\n    }\n    \n    uint8_t TwoWire::receive(void) {\n        // default to returning null char\n        // for people using with char strings\n        uint8_t value = 0;\n      \n        // get each successive byte on each call\n        if (rxBufferIndex < rxBufferLength) {\n            value = rxBuffer[rxBufferIndex];\n            ++rxBufferIndex;\n        }\n    \n        return value;\n    }\n    \n    uint8_t TwoWire::requestFrom(uint8_t address, int quantity, uint16_t timeout) {\n        // clamp to buffer length\n        if (quantity > NBWIRE_BUFFER_LENGTH) {\n            quantity = NBWIRE_BUFFER_LENGTH;\n        }\n\n        // perform blocking read into buffer\n        twi_cbreadFromDone = NULL;\n        twi_readFrom(address, rxBuffer, quantity);\n        uint8_t read = twii_WaitForDone(timeout);\n\n        // set rx buffer iterator vars\n        rxBufferIndex = 0;\n        rxBufferLength = read;\n    \n        return read;\n    }\n    \n    void TwoWire::nbrequestFrom(uint8_t address, int quantity, void (*function)(int)) {\n        // clamp to buffer length\n        if (quantity > NBWIRE_BUFFER_LENGTH) {\n            quantity = NBWIRE_BUFFER_LENGTH;\n        }\n\n        // perform blocking read into buffer\n        twi_cbreadFromDone = function;\n        twi_readFrom(address, rxBuffer, quantity);\n        //uint8_t read = twii_WaitForDone();\n\n        // set rx buffer iterator vars\n        //rxBufferIndex = 0;\n        //rxBufferLength = read;\n\n        rxBufferIndex = 0;\n        rxBufferLength = quantity; // this is a hack\n\n        return; //read;\n    }\n\n    uint8_t TwoWire::available(void) {\n        return rxBufferLength - rxBufferIndex;\n    }\n\n#endif\n"},{"name":"MPU6050.cpp","type":"source","group":"legacy","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/../../../MATLAB Add-Ons/Collections/Rensselaer Arduino Support Package Library (RASPLib)/RASPlib/src","tag":"","groupDisplay":"Other files","code":"// I2Cdev library collection - MPU6050 I2C device class\n// Based on InvenSense MPU-6050 register map document rev. 2.0, 5/19/2011 (RM-MPU-6000A-00)\n// 8/24/2011 by Jeff Rowberg <jeff@rowberg.net>\n// Updates should (hopefully) always be available at https://github.com/jrowberg/i2cdevlib\n//\n// Changelog:\n//     ... - ongoing debug release\n\n// NOTE: THIS IS ONLY A PARIAL RELEASE. THIS DEVICE CLASS IS CURRENTLY UNDERGOING ACTIVE\n// DEVELOPMENT AND IS STILL MISSING SOME IMPORTANT FEATURES. PLEASE KEEP THIS IN MIND IF\n// YOU DECIDE TO USE THIS PARTICULAR CODE FOR ANYTHING.\n\n/* ============================================\nI2Cdev device library code is placed under the MIT license\nCopyright (c) 2012 Jeff Rowberg\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n===============================================\n*/\n\n#include \"MPU6050.h\"\n\n/** Default constructor, uses default I2C address.\n * @see MPU6050_DEFAULT_ADDRESS\n */\nMPU6050::MPU6050() {\n    devAddr = MPU6050_DEFAULT_ADDRESS;\n}\n\n/** Specific address constructor.\n * @param address I2C address\n * @see MPU6050_DEFAULT_ADDRESS\n * @see MPU6050_ADDRESS_AD0_LOW\n * @see MPU6050_ADDRESS_AD0_HIGH\n */\nMPU6050::MPU6050(uint8_t address) {\n    devAddr = address;\n}\n\n/** Power on and prepare for general usage.\n * This will activate the device and take it out of sleep mode (which must be done\n * after start-up). This function also sets both the accelerometer and the gyroscope\n * to their most sensitive settings, namely +/- 2g and +/- 250 degrees/sec, and sets\n * the clock source to use the X Gyro for reference, which is slightly better than\n * the default internal clock source.\n */\nvoid MPU6050::initialize() {\n    setClockSource(MPU6050_CLOCK_PLL_XGYRO);\n    setFullScaleGyroRange(MPU6050_GYRO_FS_250); // JLH MPU6050_GYRO_FS_2000  MPU6050_GYRO_FS_250\n    setFullScaleAccelRange(MPU6050_ACCEL_FS_2);\n    setSleepEnabled(false); // thanks to Jack Elston for pointing this one out!\n}\n\n/** Verify the I2C connection.\n * Make sure the device is connected and responds as expected.\n * @return True if connection is valid, false otherwise\n */\nbool MPU6050::testConnection() {\n    return getDeviceID() == 0x34;\n}\n\n// AUX_VDDIO register (InvenSense demo code calls this RA_*G_OFFS_TC)\n\n/** Get the auxiliary I2C supply voltage level.\n * When set to 1, the auxiliary I2C bus high logic level is VDD. When cleared to\n * 0, the auxiliary I2C bus high logic level is VLOGIC. This does not apply to\n * the MPU-6000, which does not have a VLOGIC pin.\n * @return I2C supply voltage level (0=VLOGIC, 1=VDD)\n */\nuint8_t MPU6050::getAuxVDDIOLevel() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_YG_OFFS_TC, MPU6050_TC_PWR_MODE_BIT, buffer);\n    return buffer[0];\n}\n/** Set the auxiliary I2C supply voltage level.\n * When set to 1, the auxiliary I2C bus high logic level is VDD. When cleared to\n * 0, the auxiliary I2C bus high logic level is VLOGIC. This does not apply to\n * the MPU-6000, which does not have a VLOGIC pin.\n * @param level I2C supply voltage level (0=VLOGIC, 1=VDD)\n */\nvoid MPU6050::setAuxVDDIOLevel(uint8_t level) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_YG_OFFS_TC, MPU6050_TC_PWR_MODE_BIT, level);\n}\n\n// SMPLRT_DIV register\n\n/** Get gyroscope output rate divider.\n * The sensor register output, FIFO output, DMP sampling, Motion detection, Zero\n * Motion detection, and Free Fall detection are all based on the Sample Rate.\n * The Sample Rate is generated by dividing the gyroscope output rate by\n * SMPLRT_DIV:\n *\n * Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)\n *\n * where Gyroscope Output Rate = 8kHz when the DLPF is disabled (DLPF_CFG = 0 or\n * 7), and 1kHz when the DLPF is enabled (see Register 26).\n *\n * Note: The accelerometer output rate is 1kHz. This means that for a Sample\n * Rate greater than 1kHz, the same accelerometer sample may be output to the\n * FIFO, DMP, and sensor registers more than once.\n *\n * For a diagram of the gyroscope and accelerometer signal paths, see Section 8\n * of the MPU-6000/MPU-6050 Product Specification document.\n *\n * @return Current sample rate\n * @see MPU6050_RA_SMPLRT_DIV\n */\nuint8_t MPU6050::getRate() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_SMPLRT_DIV, buffer);\n    return buffer[0];\n}\n/** Set gyroscope sample rate divider.\n * @param rate New sample rate divider\n * @see getRate()\n * @see MPU6050_RA_SMPLRT_DIV\n */\nvoid MPU6050::setRate(uint8_t rate) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_SMPLRT_DIV, rate);\n}\n\n// CONFIG register\n\n/** Get external FSYNC configuration.\n * Configures the external Frame Synchronization (FSYNC) pin sampling. An\n * external signal connected to the FSYNC pin can be sampled by configuring\n * EXT_SYNC_SET. Signal changes to the FSYNC pin are latched so that short\n * strobes may be captured. The latched FSYNC signal will be sampled at the\n * Sampling Rate, as defined in register 25. After sampling, the latch will\n * reset to the current FSYNC signal state.\n *\n * The sampled value will be reported in place of the least significant bit in\n * a sensor data register determined by the value of EXT_SYNC_SET according to\n * the following table.\n *\n * <pre>\n * EXT_SYNC_SET | FSYNC Bit Location\n * -------------+-------------------\n * 0            | Input disabled\n * 1            | TEMP_OUT_L[0]\n * 2            | GYRO_XOUT_L[0]\n * 3            | GYRO_YOUT_L[0]\n * 4            | GYRO_ZOUT_L[0]\n * 5            | ACCEL_XOUT_L[0]\n * 6            | ACCEL_YOUT_L[0]\n * 7            | ACCEL_ZOUT_L[0]\n * </pre>\n *\n * @return FSYNC configuration value\n */\nuint8_t MPU6050::getExternalFrameSync() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_CONFIG, MPU6050_CFG_EXT_SYNC_SET_BIT, MPU6050_CFG_EXT_SYNC_SET_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set external FSYNC configuration.\n * @see getExternalFrameSync()\n * @see MPU6050_RA_CONFIG\n * @param sync New FSYNC configuration value\n */\nvoid MPU6050::setExternalFrameSync(uint8_t sync) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_CONFIG, MPU6050_CFG_EXT_SYNC_SET_BIT, MPU6050_CFG_EXT_SYNC_SET_LENGTH, sync);\n}\n/** Get digital low-pass filter configuration.\n * The DLPF_CFG parameter sets the digital low pass filter configuration. It\n * also determines the internal sampling rate used by the device as shown in\n * the table below.\n *\n * Note: The accelerometer output rate is 1kHz. This means that for a Sample\n * Rate greater than 1kHz, the same accelerometer sample may be output to the\n * FIFO, DMP, and sensor registers more than once.\n *\n * <pre>\n *          |   ACCELEROMETER    |           GYROSCOPE\n * DLPF_CFG | Bandwidth | Delay  | Bandwidth | Delay  | Sample Rate\n * ---------+-----------+--------+-----------+--------+-------------\n * 0        | 260Hz     | 0ms    | 256Hz     | 0.98ms | 8kHz\n * 1        | 184Hz     | 2.0ms  | 188Hz     | 1.9ms  | 1kHz\n * 2        | 94Hz      | 3.0ms  | 98Hz      | 2.8ms  | 1kHz\n * 3        | 44Hz      | 4.9ms  | 42Hz      | 4.8ms  | 1kHz\n * 4        | 21Hz      | 8.5ms  | 20Hz      | 8.3ms  | 1kHz\n * 5        | 10Hz      | 13.8ms | 10Hz      | 13.4ms | 1kHz\n * 6        | 5Hz       | 19.0ms | 5Hz       | 18.6ms | 1kHz\n * 7        |   -- Reserved --   |   -- Reserved --   | Reserved\n * </pre>\n *\n * @return DLFP configuration\n * @see MPU6050_RA_CONFIG\n * @see MPU6050_CFG_DLPF_CFG_BIT\n * @see MPU6050_CFG_DLPF_CFG_LENGTH\n */\nuint8_t MPU6050::getDLPFMode() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_CONFIG, MPU6050_CFG_DLPF_CFG_BIT, MPU6050_CFG_DLPF_CFG_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set digital low-pass filter configuration.\n * @param mode New DLFP configuration setting\n * @see getDLPFBandwidth()\n * @see MPU6050_DLPF_BW_256\n * @see MPU6050_RA_CONFIG\n * @see MPU6050_CFG_DLPF_CFG_BIT\n * @see MPU6050_CFG_DLPF_CFG_LENGTH\n */\nvoid MPU6050::setDLPFMode(uint8_t mode) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_CONFIG, MPU6050_CFG_DLPF_CFG_BIT, MPU6050_CFG_DLPF_CFG_LENGTH, mode);\n}\n\n// GYRO_CONFIG register\n\n/** Get full-scale gyroscope range.\n * The FS_SEL parameter allows setting the full-scale range of the gyro sensors,\n * as described in the table below.\n *\n * <pre>\n * 0 = +/- 250 degrees/sec\n * 1 = +/- 500 degrees/sec\n * 2 = +/- 1000 degrees/sec\n * 3 = +/- 2000 degrees/sec\n * </pre>\n *\n * @return Current full-scale gyroscope range setting\n * @see MPU6050_GYRO_FS_250\n * @see MPU6050_RA_GYRO_CONFIG\n * @see MPU6050_GCONFIG_FS_SEL_BIT\n * @see MPU6050_GCONFIG_FS_SEL_LENGTH\n */\nuint8_t MPU6050::getFullScaleGyroRange() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_GYRO_CONFIG, MPU6050_GCONFIG_FS_SEL_BIT, MPU6050_GCONFIG_FS_SEL_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set full-scale gyroscope range.\n * @param range New full-scale gyroscope range value\n * @see getFullScaleRange()\n * @see MPU6050_GYRO_FS_250\n * @see MPU6050_RA_GYRO_CONFIG\n * @see MPU6050_GCONFIG_FS_SEL_BIT\n * @see MPU6050_GCONFIG_FS_SEL_LENGTH\n */\nvoid MPU6050::setFullScaleGyroRange(uint8_t range) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_GYRO_CONFIG, MPU6050_GCONFIG_FS_SEL_BIT, MPU6050_GCONFIG_FS_SEL_LENGTH, range);\n}\n\n// ACCEL_CONFIG register\n\n/** Get self-test enabled setting for accelerometer X axis.\n * @return Self-test enabled value\n * @see MPU6050_RA_ACCEL_CONFIG\n */\nbool MPU6050::getAccelXSelfTest() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_XA_ST_BIT, buffer);\n    return buffer[0];\n}\n/** Get self-test enabled setting for accelerometer X axis.\n * @param enabled Self-test enabled value\n * @see MPU6050_RA_ACCEL_CONFIG\n */\nvoid MPU6050::setAccelXSelfTest(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_XA_ST_BIT, enabled);\n}\n/** Get self-test enabled value for accelerometer Y axis.\n * @return Self-test enabled value\n * @see MPU6050_RA_ACCEL_CONFIG\n */\nbool MPU6050::getAccelYSelfTest() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_YA_ST_BIT, buffer);\n    return buffer[0];\n}\n/** Get self-test enabled value for accelerometer Y axis.\n * @param enabled Self-test enabled value\n * @see MPU6050_RA_ACCEL_CONFIG\n */\nvoid MPU6050::setAccelYSelfTest(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_YA_ST_BIT, enabled);\n}\n/** Get self-test enabled value for accelerometer Z axis.\n * @return Self-test enabled value\n * @see MPU6050_RA_ACCEL_CONFIG\n */\nbool MPU6050::getAccelZSelfTest() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_ZA_ST_BIT, buffer);\n    return buffer[0];\n}\n/** Set self-test enabled value for accelerometer Z axis.\n * @param enabled Self-test enabled value\n * @see MPU6050_RA_ACCEL_CONFIG\n */\nvoid MPU6050::setAccelZSelfTest(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_ZA_ST_BIT, enabled);\n}\n/** Get full-scale accelerometer range.\n * The FS_SEL parameter allows setting the full-scale range of the accelerometer\n * sensors, as described in the table below.\n *\n * <pre>\n * 0 = +/- 2g\n * 1 = +/- 4g\n * 2 = +/- 8g\n * 3 = +/- 16g\n * </pre>\n *\n * @return Current full-scale accelerometer range setting\n * @see MPU6050_ACCEL_FS_2\n * @see MPU6050_RA_ACCEL_CONFIG\n * @see MPU6050_ACONFIG_AFS_SEL_BIT\n * @see MPU6050_ACONFIG_AFS_SEL_LENGTH\n */\nuint8_t MPU6050::getFullScaleAccelRange() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_AFS_SEL_BIT, MPU6050_ACONFIG_AFS_SEL_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set full-scale accelerometer range.\n * @param range New full-scale accelerometer range setting\n * @see getFullScaleAccelRange()\n */\nvoid MPU6050::setFullScaleAccelRange(uint8_t range) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_AFS_SEL_BIT, MPU6050_ACONFIG_AFS_SEL_LENGTH, range);\n}\n/** Get the high-pass filter configuration.\n * The DHPF is a filter module in the path leading to motion detectors (Free\n * Fall, Motion threshold, and Zero Motion). The high pass filter output is not\n * available to the data registers (see Figure in Section 8 of the MPU-6000/\n * MPU-6050 Product Specification document).\n *\n * The high pass filter has three modes:\n *\n * <pre>\n *    Reset: The filter output settles to zero within one sample. This\n *           effectively disables the high pass filter. This mode may be toggled\n *           to quickly settle the filter.\n *\n *    On:    The high pass filter will pass signals above the cut off frequency.\n *\n *    Hold:  When triggered, the filter holds the present sample. The filter\n *           output will be the difference between the input sample and the held\n *           sample.\n * </pre>\n *\n * <pre>\n * ACCEL_HPF | Filter Mode | Cut-off Frequency\n * ----------+-------------+------------------\n * 0         | Reset       | None\n * 1         | On          | 5Hz\n * 2         | On          | 2.5Hz\n * 3         | On          | 1.25Hz\n * 4         | On          | 0.63Hz\n * 7         | Hold        | None\n * </pre>\n *\n * @return Current high-pass filter configuration\n * @see MPU6050_DHPF_RESET\n * @see MPU6050_RA_ACCEL_CONFIG\n */\nuint8_t MPU6050::getDHPFMode() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_ACCEL_HPF_BIT, MPU6050_ACONFIG_ACCEL_HPF_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set the high-pass filter configuration.\n * @param bandwidth New high-pass filter configuration\n * @see setDHPFMode()\n * @see MPU6050_DHPF_RESET\n * @see MPU6050_RA_ACCEL_CONFIG\n */\nvoid MPU6050::setDHPFMode(uint8_t bandwidth) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_ACCEL_HPF_BIT, MPU6050_ACONFIG_ACCEL_HPF_LENGTH, bandwidth);\n}\n\n// FF_THR register\n\n/** Get free-fall event acceleration threshold.\n * This register configures the detection threshold for Free Fall event\n * detection. The unit of FF_THR is 1LSB = 2mg. Free Fall is detected when the\n * absolute value of the accelerometer measurements for the three axes are each\n * less than the detection threshold. This condition increments the Free Fall\n * duration counter (Register 30). The Free Fall interrupt is triggered when the\n * Free Fall duration counter reaches the time specified in FF_DUR.\n *\n * For more details on the Free Fall detection interrupt, see Section 8.2 of the\n * MPU-6000/MPU-6050 Product Specification document as well as Registers 56 and\n * 58 of this document.\n *\n * @return Current free-fall acceleration threshold value (LSB = 2mg)\n * @see MPU6050_RA_FF_THR\n */\nuint8_t MPU6050::getFreefallDetectionThreshold() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_FF_THR, buffer);\n    return buffer[0];\n}\n/** Get free-fall event acceleration threshold.\n * @param threshold New free-fall acceleration threshold value (LSB = 2mg)\n * @see getFreefallDetectionThreshold()\n * @see MPU6050_RA_FF_THR\n */\nvoid MPU6050::setFreefallDetectionThreshold(uint8_t threshold) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_FF_THR, threshold);\n}\n\n// FF_DUR register\n\n/** Get free-fall event duration threshold.\n * This register configures the duration counter threshold for Free Fall event\n * detection. The duration counter ticks at 1kHz, therefore FF_DUR has a unit\n * of 1 LSB = 1 ms.\n *\n * The Free Fall duration counter increments while the absolute value of the\n * accelerometer measurements are each less than the detection threshold\n * (Register 29). The Free Fall interrupt is triggered when the Free Fall\n * duration counter reaches the time specified in this register.\n *\n * For more details on the Free Fall detection interrupt, see Section 8.2 of\n * the MPU-6000/MPU-6050 Product Specification document as well as Registers 56\n * and 58 of this document.\n *\n * @return Current free-fall duration threshold value (LSB = 1ms)\n * @see MPU6050_RA_FF_DUR\n */\nuint8_t MPU6050::getFreefallDetectionDuration() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_FF_DUR, buffer);\n    return buffer[0];\n}\n/** Get free-fall event duration threshold.\n * @param duration New free-fall duration threshold value (LSB = 1ms)\n * @see getFreefallDetectionDuration()\n * @see MPU6050_RA_FF_DUR\n */\nvoid MPU6050::setFreefallDetectionDuration(uint8_t duration) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_FF_DUR, duration);\n}\n\n// MOT_THR register\n\n/** Get motion detection event acceleration threshold.\n * This register configures the detection threshold for Motion interrupt\n * generation. The unit of MOT_THR is 1LSB = 2mg. Motion is detected when the\n * absolute value of any of the accelerometer measurements exceeds this Motion\n * detection threshold. This condition increments the Motion detection duration\n * counter (Register 32). The Motion detection interrupt is triggered when the\n * Motion Detection counter reaches the time count specified in MOT_DUR\n * (Register 32).\n *\n * The Motion interrupt will indicate the axis and polarity of detected motion\n * in MOT_DETECT_STATUS (Register 97).\n *\n * For more details on the Motion detection interrupt, see Section 8.3 of the\n * MPU-6000/MPU-6050 Product Specification document as well as Registers 56 and\n * 58 of this document.\n *\n * @return Current motion detection acceleration threshold value (LSB = 2mg)\n * @see MPU6050_RA_MOT_THR\n */\nuint8_t MPU6050::getMotionDetectionThreshold() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_MOT_THR, buffer);\n    return buffer[0];\n}\n/** Set free-fall event acceleration threshold.\n * @param threshold New motion detection acceleration threshold value (LSB = 2mg)\n * @see getMotionDetectionThreshold()\n * @see MPU6050_RA_MOT_THR\n */\nvoid MPU6050::setMotionDetectionThreshold(uint8_t threshold) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_MOT_THR, threshold);\n}\n\n// MOT_DUR register\n\n/** Get motion detection event duration threshold.\n * This register configures the duration counter threshold for Motion interrupt\n * generation. The duration counter ticks at 1 kHz, therefore MOT_DUR has a unit\n * of 1LSB = 1ms. The Motion detection duration counter increments when the\n * absolute value of any of the accelerometer measurements exceeds the Motion\n * detection threshold (Register 31). The Motion detection interrupt is\n * triggered when the Motion detection counter reaches the time count specified\n * in this register.\n *\n * For more details on the Motion detection interrupt, see Section 8.3 of the\n * MPU-6000/MPU-6050 Product Specification document.\n *\n * @return Current motion detection duration threshold value (LSB = 1ms)\n * @see MPU6050_RA_MOT_DUR\n */\nuint8_t MPU6050::getMotionDetectionDuration() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_MOT_DUR, buffer);\n    return buffer[0];\n}\n/** Set motion detection event duration threshold.\n * @param duration New motion detection duration threshold value (LSB = 1ms)\n * @see getMotionDetectionDuration()\n * @see MPU6050_RA_MOT_DUR\n */\nvoid MPU6050::setMotionDetectionDuration(uint8_t duration) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_MOT_DUR, duration);\n}\n\n// ZRMOT_THR register\n\n/** Get zero motion detection event acceleration threshold.\n * This register configures the detection threshold for Zero Motion interrupt\n * generation. The unit of ZRMOT_THR is 1LSB = 2mg. Zero Motion is detected when\n * the absolute value of the accelerometer measurements for the 3 axes are each\n * less than the detection threshold. This condition increments the Zero Motion\n * duration counter (Register 34). The Zero Motion interrupt is triggered when\n * the Zero Motion duration counter reaches the time count specified in\n * ZRMOT_DUR (Register 34).\n *\n * Unlike Free Fall or Motion detection, Zero Motion detection triggers an\n * interrupt both when Zero Motion is first detected and when Zero Motion is no\n * longer detected.\n *\n * When a zero motion event is detected, a Zero Motion Status will be indicated\n * in the MOT_DETECT_STATUS register (Register 97). When a motion-to-zero-motion\n * condition is detected, the status bit is set to 1. When a zero-motion-to-\n * motion condition is detected, the status bit is set to 0.\n *\n * For more details on the Zero Motion detection interrupt, see Section 8.4 of\n * the MPU-6000/MPU-6050 Product Specification document as well as Registers 56\n * and 58 of this document.\n *\n * @return Current zero motion detection acceleration threshold value (LSB = 2mg)\n * @see MPU6050_RA_ZRMOT_THR\n */\nuint8_t MPU6050::getZeroMotionDetectionThreshold() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_ZRMOT_THR, buffer);\n    return buffer[0];\n}\n/** Set zero motion detection event acceleration threshold.\n * @param threshold New zero motion detection acceleration threshold value (LSB = 2mg)\n * @see getZeroMotionDetectionThreshold()\n * @see MPU6050_RA_ZRMOT_THR\n */\nvoid MPU6050::setZeroMotionDetectionThreshold(uint8_t threshold) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_ZRMOT_THR, threshold);\n}\n\n// ZRMOT_DUR register\n\n/** Get zero motion detection event duration threshold.\n * This register configures the duration counter threshold for Zero Motion\n * interrupt generation. The duration counter ticks at 16 Hz, therefore\n * ZRMOT_DUR has a unit of 1 LSB = 64 ms. The Zero Motion duration counter\n * increments while the absolute value of the accelerometer measurements are\n * each less than the detection threshold (Register 33). The Zero Motion\n * interrupt is triggered when the Zero Motion duration counter reaches the time\n * count specified in this register.\n *\n * For more details on the Zero Motion detection interrupt, see Section 8.4 of\n * the MPU-6000/MPU-6050 Product Specification document, as well as Registers 56\n * and 58 of this document.\n *\n * @return Current zero motion detection duration threshold value (LSB = 64ms)\n * @see MPU6050_RA_ZRMOT_DUR\n */\nuint8_t MPU6050::getZeroMotionDetectionDuration() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_ZRMOT_DUR, buffer);\n    return buffer[0];\n}\n/** Set zero motion detection event duration threshold.\n * @param duration New zero motion detection duration threshold value (LSB = 1ms)\n * @see getZeroMotionDetectionDuration()\n * @see MPU6050_RA_ZRMOT_DUR\n */\nvoid MPU6050::setZeroMotionDetectionDuration(uint8_t duration) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_ZRMOT_DUR, duration);\n}\n\n// FIFO_EN register\n\n/** Get temperature FIFO enabled value.\n * When set to 1, this bit enables TEMP_OUT_H and TEMP_OUT_L (Registers 65 and\n * 66) to be written into the FIFO buffer.\n * @return Current temperature FIFO enabled value\n * @see MPU6050_RA_FIFO_EN\n */\nbool MPU6050::getTempFIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_TEMP_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set temperature FIFO enabled value.\n * @param enabled New temperature FIFO enabled value\n * @see getTempFIFOEnabled()\n * @see MPU6050_RA_FIFO_EN\n */\nvoid MPU6050::setTempFIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_TEMP_FIFO_EN_BIT, enabled);\n}\n/** Get gyroscope X-axis FIFO enabled value.\n * When set to 1, this bit enables GYRO_XOUT_H and GYRO_XOUT_L (Registers 67 and\n * 68) to be written into the FIFO buffer.\n * @return Current gyroscope X-axis FIFO enabled value\n * @see MPU6050_RA_FIFO_EN\n */\nbool MPU6050::getXGyroFIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_XG_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set gyroscope X-axis FIFO enabled value.\n * @param enabled New gyroscope X-axis FIFO enabled value\n * @see getXGyroFIFOEnabled()\n * @see MPU6050_RA_FIFO_EN\n */\nvoid MPU6050::setXGyroFIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_XG_FIFO_EN_BIT, enabled);\n}\n/** Get gyroscope Y-axis FIFO enabled value.\n * When set to 1, this bit enables GYRO_YOUT_H and GYRO_YOUT_L (Registers 69 and\n * 70) to be written into the FIFO buffer.\n * @return Current gyroscope Y-axis FIFO enabled value\n * @see MPU6050_RA_FIFO_EN\n */\nbool MPU6050::getYGyroFIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_YG_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set gyroscope Y-axis FIFO enabled value.\n * @param enabled New gyroscope Y-axis FIFO enabled value\n * @see getYGyroFIFOEnabled()\n * @see MPU6050_RA_FIFO_EN\n */\nvoid MPU6050::setYGyroFIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_YG_FIFO_EN_BIT, enabled);\n}\n/** Get gyroscope Z-axis FIFO enabled value.\n * When set to 1, this bit enables GYRO_ZOUT_H and GYRO_ZOUT_L (Registers 71 and\n * 72) to be written into the FIFO buffer.\n * @return Current gyroscope Z-axis FIFO enabled value\n * @see MPU6050_RA_FIFO_EN\n */\nbool MPU6050::getZGyroFIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_ZG_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set gyroscope Z-axis FIFO enabled value.\n * @param enabled New gyroscope Z-axis FIFO enabled value\n * @see getZGyroFIFOEnabled()\n * @see MPU6050_RA_FIFO_EN\n */\nvoid MPU6050::setZGyroFIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_ZG_FIFO_EN_BIT, enabled);\n}\n/** Get accelerometer FIFO enabled value.\n * When set to 1, this bit enables ACCEL_XOUT_H, ACCEL_XOUT_L, ACCEL_YOUT_H,\n * ACCEL_YOUT_L, ACCEL_ZOUT_H, and ACCEL_ZOUT_L (Registers 59 to 64) to be\n * written into the FIFO buffer.\n * @return Current accelerometer FIFO enabled value\n * @see MPU6050_RA_FIFO_EN\n */\nbool MPU6050::getAccelFIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_ACCEL_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set accelerometer FIFO enabled value.\n * @param enabled New accelerometer FIFO enabled value\n * @see getAccelFIFOEnabled()\n * @see MPU6050_RA_FIFO_EN\n */\nvoid MPU6050::setAccelFIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_ACCEL_FIFO_EN_BIT, enabled);\n}\n/** Get Slave 2 FIFO enabled value.\n * When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96)\n * associated with Slave 2 to be written into the FIFO buffer.\n * @return Current Slave 2 FIFO enabled value\n * @see MPU6050_RA_FIFO_EN\n */\nbool MPU6050::getSlave2FIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_SLV2_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set Slave 2 FIFO enabled value.\n * @param enabled New Slave 2 FIFO enabled value\n * @see getSlave2FIFOEnabled()\n * @see MPU6050_RA_FIFO_EN\n */\nvoid MPU6050::setSlave2FIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_SLV2_FIFO_EN_BIT, enabled);\n}\n/** Get Slave 1 FIFO enabled value.\n * When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96)\n * associated with Slave 1 to be written into the FIFO buffer.\n * @return Current Slave 1 FIFO enabled value\n * @see MPU6050_RA_FIFO_EN\n */\nbool MPU6050::getSlave1FIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_SLV1_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set Slave 1 FIFO enabled value.\n * @param enabled New Slave 1 FIFO enabled value\n * @see getSlave1FIFOEnabled()\n * @see MPU6050_RA_FIFO_EN\n */\nvoid MPU6050::setSlave1FIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_SLV1_FIFO_EN_BIT, enabled);\n}\n/** Get Slave 0 FIFO enabled value.\n * When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96)\n * associated with Slave 0 to be written into the FIFO buffer.\n * @return Current Slave 0 FIFO enabled value\n * @see MPU6050_RA_FIFO_EN\n */\nbool MPU6050::getSlave0FIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_SLV0_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set Slave 0 FIFO enabled value.\n * @param enabled New Slave 0 FIFO enabled value\n * @see getSlave0FIFOEnabled()\n * @see MPU6050_RA_FIFO_EN\n */\nvoid MPU6050::setSlave0FIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_SLV0_FIFO_EN_BIT, enabled);\n}\n\n// I2C_MST_CTRL register\n\n/** Get multi-master enabled value.\n * Multi-master capability allows multiple I2C masters to operate on the same\n * bus. In circuits where multi-master capability is required, set MULT_MST_EN\n * to 1. This will increase current drawn by approximately 30uA.\n *\n * In circuits where multi-master capability is required, the state of the I2C\n * bus must always be monitored by each separate I2C Master. Before an I2C\n * Master can assume arbitration of the bus, it must first confirm that no other\n * I2C Master has arbitration of the bus. When MULT_MST_EN is set to 1, the\n * MPU-60X0's bus arbitration detection logic is turned on, enabling it to\n * detect when the bus is available.\n *\n * @return Current multi-master enabled value\n * @see MPU6050_RA_I2C_MST_CTRL\n */\nbool MPU6050::getMultiMasterEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_MULT_MST_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set multi-master enabled value.\n * @param enabled New multi-master enabled value\n * @see getMultiMasterEnabled()\n * @see MPU6050_RA_I2C_MST_CTRL\n */\nvoid MPU6050::setMultiMasterEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_MULT_MST_EN_BIT, enabled);\n}\n/** Get wait-for-external-sensor-data enabled value.\n * When the WAIT_FOR_ES bit is set to 1, the Data Ready interrupt will be\n * delayed until External Sensor data from the Slave Devices are loaded into the\n * EXT_SENS_DATA registers. This is used to ensure that both the internal sensor\n * data (i.e. from gyro and accel) and external sensor data have been loaded to\n * their respective data registers (i.e. the data is synced) when the Data Ready\n * interrupt is triggered.\n *\n * @return Current wait-for-external-sensor-data enabled value\n * @see MPU6050_RA_I2C_MST_CTRL\n */\nbool MPU6050::getWaitForExternalSensorEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_WAIT_FOR_ES_BIT, buffer);\n    return buffer[0];\n}\n/** Set wait-for-external-sensor-data enabled value.\n * @param enabled New wait-for-external-sensor-data enabled value\n * @see getWaitForExternalSensorEnabled()\n * @see MPU6050_RA_I2C_MST_CTRL\n */\nvoid MPU6050::setWaitForExternalSensorEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_WAIT_FOR_ES_BIT, enabled);\n}\n/** Get Slave 3 FIFO enabled value.\n * When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96)\n * associated with Slave 3 to be written into the FIFO buffer.\n * @return Current Slave 3 FIFO enabled value\n * @see MPU6050_RA_MST_CTRL\n */\nbool MPU6050::getSlave3FIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_SLV_3_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set Slave 3 FIFO enabled value.\n * @param enabled New Slave 3 FIFO enabled value\n * @see getSlave3FIFOEnabled()\n * @see MPU6050_RA_MST_CTRL\n */\nvoid MPU6050::setSlave3FIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_SLV_3_FIFO_EN_BIT, enabled);\n}\n/** Get slave read/write transition enabled value.\n * The I2C_MST_P_NSR bit configures the I2C Master's transition from one slave\n * read to the next slave read. If the bit equals 0, there will be a restart\n * between reads. If the bit equals 1, there will be a stop followed by a start\n * of the following read. When a write transaction follows a read transaction,\n * the stop followed by a start of the successive write will be always used.\n *\n * @return Current slave read/write transition enabled value\n * @see MPU6050_RA_I2C_MST_CTRL\n */\nbool MPU6050::getSlaveReadWriteTransitionEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_I2C_MST_P_NSR_BIT, buffer);\n    return buffer[0];\n}\n/** Set slave read/write transition enabled value.\n * @param enabled New slave read/write transition enabled value\n * @see getSlaveReadWriteTransitionEnabled()\n * @see MPU6050_RA_I2C_MST_CTRL\n */\nvoid MPU6050::setSlaveReadWriteTransitionEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_I2C_MST_P_NSR_BIT, enabled);\n}\n/** Get I2C master clock speed.\n * I2C_MST_CLK is a 4 bit unsigned value which configures a divider on the\n * MPU-60X0 internal 8MHz clock. It sets the I2C master clock speed according to\n * the following table:\n *\n * <pre>\n * I2C_MST_CLK | I2C Master Clock Speed | 8MHz Clock Divider\n * ------------+------------------------+-------------------\n * 0           | 348kHz                 | 23\n * 1           | 333kHz                 | 24\n * 2           | 320kHz                 | 25\n * 3           | 308kHz                 | 26\n * 4           | 296kHz                 | 27\n * 5           | 286kHz                 | 28\n * 6           | 276kHz                 | 29\n * 7           | 267kHz                 | 30\n * 8           | 258kHz                 | 31\n * 9           | 500kHz                 | 16\n * 10          | 471kHz                 | 17\n * 11          | 444kHz                 | 18\n * 12          | 421kHz                 | 19\n * 13          | 400kHz                 | 20\n * 14          | 381kHz                 | 21\n * 15          | 364kHz                 | 22\n * </pre>\n *\n * @return Current I2C master clock speed\n * @see MPU6050_RA_I2C_MST_CTRL\n */\nuint8_t MPU6050::getMasterClockSpeed() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_I2C_MST_CLK_BIT, MPU6050_I2C_MST_CLK_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set I2C master clock speed.\n * @reparam speed Current I2C master clock speed\n * @see MPU6050_RA_I2C_MST_CTRL\n */\nvoid MPU6050::setMasterClockSpeed(uint8_t speed) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_I2C_MST_CLK_BIT, MPU6050_I2C_MST_CLK_LENGTH, speed);\n}\n\n// I2C_SLV* registers (Slave 0-3)\n\n/** Get the I2C address of the specified slave (0-3).\n * Note that Bit 7 (MSB) controls read/write mode. If Bit 7 is set, it's a read\n * operation, and if it is cleared, then it's a write operation. The remaining\n * bits (6-0) are the 7-bit device address of the slave device.\n *\n * In read mode, the result of the read is placed in the lowest available \n * EXT_SENS_DATA register. For further information regarding the allocation of\n * read results, please refer to the EXT_SENS_DATA register description\n * (Registers 73 - 96).\n *\n * The MPU-6050 supports a total of five slaves, but Slave 4 has unique\n * characteristics, and so it has its own functions (getSlave4* and setSlave4*).\n *\n * I2C data transactions are performed at the Sample Rate, as defined in\n * Register 25. The user is responsible for ensuring that I2C data transactions\n * to and from each enabled Slave can be completed within a single period of the\n * Sample Rate.\n *\n * The I2C slave access rate can be reduced relative to the Sample Rate. This\n * reduced access rate is determined by I2C_MST_DLY (Register 52). Whether a\n * slave's access rate is reduced relative to the Sample Rate is determined by\n * I2C_MST_DELAY_CTRL (Register 103).\n *\n * The processing order for the slaves is fixed. The sequence followed for\n * processing the slaves is Slave 0, Slave 1, Slave 2, Slave 3 and Slave 4. If a\n * particular Slave is disabled it will be skipped.\n *\n * Each slave can either be accessed at the sample rate or at a reduced sample\n * rate. In a case where some slaves are accessed at the Sample Rate and some\n * slaves are accessed at the reduced rate, the sequence of accessing the slaves\n * (Slave 0 to Slave 4) is still followed. However, the reduced rate slaves will\n * be skipped if their access rate dictates that they should not be accessed\n * during that particular cycle. For further information regarding the reduced\n * access rate, please refer to Register 52. Whether a slave is accessed at the\n * Sample Rate or at the reduced rate is determined by the Delay Enable bits in\n * Register 103.\n *\n * @param num Slave number (0-3)\n * @return Current address for specified slave\n * @see MPU6050_RA_I2C_SLV0_ADDR\n */\nuint8_t MPU6050::getSlaveAddress(uint8_t num) {\n    if (num > 3) return 0;\n    I2Cdev::readByte(devAddr, MPU6050_RA_I2C_SLV0_ADDR + num*3, buffer);\n    return buffer[0];\n}\n/** Set the I2C address of the specified slave (0-3).\n * @param num Slave number (0-3)\n * @param address New address for specified slave\n * @see getSlaveAddress()\n * @see MPU6050_RA_I2C_SLV0_ADDR\n */\nvoid MPU6050::setSlaveAddress(uint8_t num, uint8_t address) {\n    if (num > 3) return;\n    I2Cdev::writeByte(devAddr, MPU6050_RA_I2C_SLV0_ADDR + num*3, address);\n}\n/** Get the active internal register for the specified slave (0-3).\n * Read/write operations for this slave will be done to whatever internal\n * register address is stored in this MPU register.\n *\n * The MPU-6050 supports a total of five slaves, but Slave 4 has unique\n * characteristics, and so it has its own functions.\n *\n * @param num Slave number (0-3)\n * @return Current active register for specified slave\n * @see MPU6050_RA_I2C_SLV0_REG\n */\nuint8_t MPU6050::getSlaveRegister(uint8_t num) {\n    if (num > 3) return 0;\n    I2Cdev::readByte(devAddr, MPU6050_RA_I2C_SLV0_REG + num*3, buffer);\n    return buffer[0];\n}\n/** Set the active internal register for the specified slave (0-3).\n * @param num Slave number (0-3)\n * @param reg New active register for specified slave\n * @see getSlaveRegister()\n * @see MPU6050_RA_I2C_SLV0_REG\n */\nvoid MPU6050::setSlaveRegister(uint8_t num, uint8_t reg) {\n    if (num > 3) return;\n    I2Cdev::writeByte(devAddr, MPU6050_RA_I2C_SLV0_REG + num*3, reg);\n}\n/** Get the enabled value for the specified slave (0-3).\n * When set to 1, this bit enables Slave 0 for data transfer operations. When\n * cleared to 0, this bit disables Slave 0 from data transfer operations.\n * @param num Slave number (0-3)\n * @return Current enabled value for specified slave\n * @see MPU6050_RA_I2C_SLV0_CTRL\n */\nbool MPU6050::getSlaveEnabled(uint8_t num) {\n    if (num > 3) return 0;\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set the enabled value for the specified slave (0-3).\n * @param num Slave number (0-3)\n * @param enabled New enabled value for specified slave\n * @see getSlaveEnabled()\n * @see MPU6050_RA_I2C_SLV0_CTRL\n */\nvoid MPU6050::setSlaveEnabled(uint8_t num, bool enabled) {\n    if (num > 3) return;\n    I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_EN_BIT, enabled);\n}\n/** Get word pair byte-swapping enabled for the specified slave (0-3).\n * When set to 1, this bit enables byte swapping. When byte swapping is enabled,\n * the high and low bytes of a word pair are swapped. Please refer to\n * I2C_SLV0_GRP for the pairing convention of the word pairs. When cleared to 0,\n * bytes transferred to and from Slave 0 will be written to EXT_SENS_DATA\n * registers in the order they were transferred.\n *\n * @param num Slave number (0-3)\n * @return Current word pair byte-swapping enabled value for specified slave\n * @see MPU6050_RA_I2C_SLV0_CTRL\n */\nbool MPU6050::getSlaveWordByteSwap(uint8_t num) {\n    if (num > 3) return 0;\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_BYTE_SW_BIT, buffer);\n    return buffer[0];\n}\n/** Set word pair byte-swapping enabled for the specified slave (0-3).\n * @param num Slave number (0-3)\n * @param enabled New word pair byte-swapping enabled value for specified slave\n * @see getSlaveWordByteSwap()\n * @see MPU6050_RA_I2C_SLV0_CTRL\n */\nvoid MPU6050::setSlaveWordByteSwap(uint8_t num, bool enabled) {\n    if (num > 3) return;\n    I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_BYTE_SW_BIT, enabled);\n}\n/** Get write mode for the specified slave (0-3).\n * When set to 1, the transaction will read or write data only. When cleared to\n * 0, the transaction will write a register address prior to reading or writing\n * data. This should equal 0 when specifying the register address within the\n * Slave device to/from which the ensuing data transaction will take place.\n *\n * @param num Slave number (0-3)\n * @return Current write mode for specified slave (0 = register address + data, 1 = data only)\n * @see MPU6050_RA_I2C_SLV0_CTRL\n */\nbool MPU6050::getSlaveWriteMode(uint8_t num) {\n    if (num > 3) return 0;\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_REG_DIS_BIT, buffer);\n    return buffer[0];\n}\n/** Set write mode for the specified slave (0-3).\n * @param num Slave number (0-3)\n * @param mode New write mode for specified slave (0 = register address + data, 1 = data only)\n * @see getSlaveWriteMode()\n * @see MPU6050_RA_I2C_SLV0_CTRL\n */\nvoid MPU6050::setSlaveWriteMode(uint8_t num, bool mode) {\n    if (num > 3) return;\n    I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_REG_DIS_BIT, mode);\n}\n/** Get word pair grouping order offset for the specified slave (0-3).\n * This sets specifies the grouping order of word pairs received from registers.\n * When cleared to 0, bytes from register addresses 0 and 1, 2 and 3, etc (even,\n * then odd register addresses) are paired to form a word. When set to 1, bytes\n * from register addresses are paired 1 and 2, 3 and 4, etc. (odd, then even\n * register addresses) are paired to form a word.\n *\n * @param num Slave number (0-3)\n * @return Current word pair grouping order offset for specified slave\n * @see MPU6050_RA_I2C_SLV0_CTRL\n */\nbool MPU6050::getSlaveWordGroupOffset(uint8_t num) {\n    if (num > 3) return 0;\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_GRP_BIT, buffer);\n    return buffer[0];\n}\n/** Set word pair grouping order offset for the specified slave (0-3).\n * @param num Slave number (0-3)\n * @param enabled New word pair grouping order offset for specified slave\n * @see getSlaveWordGroupOffset()\n * @see MPU6050_RA_I2C_SLV0_CTRL\n */\nvoid MPU6050::setSlaveWordGroupOffset(uint8_t num, bool enabled) {\n    if (num > 3) return;\n    I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_GRP_BIT, enabled);\n}\n/** Get number of bytes to read for the specified slave (0-3).\n * Specifies the number of bytes transferred to and from Slave 0. Clearing this\n * bit to 0 is equivalent to disabling the register by writing 0 to I2C_SLV0_EN.\n * @param num Slave number (0-3)\n * @return Number of bytes to read for specified slave\n * @see MPU6050_RA_I2C_SLV0_CTRL\n */\nuint8_t MPU6050::getSlaveDataLength(uint8_t num) {\n    if (num > 3) return 0;\n    I2Cdev::readBits(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_LEN_BIT, MPU6050_I2C_SLV_LEN_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set number of bytes to read for the specified slave (0-3).\n * @param num Slave number (0-3)\n * @param length Number of bytes to read for specified slave\n * @see getSlaveDataLength()\n * @see MPU6050_RA_I2C_SLV0_CTRL\n */\nvoid MPU6050::setSlaveDataLength(uint8_t num, uint8_t length) {\n    if (num > 3) return;\n    I2Cdev::writeBits(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_LEN_BIT, MPU6050_I2C_SLV_LEN_LENGTH, length);\n}\n\n// I2C_SLV* registers (Slave 4)\n\n/** Get the I2C address of Slave 4.\n * Note that Bit 7 (MSB) controls read/write mode. If Bit 7 is set, it's a read\n * operation, and if it is cleared, then it's a write operation. The remaining\n * bits (6-0) are the 7-bit device address of the slave device.\n *\n * @return Current address for Slave 4\n * @see getSlaveAddress()\n * @see MPU6050_RA_I2C_SLV4_ADDR\n */\nuint8_t MPU6050::getSlave4Address() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_I2C_SLV4_ADDR, buffer);\n    return buffer[0];\n}\n/** Set the I2C address of Slave 4.\n * @param address New address for Slave 4\n * @see getSlave4Address()\n * @see MPU6050_RA_I2C_SLV4_ADDR\n */\nvoid MPU6050::setSlave4Address(uint8_t address) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_I2C_SLV4_ADDR, address);\n}\n/** Get the active internal register for the Slave 4.\n * Read/write operations for this slave will be done to whatever internal\n * register address is stored in this MPU register.\n *\n * @return Current active register for Slave 4\n * @see MPU6050_RA_I2C_SLV4_REG\n */\nuint8_t MPU6050::getSlave4Register() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_I2C_SLV4_REG, buffer);\n    return buffer[0];\n}\n/** Set the active internal register for Slave 4.\n * @param reg New active register for Slave 4\n * @see getSlave4Register()\n * @see MPU6050_RA_I2C_SLV4_REG\n */\nvoid MPU6050::setSlave4Register(uint8_t reg) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_I2C_SLV4_REG, reg);\n}\n/** Set new byte to write to Slave 4.\n * This register stores the data to be written into the Slave 4. If I2C_SLV4_RW\n * is set 1 (set to read), this register has no effect.\n * @param data New byte to write to Slave 4\n * @see MPU6050_RA_I2C_SLV4_DO\n */\nvoid MPU6050::setSlave4OutputByte(uint8_t data) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_I2C_SLV4_DO, data);\n}\n/** Get the enabled value for the Slave 4.\n * When set to 1, this bit enables Slave 4 for data transfer operations. When\n * cleared to 0, this bit disables Slave 4 from data transfer operations.\n * @return Current enabled value for Slave 4\n * @see MPU6050_RA_I2C_SLV4_CTRL\n */\nbool MPU6050::getSlave4Enabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_SLV4_CTRL, MPU6050_I2C_SLV4_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set the enabled value for Slave 4.\n * @param enabled New enabled value for Slave 4\n * @see getSlave4Enabled()\n * @see MPU6050_RA_I2C_SLV4_CTRL\n */\nvoid MPU6050::setSlave4Enabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_SLV4_CTRL, MPU6050_I2C_SLV4_EN_BIT, enabled);\n}\n/** Get the enabled value for Slave 4 transaction interrupts.\n * When set to 1, this bit enables the generation of an interrupt signal upon\n * completion of a Slave 4 transaction. When cleared to 0, this bit disables the\n * generation of an interrupt signal upon completion of a Slave 4 transaction.\n * The interrupt status can be observed in Register 54.\n *\n * @return Current enabled value for Slave 4 transaction interrupts.\n * @see MPU6050_RA_I2C_SLV4_CTRL\n */\nbool MPU6050::getSlave4InterruptEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_SLV4_CTRL, MPU6050_I2C_SLV4_INT_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set the enabled value for Slave 4 transaction interrupts.\n * @param enabled New enabled value for Slave 4 transaction interrupts.\n * @see getSlave4InterruptEnabled()\n * @see MPU6050_RA_I2C_SLV4_CTRL\n */\nvoid MPU6050::setSlave4InterruptEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_SLV4_CTRL, MPU6050_I2C_SLV4_INT_EN_BIT, enabled);\n}\n/** Get write mode for Slave 4.\n * When set to 1, the transaction will read or write data only. When cleared to\n * 0, the transaction will write a register address prior to reading or writing\n * data. This should equal 0 when specifying the register address within the\n * Slave device to/from which the ensuing data transaction will take place.\n *\n * @return Current write mode for Slave 4 (0 = register address + data, 1 = data only)\n * @see MPU6050_RA_I2C_SLV4_CTRL\n */\nbool MPU6050::getSlave4WriteMode() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_SLV4_CTRL, MPU6050_I2C_SLV4_REG_DIS_BIT, buffer);\n    return buffer[0];\n}\n/** Set write mode for the Slave 4.\n * @param mode New write mode for Slave 4 (0 = register address + data, 1 = data only)\n * @see getSlave4WriteMode()\n * @see MPU6050_RA_I2C_SLV4_CTRL\n */\nvoid MPU6050::setSlave4WriteMode(bool mode) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_SLV4_CTRL, MPU6050_I2C_SLV4_REG_DIS_BIT, mode);\n}\n/** Get Slave 4 master delay value.\n * This configures the reduced access rate of I2C slaves relative to the Sample\n * Rate. When a slave's access rate is decreased relative to the Sample Rate,\n * the slave is accessed every:\n *\n *     1 / (1 + I2C_MST_DLY) samples\n *\n * This base Sample Rate in turn is determined by SMPLRT_DIV (register 25) and\n * DLPF_CFG (register 26). Whether a slave's access rate is reduced relative to\n * the Sample Rate is determined by I2C_MST_DELAY_CTRL (register 103). For\n * further information regarding the Sample Rate, please refer to register 25.\n *\n * @return Current Slave 4 master delay value\n * @see MPU6050_RA_I2C_SLV4_CTRL\n */\nuint8_t MPU6050::getSlave4MasterDelay() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_I2C_SLV4_CTRL, MPU6050_I2C_SLV4_MST_DLY_BIT, MPU6050_I2C_SLV4_MST_DLY_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set Slave 4 master delay value.\n * @param delay New Slave 4 master delay value\n * @see getSlave4MasterDelay()\n * @see MPU6050_RA_I2C_SLV4_CTRL\n */\nvoid MPU6050::setSlave4MasterDelay(uint8_t delay) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_I2C_SLV4_CTRL, MPU6050_I2C_SLV4_MST_DLY_BIT, MPU6050_I2C_SLV4_MST_DLY_LENGTH, delay);\n}\n/** Get last available byte read from Slave 4.\n * This register stores the data read from Slave 4. This field is populated\n * after a read transaction.\n * @return Last available byte read from to Slave 4\n * @see MPU6050_RA_I2C_SLV4_DI\n */\nuint8_t MPU6050::getSlate4InputByte() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_I2C_SLV4_DI, buffer);\n    return buffer[0];\n}\n\n// I2C_MST_STATUS register\n\n/** Get FSYNC interrupt status.\n * This bit reflects the status of the FSYNC interrupt from an external device\n * into the MPU-60X0. This is used as a way to pass an external interrupt\n * through the MPU-60X0 to the host application processor. When set to 1, this\n * bit will cause an interrupt if FSYNC_INT_EN is asserted in INT_PIN_CFG\n * (Register 55).\n * @return FSYNC interrupt status\n * @see MPU6050_RA_I2C_MST_STATUS\n */\nbool MPU6050::getPassthroughStatus() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_STATUS, MPU6050_MST_PASS_THROUGH_BIT, buffer);\n    return buffer[0];\n}\n/** Get Slave 4 transaction done status.\n * Automatically sets to 1 when a Slave 4 transaction has completed. This\n * triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register\n * (Register 56) is asserted and if the SLV_4_DONE_INT bit is asserted in the\n * I2C_SLV4_CTRL register (Register 52).\n * @return Slave 4 transaction done status\n * @see MPU6050_RA_I2C_MST_STATUS\n */\nbool MPU6050::getSlave4IsDone() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_STATUS, MPU6050_MST_I2C_SLV4_DONE_BIT, buffer);\n    return buffer[0];\n}\n/** Get master arbitration lost status.\n * This bit automatically sets to 1 when the I2C Master has lost arbitration of\n * the auxiliary I2C bus (an error condition). This triggers an interrupt if the\n * I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted.\n * @return Master arbitration lost status\n * @see MPU6050_RA_I2C_MST_STATUS\n */\nbool MPU6050::getLostArbitration() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_STATUS, MPU6050_MST_I2C_LOST_ARB_BIT, buffer);\n    return buffer[0];\n}\n/** Get Slave 4 NACK status.\n * This bit automatically sets to 1 when the I2C Master receives a NACK in a\n * transaction with Slave 4. This triggers an interrupt if the I2C_MST_INT_EN\n * bit in the INT_ENABLE register (Register 56) is asserted.\n * @return Slave 4 NACK interrupt status\n * @see MPU6050_RA_I2C_MST_STATUS\n */\nbool MPU6050::getSlave4Nack() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_STATUS, MPU6050_MST_I2C_SLV4_NACK_BIT, buffer);\n    return buffer[0];\n}\n/** Get Slave 3 NACK status.\n * This bit automatically sets to 1 when the I2C Master receives a NACK in a\n * transaction with Slave 3. This triggers an interrupt if the I2C_MST_INT_EN\n * bit in the INT_ENABLE register (Register 56) is asserted.\n * @return Slave 3 NACK interrupt status\n * @see MPU6050_RA_I2C_MST_STATUS\n */\nbool MPU6050::getSlave3Nack() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_STATUS, MPU6050_MST_I2C_SLV3_NACK_BIT, buffer);\n    return buffer[0];\n}\n/** Get Slave 2 NACK status.\n * This bit automatically sets to 1 when the I2C Master receives a NACK in a\n * transaction with Slave 2. This triggers an interrupt if the I2C_MST_INT_EN\n * bit in the INT_ENABLE register (Register 56) is asserted.\n * @return Slave 2 NACK interrupt status\n * @see MPU6050_RA_I2C_MST_STATUS\n */\nbool MPU6050::getSlave2Nack() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_STATUS, MPU6050_MST_I2C_SLV2_NACK_BIT, buffer);\n    return buffer[0];\n}\n/** Get Slave 1 NACK status.\n * This bit automatically sets to 1 when the I2C Master receives a NACK in a\n * transaction with Slave 1. This triggers an interrupt if the I2C_MST_INT_EN\n * bit in the INT_ENABLE register (Register 56) is asserted.\n * @return Slave 1 NACK interrupt status\n * @see MPU6050_RA_I2C_MST_STATUS\n */\nbool MPU6050::getSlave1Nack() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_STATUS, MPU6050_MST_I2C_SLV1_NACK_BIT, buffer);\n    return buffer[0];\n}\n/** Get Slave 0 NACK status.\n * This bit automatically sets to 1 when the I2C Master receives a NACK in a\n * transaction with Slave 0. This triggers an interrupt if the I2C_MST_INT_EN\n * bit in the INT_ENABLE register (Register 56) is asserted.\n * @return Slave 0 NACK interrupt status\n * @see MPU6050_RA_I2C_MST_STATUS\n */\nbool MPU6050::getSlave0Nack() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_STATUS, MPU6050_MST_I2C_SLV0_NACK_BIT, buffer);\n    return buffer[0];\n}\n\n// INT_PIN_CFG register\n\n/** Get interrupt logic level mode.\n * Will be set 0 for active-high, 1 for active-low.\n * @return Current interrupt mode (0=active-high, 1=active-low)\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_INT_LEVEL_BIT\n */\nbool MPU6050::getInterruptMode() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_LEVEL_BIT, buffer);\n    return buffer[0];\n}\n/** Set interrupt logic level mode.\n * @param mode New interrupt mode (0=active-high, 1=active-low)\n * @see getInterruptMode()\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_INT_LEVEL_BIT\n */\nvoid MPU6050::setInterruptMode(bool mode) {\n   I2Cdev::writeBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_LEVEL_BIT, mode);\n}\n/** Get interrupt drive mode.\n * Will be set 0 for push-pull, 1 for open-drain.\n * @return Current interrupt drive mode (0=push-pull, 1=open-drain)\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_INT_OPEN_BIT\n */\nbool MPU6050::getInterruptDrive() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_OPEN_BIT, buffer);\n    return buffer[0];\n}\n/** Set interrupt drive mode.\n * @param drive New interrupt drive mode (0=push-pull, 1=open-drain)\n * @see getInterruptDrive()\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_INT_OPEN_BIT\n */\nvoid MPU6050::setInterruptDrive(bool drive) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_OPEN_BIT, drive);\n}\n/** Get interrupt latch mode.\n * Will be set 0 for 50us-pulse, 1 for latch-until-int-cleared.\n * @return Current latch mode (0=50us-pulse, 1=latch-until-int-cleared)\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_LATCH_INT_EN_BIT\n */\nbool MPU6050::getInterruptLatch() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_LATCH_INT_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set interrupt latch mode.\n * @param latch New latch mode (0=50us-pulse, 1=latch-until-int-cleared)\n * @see getInterruptLatch()\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_LATCH_INT_EN_BIT\n */\nvoid MPU6050::setInterruptLatch(bool latch) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_LATCH_INT_EN_BIT, latch);\n}\n/** Get interrupt latch clear mode.\n * Will be set 0 for status-read-only, 1 for any-register-read.\n * @return Current latch clear mode (0=status-read-only, 1=any-register-read)\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_INT_RD_CLEAR_BIT\n */\nbool MPU6050::getInterruptLatchClear() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_RD_CLEAR_BIT, buffer);\n    return buffer[0];\n}\n/** Set interrupt latch clear mode.\n * @param clear New latch clear mode (0=status-read-only, 1=any-register-read)\n * @see getInterruptLatchClear()\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_INT_RD_CLEAR_BIT\n */\nvoid MPU6050::setInterruptLatchClear(bool clear) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_RD_CLEAR_BIT, clear);\n}\n/** Get FSYNC interrupt logic level mode.\n * @return Current FSYNC interrupt mode (0=active-high, 1=active-low)\n * @see getFSyncInterruptMode()\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT\n */\nbool MPU6050::getFSyncInterruptLevel() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT, buffer);\n    return buffer[0];\n}\n/** Set FSYNC interrupt logic level mode.\n * @param mode New FSYNC interrupt mode (0=active-high, 1=active-low)\n * @see getFSyncInterruptMode()\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT\n */\nvoid MPU6050::setFSyncInterruptLevel(bool level) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT, level);\n}\n/** Get FSYNC pin interrupt enabled setting.\n * Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled setting\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_FSYNC_INT_EN_BIT\n */\nbool MPU6050::getFSyncInterruptEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_FSYNC_INT_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set FSYNC pin interrupt enabled setting.\n * @param enabled New FSYNC pin interrupt enabled setting\n * @see getFSyncInterruptEnabled()\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_FSYNC_INT_EN_BIT\n */\nvoid MPU6050::setFSyncInterruptEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_FSYNC_INT_EN_BIT, enabled);\n}\n/** Get I2C bypass enabled status.\n * When this bit is equal to 1 and I2C_MST_EN (Register 106 bit[5]) is equal to\n * 0, the host application processor will be able to directly access the\n * auxiliary I2C bus of the MPU-60X0. When this bit is equal to 0, the host\n * application processor will not be able to directly access the auxiliary I2C\n * bus of the MPU-60X0 regardless of the state of I2C_MST_EN (Register 106\n * bit[5]).\n * @return Current I2C bypass enabled status\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_I2C_BYPASS_EN_BIT\n */\nbool MPU6050::getI2CBypassEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_I2C_BYPASS_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set I2C bypass enabled status.\n * When this bit is equal to 1 and I2C_MST_EN (Register 106 bit[5]) is equal to\n * 0, the host application processor will be able to directly access the\n * auxiliary I2C bus of the MPU-60X0. When this bit is equal to 0, the host\n * application processor will not be able to directly access the auxiliary I2C\n * bus of the MPU-60X0 regardless of the state of I2C_MST_EN (Register 106\n * bit[5]).\n * @param enabled New I2C bypass enabled status\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_I2C_BYPASS_EN_BIT\n */\nvoid MPU6050::setI2CBypassEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_I2C_BYPASS_EN_BIT, enabled);\n}\n/** Get reference clock output enabled status.\n * When this bit is equal to 1, a reference clock output is provided at the\n * CLKOUT pin. When this bit is equal to 0, the clock output is disabled. For\n * further information regarding CLKOUT, please refer to the MPU-60X0 Product\n * Specification document.\n * @return Current reference clock output enabled status\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_CLKOUT_EN_BIT\n */\nbool MPU6050::getClockOutputEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_CLKOUT_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set reference clock output enabled status.\n * When this bit is equal to 1, a reference clock output is provided at the\n * CLKOUT pin. When this bit is equal to 0, the clock output is disabled. For\n * further information regarding CLKOUT, please refer to the MPU-60X0 Product\n * Specification document.\n * @param enabled New reference clock output enabled status\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_CLKOUT_EN_BIT\n */\nvoid MPU6050::setClockOutputEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_CLKOUT_EN_BIT, enabled);\n}\n\n// INT_ENABLE register\n\n/** Get full interrupt enabled status.\n * Full register byte for all interrupts, for quick reading. Each bit will be\n * set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see MPU6050_RA_INT_ENABLE\n * @see MPU6050_INTERRUPT_FF_BIT\n **/\nuint8_t MPU6050::getIntEnabled() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_INT_ENABLE, buffer);\n    return buffer[0];\n}\n/** Set full interrupt enabled status.\n * Full register byte for all interrupts, for quick reading. Each bit should be\n * set 0 for disabled, 1 for enabled.\n * @param enabled New interrupt enabled status\n * @see getIntFreefallEnabled()\n * @see MPU6050_RA_INT_ENABLE\n * @see MPU6050_INTERRUPT_FF_BIT\n **/\nvoid MPU6050::setIntEnabled(uint8_t enabled) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_INT_ENABLE, enabled);\n}\n/** Get Free Fall interrupt enabled status.\n * Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see MPU6050_RA_INT_ENABLE\n * @see MPU6050_INTERRUPT_FF_BIT\n **/\nbool MPU6050::getIntFreefallEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_FF_BIT, buffer);\n    return buffer[0];\n}\n/** Set Free Fall interrupt enabled status.\n * @param enabled New interrupt enabled status\n * @see getIntFreefallEnabled()\n * @see MPU6050_RA_INT_ENABLE\n * @see MPU6050_INTERRUPT_FF_BIT\n **/\nvoid MPU6050::setIntFreefallEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_FF_BIT, enabled);\n}\n/** Get Motion Detection interrupt enabled status.\n * Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see MPU6050_RA_INT_ENABLE\n * @see MPU6050_INTERRUPT_MOT_BIT\n **/\nbool MPU6050::getIntMotionEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_MOT_BIT, buffer);\n    return buffer[0];\n}\n/** Set Motion Detection interrupt enabled status.\n * @param enabled New interrupt enabled status\n * @see getIntMotionEnabled()\n * @see MPU6050_RA_INT_ENABLE\n * @see MPU6050_INTERRUPT_MOT_BIT\n **/\nvoid MPU6050::setIntMotionEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_MOT_BIT, enabled);\n}\n/** Get Zero Motion Detection interrupt enabled status.\n * Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see MPU6050_RA_INT_ENABLE\n * @see MPU6050_INTERRUPT_ZMOT_BIT\n **/\nbool MPU6050::getIntZeroMotionEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_ZMOT_BIT, buffer);\n    return buffer[0];\n}\n/** Set Zero Motion Detection interrupt enabled status.\n * @param enabled New interrupt enabled status\n * @see getIntZeroMotionEnabled()\n * @see MPU6050_RA_INT_ENABLE\n * @see MPU6050_INTERRUPT_ZMOT_BIT\n **/\nvoid MPU6050::setIntZeroMotionEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_ZMOT_BIT, enabled);\n}\n/** Get FIFO Buffer Overflow interrupt enabled status.\n * Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see MPU6050_RA_INT_ENABLE\n * @see MPU6050_INTERRUPT_FIFO_OFLOW_BIT\n **/\nbool MPU6050::getIntFIFOBufferOverflowEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_FIFO_OFLOW_BIT, buffer);\n    return buffer[0];\n}\n/** Set FIFO Buffer Overflow interrupt enabled status.\n * @param enabled New interrupt enabled status\n * @see getIntFIFOBufferOverflowEnabled()\n * @see MPU6050_RA_INT_ENABLE\n * @see MPU6050_INTERRUPT_FIFO_OFLOW_BIT\n **/\nvoid MPU6050::setIntFIFOBufferOverflowEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_FIFO_OFLOW_BIT, enabled);\n}\n/** Get I2C Master interrupt enabled status.\n * This enables any of the I2C Master interrupt sources to generate an\n * interrupt. Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see MPU6050_RA_INT_ENABLE\n * @see MPU6050_INTERRUPT_I2C_MST_INT_BIT\n **/\nbool MPU6050::getIntI2CMasterEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_I2C_MST_INT_BIT, buffer);\n    return buffer[0];\n}\n/** Set I2C Master interrupt enabled status.\n * @param enabled New interrupt enabled status\n * @see getIntI2CMasterEnabled()\n * @see MPU6050_RA_INT_ENABLE\n * @see MPU6050_INTERRUPT_I2C_MST_INT_BIT\n **/\nvoid MPU6050::setIntI2CMasterEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_I2C_MST_INT_BIT, enabled);\n}\n/** Get Data Ready interrupt enabled setting.\n * This event occurs each time a write operation to all of the sensor registers\n * has been completed. Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see MPU6050_RA_INT_ENABLE\n * @see MPU6050_INTERRUPT_DATA_RDY_BIT\n */\nbool MPU6050::getIntDataReadyEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_DATA_RDY_BIT, buffer);\n    return buffer[0];\n}\n/** Set Data Ready interrupt enabled status.\n * @param enabled New interrupt enabled status\n * @see getIntDataReadyEnabled()\n * @see MPU6050_RA_INT_CFG\n * @see MPU6050_INTERRUPT_DATA_RDY_BIT\n */\nvoid MPU6050::setIntDataReadyEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_DATA_RDY_BIT, enabled);\n}\n\n// INT_STATUS register\n\n/** Get full set of interrupt status bits.\n * These bits clear to 0 after the register has been read. Very useful\n * for getting multiple INT statuses, since each single bit read clears\n * all of them because it has to read the whole byte.\n * @return Current interrupt status\n * @see MPU6050_RA_INT_STATUS\n */\nuint8_t MPU6050::getIntStatus() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_INT_STATUS, buffer);\n    return buffer[0];\n}\n/** Get Free Fall interrupt status.\n * This bit automatically sets to 1 when a Free Fall interrupt has been\n * generated. The bit clears to 0 after the register has been read.\n * @return Current interrupt status\n * @see MPU6050_RA_INT_STATUS\n * @see MPU6050_INTERRUPT_FF_BIT\n */\nbool MPU6050::getIntFreefallStatus() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_STATUS, MPU6050_INTERRUPT_FF_BIT, buffer);\n    return buffer[0];\n}\n/** Get Motion Detection interrupt status.\n * This bit automatically sets to 1 when a Motion Detection interrupt has been\n * generated. The bit clears to 0 after the register has been read.\n * @return Current interrupt status\n * @see MPU6050_RA_INT_STATUS\n * @see MPU6050_INTERRUPT_MOT_BIT\n */\nbool MPU6050::getIntMotionStatus() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_STATUS, MPU6050_INTERRUPT_MOT_BIT, buffer);\n    return buffer[0];\n}\n/** Get Zero Motion Detection interrupt status.\n * This bit automatically sets to 1 when a Zero Motion Detection interrupt has\n * been generated. The bit clears to 0 after the register has been read.\n * @return Current interrupt status\n * @see MPU6050_RA_INT_STATUS\n * @see MPU6050_INTERRUPT_ZMOT_BIT\n */\nbool MPU6050::getIntZeroMotionStatus() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_STATUS, MPU6050_INTERRUPT_ZMOT_BIT, buffer);\n    return buffer[0];\n}\n/** Get FIFO Buffer Overflow interrupt status.\n * This bit automatically sets to 1 when a Free Fall interrupt has been\n * generated. The bit clears to 0 after the register has been read.\n * @return Current interrupt status\n * @see MPU6050_RA_INT_STATUS\n * @see MPU6050_INTERRUPT_FIFO_OFLOW_BIT\n */\nbool MPU6050::getIntFIFOBufferOverflowStatus() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_STATUS, MPU6050_INTERRUPT_FIFO_OFLOW_BIT, buffer);\n    return buffer[0];\n}\n/** Get I2C Master interrupt status.\n * This bit automatically sets to 1 when an I2C Master interrupt has been\n * generated. For a list of I2C Master interrupts, please refer to Register 54.\n * The bit clears to 0 after the register has been read.\n * @return Current interrupt status\n * @see MPU6050_RA_INT_STATUS\n * @see MPU6050_INTERRUPT_I2C_MST_INT_BIT\n */\nbool MPU6050::getIntI2CMasterStatus() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_STATUS, MPU6050_INTERRUPT_I2C_MST_INT_BIT, buffer);\n    return buffer[0];\n}\n/** Get Data Ready interrupt status.\n * This bit automatically sets to 1 when a Data Ready interrupt has been\n * generated. The bit clears to 0 after the register has been read.\n * @return Current interrupt status\n * @see MPU6050_RA_INT_STATUS\n * @see MPU6050_INTERRUPT_DATA_RDY_BIT\n */\nbool MPU6050::getIntDataReadyStatus() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_STATUS, MPU6050_INTERRUPT_DATA_RDY_BIT, buffer);\n    return buffer[0];\n}\n\n// ACCEL_*OUT_* registers\n\n/** Get raw 9-axis motion sensor readings (accel/gyro/compass).\n * FUNCTION NOT FULLY IMPLEMENTED YET.\n * @param ax 16-bit signed integer container for accelerometer X-axis value\n * @param ay 16-bit signed integer container for accelerometer Y-axis value\n * @param az 16-bit signed integer container for accelerometer Z-axis value\n * @param gx 16-bit signed integer container for gyroscope X-axis value\n * @param gy 16-bit signed integer container for gyroscope Y-axis value\n * @param gz 16-bit signed integer container for gyroscope Z-axis value\n * @param mx 16-bit signed integer container for magnetometer X-axis value\n * @param my 16-bit signed integer container for magnetometer Y-axis value\n * @param mz 16-bit signed integer container for magnetometer Z-axis value\n * @see getMotion6()\n * @see getAcceleration()\n * @see getRotation()\n * @see MPU6050_RA_ACCEL_XOUT_H\n */\nvoid MPU6050::getMotion9(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz, int16_t* mx, int16_t* my, int16_t* mz) {\n    getMotion6(ax, ay, az, gx, gy, gz);\n    // TODO: magnetometer integration\n}\n/** Get raw 6-axis motion sensor readings (accel/gyro).\n * Retrieves all currently available motion sensor values.\n * @param ax 16-bit signed integer container for accelerometer X-axis value\n * @param ay 16-bit signed integer container for accelerometer Y-axis value\n * @param az 16-bit signed integer container for accelerometer Z-axis value\n * @param gx 16-bit signed integer container for gyroscope X-axis value\n * @param gy 16-bit signed integer container for gyroscope Y-axis value\n * @param gz 16-bit signed integer container for gyroscope Z-axis value\n * @see getAcceleration()\n * @see getRotation()\n * @see MPU6050_RA_ACCEL_XOUT_H\n */\nvoid MPU6050::getMotion6(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz) {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_ACCEL_XOUT_H, 14, buffer);\n    *ax = (((int16_t)buffer[0]) << 8) | buffer[1];\n    *ay = (((int16_t)buffer[2]) << 8) | buffer[3];\n    *az = (((int16_t)buffer[4]) << 8) | buffer[5];\n    *gx = (((int16_t)buffer[8]) << 8) | buffer[9];\n    *gy = (((int16_t)buffer[10]) << 8) | buffer[11];\n    *gz = (((int16_t)buffer[12]) << 8) | buffer[13];\n}\n/** Get 3-axis accelerometer readings.\n * These registers store the most recent accelerometer measurements.\n * Accelerometer measurements are written to these registers at the Sample Rate\n * as defined in Register 25.\n *\n * The accelerometer measurement registers, along with the temperature\n * measurement registers, gyroscope measurement registers, and external sensor\n * data registers, are composed of two sets of registers: an internal register\n * set and a user-facing read register set.\n *\n * The data within the accelerometer sensors' internal register set is always\n * updated at the Sample Rate. Meanwhile, the user-facing read register set\n * duplicates the internal register set's data values whenever the serial\n * interface is idle. This guarantees that a burst read of sensor registers will\n * read measurements from the same sampling instant. Note that if burst reads\n * are not used, the user is responsible for ensuring a set of single byte reads\n * correspond to a single sampling instant by checking the Data Ready interrupt.\n *\n * Each 16-bit accelerometer measurement has a full scale defined in ACCEL_FS\n * (Register 28). For each full scale setting, the accelerometers' sensitivity\n * per LSB in ACCEL_xOUT is shown in the table below:\n *\n * <pre>\n * AFS_SEL | Full Scale Range | LSB Sensitivity\n * --------+------------------+----------------\n * 0       | +/- 2g           | 8192 LSB/mg\n * 1       | +/- 4g           | 4096 LSB/mg\n * 2       | +/- 8g           | 2048 LSB/mg\n * 3       | +/- 16g          | 1024 LSB/mg\n * </pre>\n *\n * @param x 16-bit signed integer container for X-axis acceleration\n * @param y 16-bit signed integer container for Y-axis acceleration\n * @param z 16-bit signed integer container for Z-axis acceleration\n * @see MPU6050_RA_GYRO_XOUT_H\n */\nvoid MPU6050::getAcceleration(int16_t* x, int16_t* y, int16_t* z) {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_ACCEL_XOUT_H, 6, buffer);\n    *x = (((int16_t)buffer[0]) << 8) | buffer[1];\n    *y = (((int16_t)buffer[2]) << 8) | buffer[3];\n    *z = (((int16_t)buffer[4]) << 8) | buffer[5];\n}\n/** Get X-axis accelerometer reading.\n * @return X-axis acceleration measurement in 16-bit 2's complement format\n * @see getMotion6()\n * @see MPU6050_RA_ACCEL_XOUT_H\n */\nint16_t MPU6050::getAccelerationX() {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_ACCEL_XOUT_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\n/** Get Y-axis accelerometer reading.\n * @return Y-axis acceleration measurement in 16-bit 2's complement format\n * @see getMotion6()\n * @see MPU6050_RA_ACCEL_YOUT_H\n */\nint16_t MPU6050::getAccelerationY() {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_ACCEL_YOUT_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\n/** Get Z-axis accelerometer reading.\n * @return Z-axis acceleration measurement in 16-bit 2's complement format\n * @see getMotion6()\n * @see MPU6050_RA_ACCEL_ZOUT_H\n */\nint16_t MPU6050::getAccelerationZ() {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_ACCEL_ZOUT_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\n\n// TEMP_OUT_* registers\n\n/** Get current internal temperature.\n * @return Temperature reading in 16-bit 2's complement format\n * @see MPU6050_RA_TEMP_OUT_H\n */\nint16_t MPU6050::getTemperature() {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_TEMP_OUT_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\n\n// GYRO_*OUT_* registers\n\n/** Get 3-axis gyroscope readings.\n * These gyroscope measurement registers, along with the accelerometer\n * measurement registers, temperature measurement registers, and external sensor\n * data registers, are composed of two sets of registers: an internal register\n * set and a user-facing read register set.\n * The data within the gyroscope sensors' internal register set is always\n * updated at the Sample Rate. Meanwhile, the user-facing read register set\n * duplicates the internal register set's data values whenever the serial\n * interface is idle. This guarantees that a burst read of sensor registers will\n * read measurements from the same sampling instant. Note that if burst reads\n * are not used, the user is responsible for ensuring a set of single byte reads\n * correspond to a single sampling instant by checking the Data Ready interrupt.\n *\n * Each 16-bit gyroscope measurement has a full scale defined in FS_SEL\n * (Register 27). For each full scale setting, the gyroscopes' sensitivity per\n * LSB in GYRO_xOUT is shown in the table below:\n *\n * <pre>\n * FS_SEL | Full Scale Range   | LSB Sensitivity\n * -------+--------------------+----------------\n * 0      | +/- 250 degrees/s  | 131 LSB/deg/s\n * 1      | +/- 500 degrees/s  | 65.5 LSB/deg/s\n * 2      | +/- 1000 degrees/s | 32.8 LSB/deg/s\n * 3      | +/- 2000 degrees/s | 16.4 LSB/deg/s\n * </pre>\n *\n * @param x 16-bit signed integer container for X-axis rotation\n * @param y 16-bit signed integer container for Y-axis rotation\n * @param z 16-bit signed integer container for Z-axis rotation\n * @see getMotion6()\n * @see MPU6050_RA_GYRO_XOUT_H\n */\nvoid MPU6050::getRotation(int16_t* x, int16_t* y, int16_t* z) {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_GYRO_XOUT_H, 6, buffer);\n    *x = (((int16_t)buffer[0]) << 8) | buffer[1];\n    *y = (((int16_t)buffer[2]) << 8) | buffer[3];\n    *z = (((int16_t)buffer[4]) << 8) | buffer[5];\n}\n/** Get X-axis gyroscope reading.\n * @return X-axis rotation measurement in 16-bit 2's complement format\n * @see getMotion6()\n * @see MPU6050_RA_GYRO_XOUT_H\n */\nint16_t MPU6050::getRotationX() {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_GYRO_XOUT_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\n/** Get Y-axis gyroscope reading.\n * @return Y-axis rotation measurement in 16-bit 2's complement format\n * @see getMotion6()\n * @see MPU6050_RA_GYRO_YOUT_H\n */\nint16_t MPU6050::getRotationY() {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_GYRO_YOUT_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\n/** Get Z-axis gyroscope reading.\n * @return Z-axis rotation measurement in 16-bit 2's complement format\n * @see getMotion6()\n * @see MPU6050_RA_GYRO_ZOUT_H\n */\nint16_t MPU6050::getRotationZ() {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_GYRO_ZOUT_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\n\n// EXT_SENS_DATA_* registers\n\n/** Read single byte from external sensor data register.\n * These registers store data read from external sensors by the Slave 0, 1, 2,\n * and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in\n * I2C_SLV4_DI (Register 53).\n *\n * External sensor data is written to these registers at the Sample Rate as\n * defined in Register 25. This access rate can be reduced by using the Slave\n * Delay Enable registers (Register 103).\n *\n * External sensor data registers, along with the gyroscope measurement\n * registers, accelerometer measurement registers, and temperature measurement\n * registers, are composed of two sets of registers: an internal register set\n * and a user-facing read register set.\n *\n * The data within the external sensors' internal register set is always updated\n * at the Sample Rate (or the reduced access rate) whenever the serial interface\n * is idle. This guarantees that a burst read of sensor registers will read\n * measurements from the same sampling instant. Note that if burst reads are not\n * used, the user is responsible for ensuring a set of single byte reads\n * correspond to a single sampling instant by checking the Data Ready interrupt.\n *\n * Data is placed in these external sensor data registers according to\n * I2C_SLV0_CTRL, I2C_SLV1_CTRL, I2C_SLV2_CTRL, and I2C_SLV3_CTRL (Registers 39,\n * 42, 45, and 48). When more than zero bytes are read (I2C_SLVx_LEN > 0) from\n * an enabled slave (I2C_SLVx_EN = 1), the slave is read at the Sample Rate (as\n * defined in Register 25) or delayed rate (if specified in Register 52 and\n * 103). During each Sample cycle, slave reads are performed in order of Slave\n * number. If all slaves are enabled with more than zero bytes to be read, the\n * order will be Slave 0, followed by Slave 1, Slave 2, and Slave 3.\n *\n * Each enabled slave will have EXT_SENS_DATA registers associated with it by\n * number of bytes read (I2C_SLVx_LEN) in order of slave number, starting from\n * EXT_SENS_DATA_00. Note that this means enabling or disabling a slave may\n * change the higher numbered slaves' associated registers. Furthermore, if\n * fewer total bytes are being read from the external sensors as a result of\n * such a change, then the data remaining in the registers which no longer have\n * an associated slave device (i.e. high numbered registers) will remain in\n * these previously allocated registers unless reset.\n *\n * If the sum of the read lengths of all SLVx transactions exceed the number of\n * available EXT_SENS_DATA registers, the excess bytes will be dropped. There\n * are 24 EXT_SENS_DATA registers and hence the total read lengths between all\n * the slaves cannot be greater than 24 or some bytes will be lost.\n *\n * Note: Slave 4's behavior is distinct from that of Slaves 0-3. For further\n * information regarding the characteristics of Slave 4, please refer to\n * Registers 49 to 53.\n *\n * EXAMPLE:\n * Suppose that Slave 0 is enabled with 4 bytes to be read (I2C_SLV0_EN = 1 and\n * I2C_SLV0_LEN = 4) while Slave 1 is enabled with 2 bytes to be read so that\n * I2C_SLV1_EN = 1 and I2C_SLV1_LEN = 2. In such a situation, EXT_SENS_DATA _00\n * through _03 will be associated with Slave 0, while EXT_SENS_DATA _04 and 05\n * will be associated with Slave 1. If Slave 2 is enabled as well, registers\n * starting from EXT_SENS_DATA_06 will be allocated to Slave 2.\n *\n * If Slave 2 is disabled while Slave 3 is enabled in this same situation, then\n * registers starting from EXT_SENS_DATA_06 will be allocated to Slave 3\n * instead.\n *\n * REGISTER ALLOCATION FOR DYNAMIC DISABLE VS. NORMAL DISABLE:\n * If a slave is disabled at any time, the space initially allocated to the\n * slave in the EXT_SENS_DATA register, will remain associated with that slave.\n * This is to avoid dynamic adjustment of the register allocation.\n *\n * The allocation of the EXT_SENS_DATA registers is recomputed only when (1) all\n * slaves are disabled, or (2) the I2C_MST_RST bit is set (Register 106).\n *\n * This above is also true if one of the slaves gets NACKed and stops\n * functioning.\n *\n * @param position Starting position (0-23)\n * @return Byte read from register\n */\nuint8_t MPU6050::getExternalSensorByte(int position) {\n    I2Cdev::readByte(devAddr, MPU6050_RA_EXT_SENS_DATA_00 + position, buffer);\n    return buffer[0];\n}\n/** Read word (2 bytes) from external sensor data registers.\n * @param position Starting position (0-21)\n * @return Word read from register\n * @see getExternalSensorByte()\n */\nuint16_t MPU6050::getExternalSensorWord(int position) {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_EXT_SENS_DATA_00 + position, 2, buffer);\n    return (((uint16_t)buffer[0]) << 8) | buffer[1];\n}\n/** Read double word (4 bytes) from external sensor data registers.\n * @param position Starting position (0-20)\n * @return Double word read from registers\n * @see getExternalSensorByte()\n */\nuint32_t MPU6050::getExternalSensorDWord(int position) {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_EXT_SENS_DATA_00 + position, 4, buffer);\n    return (((uint32_t)buffer[0]) << 24) | (((uint32_t)buffer[1]) << 16) | (((uint16_t)buffer[2]) << 8) | buffer[3];\n}\n\n// MOT_DETECT_STATUS register\n\n/** Get X-axis negative motion detection interrupt status.\n * @return Motion detection status\n * @see MPU6050_RA_MOT_DETECT_STATUS\n * @see MPU6050_MOTION_MOT_XNEG_BIT\n */\nbool MPU6050::getXNegMotionDetected() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_MOT_DETECT_STATUS, MPU6050_MOTION_MOT_XNEG_BIT, buffer);\n    return buffer[0];\n}\n/** Get X-axis positive motion detection interrupt status.\n * @return Motion detection status\n * @see MPU6050_RA_MOT_DETECT_STATUS\n * @see MPU6050_MOTION_MOT_XPOS_BIT\n */\nbool MPU6050::getXPosMotionDetected() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_MOT_DETECT_STATUS, MPU6050_MOTION_MOT_XPOS_BIT, buffer);\n    return buffer[0];\n}\n/** Get Y-axis negative motion detection interrupt status.\n * @return Motion detection status\n * @see MPU6050_RA_MOT_DETECT_STATUS\n * @see MPU6050_MOTION_MOT_YNEG_BIT\n */\nbool MPU6050::getYNegMotionDetected() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_MOT_DETECT_STATUS, MPU6050_MOTION_MOT_YNEG_BIT, buffer);\n    return buffer[0];\n}\n/** Get Y-axis positive motion detection interrupt status.\n * @return Motion detection status\n * @see MPU6050_RA_MOT_DETECT_STATUS\n * @see MPU6050_MOTION_MOT_YPOS_BIT\n */\nbool MPU6050::getYPosMotionDetected() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_MOT_DETECT_STATUS, MPU6050_MOTION_MOT_YPOS_BIT, buffer);\n    return buffer[0];\n}\n/** Get Z-axis negative motion detection interrupt status.\n * @return Motion detection status\n * @see MPU6050_RA_MOT_DETECT_STATUS\n * @see MPU6050_MOTION_MOT_ZNEG_BIT\n */\nbool MPU6050::getZNegMotionDetected() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_MOT_DETECT_STATUS, MPU6050_MOTION_MOT_ZNEG_BIT, buffer);\n    return buffer[0];\n}\n/** Get Z-axis positive motion detection interrupt status.\n * @return Motion detection status\n * @see MPU6050_RA_MOT_DETECT_STATUS\n * @see MPU6050_MOTION_MOT_ZPOS_BIT\n */\nbool MPU6050::getZPosMotionDetected() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_MOT_DETECT_STATUS, MPU6050_MOTION_MOT_ZPOS_BIT, buffer);\n    return buffer[0];\n}\n/** Get zero motion detection interrupt status.\n * @return Motion detection status\n * @see MPU6050_RA_MOT_DETECT_STATUS\n * @see MPU6050_MOTION_MOT_ZRMOT_BIT\n */\nbool MPU6050::getZeroMotionDetected() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_MOT_DETECT_STATUS, MPU6050_MOTION_MOT_ZRMOT_BIT, buffer);\n    return buffer[0];\n}\n\n// I2C_SLV*_DO register\n\n/** Write byte to Data Output container for specified slave.\n * This register holds the output data written into Slave when Slave is set to\n * write mode. For further information regarding Slave control, please\n * refer to Registers 37 to 39 and immediately following.\n * @param num Slave number (0-3)\n * @param data Byte to write\n * @see MPU6050_RA_I2C_SLV0_DO\n */\nvoid MPU6050::setSlaveOutputByte(uint8_t num, uint8_t data) {\n    if (num > 3) return;\n    I2Cdev::writeByte(devAddr, MPU6050_RA_I2C_SLV0_DO + num, data);\n}\n\n// I2C_MST_DELAY_CTRL register\n\n/** Get external data shadow delay enabled status.\n * This register is used to specify the timing of external sensor data\n * shadowing. When DELAY_ES_SHADOW is set to 1, shadowing of external\n * sensor data is delayed until all data has been received.\n * @return Current external data shadow delay enabled status.\n * @see MPU6050_RA_I2C_MST_DELAY_CTRL\n * @see MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT\n */\nbool MPU6050::getExternalShadowDelayEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_DELAY_CTRL, MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT, buffer);\n    return buffer[0];\n}\n/** Set external data shadow delay enabled status.\n * @param enabled New external data shadow delay enabled status.\n * @see getExternalShadowDelayEnabled()\n * @see MPU6050_RA_I2C_MST_DELAY_CTRL\n * @see MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT\n */\nvoid MPU6050::setExternalShadowDelayEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_MST_DELAY_CTRL, MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT, enabled);\n}\n/** Get slave delay enabled status.\n * When a particular slave delay is enabled, the rate of access for the that\n * slave device is reduced. When a slave's access rate is decreased relative to\n * the Sample Rate, the slave is accessed every:\n *\n *     1 / (1 + I2C_MST_DLY) Samples\n *\n * This base Sample Rate in turn is determined by SMPLRT_DIV (register  * 25)\n * and DLPF_CFG (register 26).\n *\n * For further information regarding I2C_MST_DLY, please refer to register 52.\n * For further information regarding the Sample Rate, please refer to register 25.\n *\n * @param num Slave number (0-4)\n * @return Current slave delay enabled status.\n * @see MPU6050_RA_I2C_MST_DELAY_CTRL\n * @see MPU6050_DELAYCTRL_I2C_SLV0_DLY_EN_BIT\n */\nbool MPU6050::getSlaveDelayEnabled(uint8_t num) {\n    // MPU6050_DELAYCTRL_I2C_SLV4_DLY_EN_BIT is 4, SLV3 is 3, etc.\n    if (num > 4) return 0;\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_DELAY_CTRL, num, buffer);\n    return buffer[0];\n}\n/** Set slave delay enabled status.\n * @param num Slave number (0-4)\n * @param enabled New slave delay enabled status.\n * @see MPU6050_RA_I2C_MST_DELAY_CTRL\n * @see MPU6050_DELAYCTRL_I2C_SLV0_DLY_EN_BIT\n */\nvoid MPU6050::setSlaveDelayEnabled(uint8_t num, bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_MST_DELAY_CTRL, num, enabled);\n}\n\n// SIGNAL_PATH_RESET register\n\n/** Reset gyroscope signal path.\n * The reset will revert the signal path analog to digital converters and\n * filters to their power up configurations.\n * @see MPU6050_RA_SIGNAL_PATH_RESET\n * @see MPU6050_PATHRESET_GYRO_RESET_BIT\n */\nvoid MPU6050::resetGyroscopePath() {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_SIGNAL_PATH_RESET, MPU6050_PATHRESET_GYRO_RESET_BIT, true);\n}\n/** Reset accelerometer signal path.\n * The reset will revert the signal path analog to digital converters and\n * filters to their power up configurations.\n * @see MPU6050_RA_SIGNAL_PATH_RESET\n * @see MPU6050_PATHRESET_ACCEL_RESET_BIT\n */\nvoid MPU6050::resetAccelerometerPath() {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_SIGNAL_PATH_RESET, MPU6050_PATHRESET_ACCEL_RESET_BIT, true);\n}\n/** Reset temperature sensor signal path.\n * The reset will revert the signal path analog to digital converters and\n * filters to their power up configurations.\n * @see MPU6050_RA_SIGNAL_PATH_RESET\n * @see MPU6050_PATHRESET_TEMP_RESET_BIT\n */\nvoid MPU6050::resetTemperaturePath() {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_SIGNAL_PATH_RESET, MPU6050_PATHRESET_TEMP_RESET_BIT, true);\n}\n\n// MOT_DETECT_CTRL register\n\n/** Get accelerometer power-on delay.\n * The accelerometer data path provides samples to the sensor registers, Motion\n * detection, Zero Motion detection, and Free Fall detection modules. The\n * signal path contains filters which must be flushed on wake-up with new\n * samples before the detection modules begin operations. The default wake-up\n * delay, of 4ms can be lengthened by up to 3ms. This additional delay is\n * specified in ACCEL_ON_DELAY in units of 1 LSB = 1 ms. The user may select\n * any value above zero unless instructed otherwise by InvenSense. Please refer\n * to Section 8 of the MPU-6000/MPU-6050 Product Specification document for\n * further information regarding the detection modules.\n * @return Current accelerometer power-on delay\n * @see MPU6050_RA_MOT_DETECT_CTRL\n * @see MPU6050_DETECT_ACCEL_ON_DELAY_BIT\n */\nuint8_t MPU6050::getAccelerometerPowerOnDelay() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_MOT_DETECT_CTRL, MPU6050_DETECT_ACCEL_ON_DELAY_BIT, MPU6050_DETECT_ACCEL_ON_DELAY_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set accelerometer power-on delay.\n * @param delay New accelerometer power-on delay (0-3)\n * @see getAccelerometerPowerOnDelay()\n * @see MPU6050_RA_MOT_DETECT_CTRL\n * @see MPU6050_DETECT_ACCEL_ON_DELAY_BIT\n */\nvoid MPU6050::setAccelerometerPowerOnDelay(uint8_t delay) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_MOT_DETECT_CTRL, MPU6050_DETECT_ACCEL_ON_DELAY_BIT, MPU6050_DETECT_ACCEL_ON_DELAY_LENGTH, delay);\n}\n/** Get Free Fall detection counter decrement configuration.\n * Detection is registered by the Free Fall detection module after accelerometer\n * measurements meet their respective threshold conditions over a specified\n * number of samples. When the threshold conditions are met, the corresponding\n * detection counter increments by 1. The user may control the rate at which the\n * detection counter decrements when the threshold condition is not met by\n * configuring FF_COUNT. The decrement rate can be set according to the\n * following table:\n *\n * <pre>\n * FF_COUNT | Counter Decrement\n * ---------+------------------\n * 0        | Reset\n * 1        | 1\n * 2        | 2\n * 3        | 4\n * </pre>\n *\n * When FF_COUNT is configured to 0 (reset), any non-qualifying sample will\n * reset the counter to 0. For further information on Free Fall detection,\n * please refer to Registers 29 to 32.\n *\n * @return Current decrement configuration\n * @see MPU6050_RA_MOT_DETECT_CTRL\n * @see MPU6050_DETECT_FF_COUNT_BIT\n */\nuint8_t MPU6050::getFreefallDetectionCounterDecrement() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_MOT_DETECT_CTRL, MPU6050_DETECT_FF_COUNT_BIT, MPU6050_DETECT_FF_COUNT_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set Free Fall detection counter decrement configuration.\n * @param decrement New decrement configuration value\n * @see getFreefallDetectionCounterDecrement()\n * @see MPU6050_RA_MOT_DETECT_CTRL\n * @see MPU6050_DETECT_FF_COUNT_BIT\n */\nvoid MPU6050::setFreefallDetectionCounterDecrement(uint8_t decrement) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_MOT_DETECT_CTRL, MPU6050_DETECT_FF_COUNT_BIT, MPU6050_DETECT_FF_COUNT_LENGTH, decrement);\n}\n/** Get Motion detection counter decrement configuration.\n * Detection is registered by the Motion detection module after accelerometer\n * measurements meet their respective threshold conditions over a specified\n * number of samples. When the threshold conditions are met, the corresponding\n * detection counter increments by 1. The user may control the rate at which the\n * detection counter decrements when the threshold condition is not met by\n * configuring MOT_COUNT. The decrement rate can be set according to the\n * following table:\n *\n * <pre>\n * MOT_COUNT | Counter Decrement\n * ----------+------------------\n * 0         | Reset\n * 1         | 1\n * 2         | 2\n * 3         | 4\n * </pre>\n *\n * When MOT_COUNT is configured to 0 (reset), any non-qualifying sample will\n * reset the counter to 0. For further information on Motion detection,\n * please refer to Registers 29 to 32.\n *\n */\nuint8_t MPU6050::getMotionDetectionCounterDecrement() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_MOT_DETECT_CTRL, MPU6050_DETECT_MOT_COUNT_BIT, MPU6050_DETECT_MOT_COUNT_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set Motion detection counter decrement configuration.\n * @param decrement New decrement configuration value\n * @see getMotionDetectionCounterDecrement()\n * @see MPU6050_RA_MOT_DETECT_CTRL\n * @see MPU6050_DETECT_MOT_COUNT_BIT\n */\nvoid MPU6050::setMotionDetectionCounterDecrement(uint8_t decrement) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_MOT_DETECT_CTRL, MPU6050_DETECT_MOT_COUNT_BIT, MPU6050_DETECT_MOT_COUNT_LENGTH, decrement);\n}\n\n// USER_CTRL register\n\n/** Get FIFO enabled status.\n * When this bit is set to 0, the FIFO buffer is disabled. The FIFO buffer\n * cannot be written to or read from while disabled. The FIFO buffer's state\n * does not change unless the MPU-60X0 is power cycled.\n * @return Current FIFO enabled status\n * @see MPU6050_RA_USER_CTRL\n * @see MPU6050_USERCTRL_FIFO_EN_BIT\n */\nbool MPU6050::getFIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set FIFO enabled status.\n * @param enabled New FIFO enabled status\n * @see getFIFOEnabled()\n * @see MPU6050_RA_USER_CTRL\n * @see MPU6050_USERCTRL_FIFO_EN_BIT\n */\nvoid MPU6050::setFIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_EN_BIT, enabled);\n}\n/** Get I2C Master Mode enabled status.\n * When this mode is enabled, the MPU-60X0 acts as the I2C Master to the\n * external sensor slave devices on the auxiliary I2C bus. When this bit is\n * cleared to 0, the auxiliary I2C bus lines (AUX_DA and AUX_CL) are logically\n * driven by the primary I2C bus (SDA and SCL). This is a precondition to\n * enabling Bypass Mode. For further information regarding Bypass Mode, please\n * refer to Register 55.\n * @return Current I2C Master Mode enabled status\n * @see MPU6050_RA_USER_CTRL\n * @see MPU6050_USERCTRL_I2C_MST_EN_BIT\n */\nbool MPU6050::getI2CMasterModeEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_I2C_MST_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set I2C Master Mode enabled status.\n * @param enabled New I2C Master Mode enabled status\n * @see getI2CMasterModeEnabled()\n * @see MPU6050_RA_USER_CTRL\n * @see MPU6050_USERCTRL_I2C_MST_EN_BIT\n */\nvoid MPU6050::setI2CMasterModeEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_I2C_MST_EN_BIT, enabled);\n}\n/** Switch from I2C to SPI mode (MPU-6000 only)\n * If this is set, the primary SPI interface will be enabled in place of the\n * disabled primary I2C interface.\n */\nvoid MPU6050::switchSPIEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_I2C_IF_DIS_BIT, enabled);\n}\n/** Reset the FIFO.\n * This bit resets the FIFO buffer when set to 1 while FIFO_EN equals 0. This\n * bit automatically clears to 0 after the reset has been triggered.\n * @see MPU6050_RA_USER_CTRL\n * @see MPU6050_USERCTRL_FIFO_RESET_BIT\n */\nvoid MPU6050::resetFIFO() {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_RESET_BIT, true);\n}\n/** Reset the I2C Master.\n * This bit resets the I2C Master when set to 1 while I2C_MST_EN equals 0.\n * This bit automatically clears to 0 after the reset has been triggered.\n * @see MPU6050_RA_USER_CTRL\n * @see MPU6050_USERCTRL_I2C_MST_RESET_BIT\n */\nvoid MPU6050::resetI2CMaster() {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_I2C_MST_RESET_BIT, true);\n}\n/** Reset all sensor registers and signal paths.\n * When set to 1, this bit resets the signal paths for all sensors (gyroscopes,\n * accelerometers, and temperature sensor). This operation will also clear the\n * sensor registers. This bit automatically clears to 0 after the reset has been\n * triggered.\n *\n * When resetting only the signal path (and not the sensor registers), please\n * use Register 104, SIGNAL_PATH_RESET.\n *\n * @see MPU6050_RA_USER_CTRL\n * @see MPU6050_USERCTRL_SIG_COND_RESET_BIT\n */\nvoid MPU6050::resetSensors() {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_SIG_COND_RESET_BIT, true);\n}\n\n// PWR_MGMT_1 register\n\n/** Trigger a full device reset.\n * A small delay of ~50ms may be desirable after triggering a reset.\n * @see MPU6050_RA_PWR_MGMT_1\n * @see MPU6050_PWR1_DEVICE_RESET_BIT\n */\nvoid MPU6050::reset() {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_DEVICE_RESET_BIT, true);\n}\n/** Get sleep mode status.\n * Setting the SLEEP bit in the register puts the device into very low power\n * sleep mode. In this mode, only the serial interface and internal registers\n * remain active, allowing for a very low standby current. Clearing this bit\n * puts the device back into normal mode. To save power, the individual standby\n * selections for each of the gyros should be used if any gyro axis is not used\n * by the application.\n * @return Current sleep mode enabled status\n * @see MPU6050_RA_PWR_MGMT_1\n * @see MPU6050_PWR1_SLEEP_BIT\n */\nbool MPU6050::getSleepEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, buffer);\n    return buffer[0];\n}\n/** Set sleep mode status.\n * @param enabled New sleep mode enabled status\n * @see getSleepEnabled()\n * @see MPU6050_RA_PWR_MGMT_1\n * @see MPU6050_PWR1_SLEEP_BIT\n */\nvoid MPU6050::setSleepEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, enabled);\n}\n/** Get wake cycle enabled status.\n * When this bit is set to 1 and SLEEP is disabled, the MPU-60X0 will cycle\n * between sleep mode and waking up to take a single sample of data from active\n * sensors at a rate determined by LP_WAKE_CTRL (register 108).\n * @return Current sleep mode enabled status\n * @see MPU6050_RA_PWR_MGMT_1\n * @see MPU6050_PWR1_CYCLE_BIT\n */\nbool MPU6050::getWakeCycleEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CYCLE_BIT, buffer);\n    return buffer[0];\n}\n/** Set wake cycle enabled status.\n * @param enabled New sleep mode enabled status\n * @see getWakeCycleEnabled()\n * @see MPU6050_RA_PWR_MGMT_1\n * @see MPU6050_PWR1_CYCLE_BIT\n */\nvoid MPU6050::setWakeCycleEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CYCLE_BIT, enabled);\n}\n/** Get temperature sensor enabled status.\n * Control the usage of the internal temperature sensor.\n *\n * Note: this register stores the *disabled* value, but for consistency with the\n * rest of the code, the function is named and used with standard true/false\n * values to indicate whether the sensor is enabled or disabled, respectively.\n *\n * @return Current temperature sensor enabled status\n * @see MPU6050_RA_PWR_MGMT_1\n * @see MPU6050_PWR1_TEMP_DIS_BIT\n */\nbool MPU6050::getTempSensorEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_TEMP_DIS_BIT, buffer);\n    return buffer[0] == 0; // 1 is actually disabled here\n}\n/** Set temperature sensor enabled status.\n * Note: this register stores the *disabled* value, but for consistency with the\n * rest of the code, the function is named and used with standard true/false\n * values to indicate whether the sensor is enabled or disabled, respectively.\n *\n * @param enabled New temperature sensor enabled status\n * @see getTempSensorEnabled()\n * @see MPU6050_RA_PWR_MGMT_1\n * @see MPU6050_PWR1_TEMP_DIS_BIT\n */\nvoid MPU6050::setTempSensorEnabled(bool enabled) {\n    // 1 is actually disabled here\n    I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_TEMP_DIS_BIT, !enabled);\n}\n/** Get clock source setting.\n * @return Current clock source setting\n * @see MPU6050_RA_PWR_MGMT_1\n * @see MPU6050_PWR1_CLKSEL_BIT\n * @see MPU6050_PWR1_CLKSEL_LENGTH\n */\nuint8_t MPU6050::getClockSource() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CLKSEL_BIT, MPU6050_PWR1_CLKSEL_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set clock source setting.\n * An internal 8MHz oscillator, gyroscope based clock, or external sources can\n * be selected as the MPU-60X0 clock source. When the internal 8 MHz oscillator\n * or an external source is chosen as the clock source, the MPU-60X0 can operate\n * in low power modes with the gyroscopes disabled.\n *\n * Upon power up, the MPU-60X0 clock source defaults to the internal oscillator.\n * However, it is highly recommended that the device be configured to use one of\n * the gyroscopes (or an external clock source) as the clock reference for\n * improved stability. The clock source can be selected according to the following table:\n *\n * <pre>\n * CLK_SEL | Clock Source\n * --------+--------------------------------------\n * 0       | Internal oscillator\n * 1       | PLL with X Gyro reference\n * 2       | PLL with Y Gyro reference\n * 3       | PLL with Z Gyro reference\n * 4       | PLL with external 32.768kHz reference\n * 5       | PLL with external 19.2MHz reference\n * 6       | Reserved\n * 7       | Stops the clock and keeps the timing generator in reset\n * </pre>\n *\n * @param source New clock source setting\n * @see getClockSource()\n * @see MPU6050_RA_PWR_MGMT_1\n * @see MPU6050_PWR1_CLKSEL_BIT\n * @see MPU6050_PWR1_CLKSEL_LENGTH\n */\nvoid MPU6050::setClockSource(uint8_t source) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CLKSEL_BIT, MPU6050_PWR1_CLKSEL_LENGTH, source);\n}\n\n// PWR_MGMT_2 register\n\n/** Get wake frequency in Accel-Only Low Power Mode.\n * The MPU-60X0 can be put into Accerlerometer Only Low Power Mode by setting\n * PWRSEL to 1 in the Power Management 1 register (Register 107). In this mode,\n * the device will power off all devices except for the primary I2C interface,\n * waking only the accelerometer at fixed intervals to take a single\n * measurement. The frequency of wake-ups can be configured with LP_WAKE_CTRL\n * as shown below:\n *\n * <pre>\n * LP_WAKE_CTRL | Wake-up Frequency\n * -------------+------------------\n * 0            | 1.25 Hz\n * 1            | 2.5 Hz\n * 2            | 5 Hz\n * 3            | 10 Hz\n * <pre>\n *\n * For further information regarding the MPU-60X0's power modes, please refer to\n * Register 107.\n *\n * @return Current wake frequency\n * @see MPU6050_RA_PWR_MGMT_2\n */\nuint8_t MPU6050::getWakeFrequency() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_LP_WAKE_CTRL_BIT, MPU6050_PWR2_LP_WAKE_CTRL_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set wake frequency in Accel-Only Low Power Mode.\n * @param frequency New wake frequency\n * @see MPU6050_RA_PWR_MGMT_2\n */\nvoid MPU6050::setWakeFrequency(uint8_t frequency) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_LP_WAKE_CTRL_BIT, MPU6050_PWR2_LP_WAKE_CTRL_LENGTH, frequency);\n}\n\n/** Get X-axis accelerometer standby enabled status.\n * If enabled, the X-axis will not gather or report data (or use power).\n * @return Current X-axis standby enabled status\n * @see MPU6050_RA_PWR_MGMT_2\n * @see MPU6050_PWR2_STBY_XA_BIT\n */\nbool MPU6050::getStandbyXAccelEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_XA_BIT, buffer);\n    return buffer[0];\n}\n/** Set X-axis accelerometer standby enabled status.\n * @param New X-axis standby enabled status\n * @see getStandbyXAccelEnabled()\n * @see MPU6050_RA_PWR_MGMT_2\n * @see MPU6050_PWR2_STBY_XA_BIT\n */\nvoid MPU6050::setStandbyXAccelEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_XA_BIT, enabled);\n}\n/** Get Y-axis accelerometer standby enabled status.\n * If enabled, the Y-axis will not gather or report data (or use power).\n * @return Current Y-axis standby enabled status\n * @see MPU6050_RA_PWR_MGMT_2\n * @see MPU6050_PWR2_STBY_YA_BIT\n */\nbool MPU6050::getStandbyYAccelEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_YA_BIT, buffer);\n    return buffer[0];\n}\n/** Set Y-axis accelerometer standby enabled status.\n * @param New Y-axis standby enabled status\n * @see getStandbyYAccelEnabled()\n * @see MPU6050_RA_PWR_MGMT_2\n * @see MPU6050_PWR2_STBY_YA_BIT\n */\nvoid MPU6050::setStandbyYAccelEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_YA_BIT, enabled);\n}\n/** Get Z-axis accelerometer standby enabled status.\n * If enabled, the Z-axis will not gather or report data (or use power).\n * @return Current Z-axis standby enabled status\n * @see MPU6050_RA_PWR_MGMT_2\n * @see MPU6050_PWR2_STBY_ZA_BIT\n */\nbool MPU6050::getStandbyZAccelEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_ZA_BIT, buffer);\n    return buffer[0];\n}\n/** Set Z-axis accelerometer standby enabled status.\n * @param New Z-axis standby enabled status\n * @see getStandbyZAccelEnabled()\n * @see MPU6050_RA_PWR_MGMT_2\n * @see MPU6050_PWR2_STBY_ZA_BIT\n */\nvoid MPU6050::setStandbyZAccelEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_ZA_BIT, enabled);\n}\n/** Get X-axis gyroscope standby enabled status.\n * If enabled, the X-axis will not gather or report data (or use power).\n * @return Current X-axis standby enabled status\n * @see MPU6050_RA_PWR_MGMT_2\n * @see MPU6050_PWR2_STBY_XG_BIT\n */\nbool MPU6050::getStandbyXGyroEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_XG_BIT, buffer);\n    return buffer[0];\n}\n/** Set X-axis gyroscope standby enabled status.\n * @param New X-axis standby enabled status\n * @see getStandbyXGyroEnabled()\n * @see MPU6050_RA_PWR_MGMT_2\n * @see MPU6050_PWR2_STBY_XG_BIT\n */\nvoid MPU6050::setStandbyXGyroEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_XG_BIT, enabled);\n}\n/** Get Y-axis gyroscope standby enabled status.\n * If enabled, the Y-axis will not gather or report data (or use power).\n * @return Current Y-axis standby enabled status\n * @see MPU6050_RA_PWR_MGMT_2\n * @see MPU6050_PWR2_STBY_YG_BIT\n */\nbool MPU6050::getStandbyYGyroEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_YG_BIT, buffer);\n    return buffer[0];\n}\n/** Set Y-axis gyroscope standby enabled status.\n * @param New Y-axis standby enabled status\n * @see getStandbyYGyroEnabled()\n * @see MPU6050_RA_PWR_MGMT_2\n * @see MPU6050_PWR2_STBY_YG_BIT\n */\nvoid MPU6050::setStandbyYGyroEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_YG_BIT, enabled);\n}\n/** Get Z-axis gyroscope standby enabled status.\n * If enabled, the Z-axis will not gather or report data (or use power).\n * @return Current Z-axis standby enabled status\n * @see MPU6050_RA_PWR_MGMT_2\n * @see MPU6050_PWR2_STBY_ZG_BIT\n */\nbool MPU6050::getStandbyZGyroEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_ZG_BIT, buffer);\n    return buffer[0];\n}\n/** Set Z-axis gyroscope standby enabled status.\n * @param New Z-axis standby enabled status\n * @see getStandbyZGyroEnabled()\n * @see MPU6050_RA_PWR_MGMT_2\n * @see MPU6050_PWR2_STBY_ZG_BIT\n */\nvoid MPU6050::setStandbyZGyroEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_ZG_BIT, enabled);\n}\n\n// FIFO_COUNT* registers\n\n/** Get current FIFO buffer size.\n * This value indicates the number of bytes stored in the FIFO buffer. This\n * number is in turn the number of bytes that can be read from the FIFO buffer\n * and it is directly proportional to the number of samples available given the\n * set of sensor data bound to be stored in the FIFO (register 35 and 36).\n * @return Current FIFO buffer size\n */\nuint16_t MPU6050::getFIFOCount() {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_FIFO_COUNTH, 2, buffer);\n    return (((uint16_t)buffer[0]) << 8) | buffer[1];\n}\n\n// FIFO_R_W register\n\n/** Get byte from FIFO buffer.\n * This register is used to read and write data from the FIFO buffer. Data is\n * written to the FIFO in order of register number (from lowest to highest). If\n * all the FIFO enable flags (see below) are enabled and all External Sensor\n * Data registers (Registers 73 to 96) are associated with a Slave device, the\n * contents of registers 59 through 96 will be written in order at the Sample\n * Rate.\n *\n * The contents of the sensor data registers (Registers 59 to 96) are written\n * into the FIFO buffer when their corresponding FIFO enable flags are set to 1\n * in FIFO_EN (Register 35). An additional flag for the sensor data registers\n * associated with I2C Slave 3 can be found in I2C_MST_CTRL (Register 36).\n *\n * If the FIFO buffer has overflowed, the status bit FIFO_OFLOW_INT is\n * automatically set to 1. This bit is located in INT_STATUS (Register 58).\n * When the FIFO buffer has overflowed, the oldest data will be lost and new\n * data will be written to the FIFO.\n *\n * If the FIFO buffer is empty, reading this register will return the last byte\n * that was previously read from the FIFO until new data is available. The user\n * should check FIFO_COUNT to ensure that the FIFO buffer is not read when\n * empty.\n *\n * @return Byte from FIFO buffer\n */\nuint8_t MPU6050::getFIFOByte() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_FIFO_R_W, buffer);\n    return buffer[0];\n}\nvoid MPU6050::getFIFOBytes(uint8_t *data, uint8_t length) {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_FIFO_R_W, length, data);\n}\n/** Write byte to FIFO buffer.\n * @see getFIFOByte()\n * @see MPU6050_RA_FIFO_R_W\n */\nvoid MPU6050::setFIFOByte(uint8_t data) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_FIFO_R_W, data);\n}\n\n// WHO_AM_I register\n\n/** Get Device ID.\n * This register is used to verify the identity of the device (0b110100, 0x34).\n * @return Device ID (6 bits only! should be 0x34)\n * @see MPU6050_RA_WHO_AM_I\n * @see MPU6050_WHO_AM_I_BIT\n * @see MPU6050_WHO_AM_I_LENGTH\n */\nuint8_t MPU6050::getDeviceID() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_WHO_AM_I, MPU6050_WHO_AM_I_BIT, MPU6050_WHO_AM_I_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set Device ID.\n * Write a new ID into the WHO_AM_I register (no idea why this should ever be\n * necessary though).\n * @param id New device ID to set.\n * @see getDeviceID()\n * @see MPU6050_RA_WHO_AM_I\n * @see MPU6050_WHO_AM_I_BIT\n * @see MPU6050_WHO_AM_I_LENGTH\n */\nvoid MPU6050::setDeviceID(uint8_t id) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_WHO_AM_I, MPU6050_WHO_AM_I_BIT, MPU6050_WHO_AM_I_LENGTH, id);\n}\n\n// ======== UNDOCUMENTED/DMP REGISTERS/METHODS ========\n\n// XG_OFFS_TC register\n\nuint8_t MPU6050::getOTPBankValid() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_XG_OFFS_TC, MPU6050_TC_OTP_BNK_VLD_BIT, buffer);\n    return buffer[0];\n}\nvoid MPU6050::setOTPBankValid(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_XG_OFFS_TC, MPU6050_TC_OTP_BNK_VLD_BIT, enabled);\n}\nint8_t MPU6050::getXGyroOffset() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_XG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH, buffer);\n    return buffer[0];\n}\nvoid MPU6050::setXGyroOffset(int8_t offset) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_XG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH, offset);\n}\n\n// YG_OFFS_TC register\n\nint8_t MPU6050::getYGyroOffset() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_YG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH, buffer);\n    return buffer[0];\n}\nvoid MPU6050::setYGyroOffset(int8_t offset) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_YG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH, offset);\n}\n\n// ZG_OFFS_TC register\n\nint8_t MPU6050::getZGyroOffset() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_ZG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH, buffer);\n    return buffer[0];\n}\nvoid MPU6050::setZGyroOffset(int8_t offset) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_ZG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH, offset);\n}\n\n// X_FINE_GAIN register\n\nint8_t MPU6050::getXFineGain() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_X_FINE_GAIN, buffer);\n    return buffer[0];\n}\nvoid MPU6050::setXFineGain(int8_t gain) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_X_FINE_GAIN, gain);\n}\n\n// Y_FINE_GAIN register\n\nint8_t MPU6050::getYFineGain() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_Y_FINE_GAIN, buffer);\n    return buffer[0];\n}\nvoid MPU6050::setYFineGain(int8_t gain) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_Y_FINE_GAIN, gain);\n}\n\n// Z_FINE_GAIN register\n\nint8_t MPU6050::getZFineGain() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_Z_FINE_GAIN, buffer);\n    return buffer[0];\n}\nvoid MPU6050::setZFineGain(int8_t gain) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_Z_FINE_GAIN, gain);\n}\n\n// XA_OFFS_* registers\n\nint16_t MPU6050::getXAccelOffset() {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_XA_OFFS_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\nvoid MPU6050::setXAccelOffset(int16_t offset) {\n    I2Cdev::writeWord(devAddr, MPU6050_RA_XA_OFFS_H, offset);\n}\n\n// YA_OFFS_* register\n\nint16_t MPU6050::getYAccelOffset() {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_YA_OFFS_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\nvoid MPU6050::setYAccelOffset(int16_t offset) {\n    I2Cdev::writeWord(devAddr, MPU6050_RA_YA_OFFS_H, offset);\n}\n\n// ZA_OFFS_* register\n\nint16_t MPU6050::getZAccelOffset() {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_ZA_OFFS_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\nvoid MPU6050::setZAccelOffset(int16_t offset) {\n    I2Cdev::writeWord(devAddr, MPU6050_RA_ZA_OFFS_H, offset);\n}\n\n// XG_OFFS_USR* registers\n\nint16_t MPU6050::getXGyroOffsetUser() {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_XG_OFFS_USRH, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\nvoid MPU6050::setXGyroOffsetUser(int16_t offset) {\n    I2Cdev::writeWord(devAddr, MPU6050_RA_XG_OFFS_USRH, offset);\n}\n\n// YG_OFFS_USR* register\n\nint16_t MPU6050::getYGyroOffsetUser() {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_YG_OFFS_USRH, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\nvoid MPU6050::setYGyroOffsetUser(int16_t offset) {\n    I2Cdev::writeWord(devAddr, MPU6050_RA_YG_OFFS_USRH, offset);\n}\n\n// ZG_OFFS_USR* register\n\nint16_t MPU6050::getZGyroOffsetUser() {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_ZG_OFFS_USRH, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\nvoid MPU6050::setZGyroOffsetUser(int16_t offset) {\n    I2Cdev::writeWord(devAddr, MPU6050_RA_ZG_OFFS_USRH, offset);\n}\n\n// INT_ENABLE register (DMP functions)\n\nbool MPU6050::getIntPLLReadyEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_PLL_RDY_INT_BIT, buffer);\n    return buffer[0];\n}\nvoid MPU6050::setIntPLLReadyEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_PLL_RDY_INT_BIT, enabled);\n}\nbool MPU6050::getIntDMPEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_DMP_INT_BIT, buffer);\n    return buffer[0];\n}\nvoid MPU6050::setIntDMPEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_DMP_INT_BIT, enabled);\n}\n\n// DMP_INT_STATUS\n\nbool MPU6050::getDMPInt5Status() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_DMP_INT_STATUS, MPU6050_DMPINT_5_BIT, buffer);\n    return buffer[0];\n}\nbool MPU6050::getDMPInt4Status() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_DMP_INT_STATUS, MPU6050_DMPINT_4_BIT, buffer);\n    return buffer[0];\n}\nbool MPU6050::getDMPInt3Status() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_DMP_INT_STATUS, MPU6050_DMPINT_3_BIT, buffer);\n    return buffer[0];\n}\nbool MPU6050::getDMPInt2Status() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_DMP_INT_STATUS, MPU6050_DMPINT_2_BIT, buffer);\n    return buffer[0];\n}\nbool MPU6050::getDMPInt1Status() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_DMP_INT_STATUS, MPU6050_DMPINT_1_BIT, buffer);\n    return buffer[0];\n}\nbool MPU6050::getDMPInt0Status() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_DMP_INT_STATUS, MPU6050_DMPINT_0_BIT, buffer);\n    return buffer[0];\n}\n\n// INT_STATUS register (DMP functions)\n\nbool MPU6050::getIntPLLReadyStatus() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_STATUS, MPU6050_INTERRUPT_PLL_RDY_INT_BIT, buffer);\n    return buffer[0];\n}\nbool MPU6050::getIntDMPStatus() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_STATUS, MPU6050_INTERRUPT_DMP_INT_BIT, buffer);\n    return buffer[0];\n}\n\n// USER_CTRL register (DMP functions)\n\nbool MPU6050::getDMPEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_EN_BIT, buffer);\n    return buffer[0];\n}\nvoid MPU6050::setDMPEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_EN_BIT, enabled);\n}\nvoid MPU6050::resetDMP() {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_RESET_BIT, true);\n}\n\n// BANK_SEL register\n\nvoid MPU6050::setMemoryBank(uint8_t bank, bool prefetchEnabled, bool userBank) {\n    bank &= 0x1F;\n    if (userBank) bank |= 0x20;\n    if (prefetchEnabled) bank |= 0x40;\n    I2Cdev::writeByte(devAddr, MPU6050_RA_BANK_SEL, bank);\n}\n\n// MEM_START_ADDR register\n\nvoid MPU6050::setMemoryStartAddress(uint8_t address) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_MEM_START_ADDR, address);\n}\n\n// MEM_R_W register\n\nuint8_t MPU6050::readMemoryByte() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_MEM_R_W, buffer);\n    return buffer[0];\n}\nvoid MPU6050::writeMemoryByte(uint8_t data) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_MEM_R_W, data);\n}\nvoid MPU6050::readMemoryBlock(uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address) {\n    setMemoryBank(bank);\n    setMemoryStartAddress(address);\n    uint8_t chunkSize;\n    for (uint16_t i = 0; i < dataSize;) {\n        // determine correct chunk size according to bank position and data size\n        chunkSize = MPU6050_DMP_MEMORY_CHUNK_SIZE;\n\n        // make sure we don't go past the data size\n        if (i + chunkSize > dataSize) chunkSize = dataSize - i;\n\n        // make sure this chunk doesn't go past the bank boundary (256 bytes)\n        if (chunkSize > 256 - address) chunkSize = 256 - address;\n\n        // read the chunk of data as specified\n        I2Cdev::readBytes(devAddr, MPU6050_RA_MEM_R_W, chunkSize, data + i);\n        \n        // increase byte index by [chunkSize]\n        i += chunkSize;\n\n        // uint8_t automatically wraps to 0 at 256\n        address += chunkSize;\n\n        // if we aren't done, update bank (if necessary) and address\n        if (i < dataSize) {\n            if (address == 0) bank++;\n            setMemoryBank(bank);\n            setMemoryStartAddress(address);\n        }\n    }\n}\nbool MPU6050::writeMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify, bool useProgMem) {\n    setMemoryBank(bank);\n    setMemoryStartAddress(address);\n    uint8_t chunkSize;\n    uint8_t *verifyBuffer;\n    uint8_t *progBuffer;\n    uint16_t i;\n    uint8_t j;\n    if (verify) verifyBuffer = (uint8_t *)malloc(MPU6050_DMP_MEMORY_CHUNK_SIZE);\n    if (useProgMem) progBuffer = (uint8_t *)malloc(MPU6050_DMP_MEMORY_CHUNK_SIZE);\n    for (i = 0; i < dataSize;) {\n        // determine correct chunk size according to bank position and data size\n        chunkSize = MPU6050_DMP_MEMORY_CHUNK_SIZE;\n\n        // make sure we don't go past the data size\n        if (i + chunkSize > dataSize) chunkSize = dataSize - i;\n\n        // make sure this chunk doesn't go past the bank boundary (256 bytes)\n        if (chunkSize > 256 - address) chunkSize = 256 - address;\n        \n        if (useProgMem) {\n            // write the chunk of data as specified\n            for (j = 0; j < chunkSize; j++) progBuffer[j] = pgm_read_byte(data + i + j);\n        } else {\n            // write the chunk of data as specified\n            progBuffer = (uint8_t *)data + i;\n        }\n\n        I2Cdev::writeBytes(devAddr, MPU6050_RA_MEM_R_W, chunkSize, progBuffer);\n\n        // verify data if needed\n        if (verify && verifyBuffer) {\n            setMemoryBank(bank);\n            setMemoryStartAddress(address);\n            I2Cdev::readBytes(devAddr, MPU6050_RA_MEM_R_W, chunkSize, verifyBuffer);\n            if (memcmp(progBuffer, verifyBuffer, chunkSize) != 0) {\n                /*Serial.print(\"Block write verification error, bank \");\n                Serial.print(bank, DEC);\n                Serial.print(\", address \");\n                Serial.print(address, DEC);\n                Serial.print(\"!\\nExpected:\");\n                for (j = 0; j < chunkSize; j++) {\n                    Serial.print(\" 0x\");\n                    if (progBuffer[j] < 16) Serial.print(\"0\");\n                    Serial.print(progBuffer[j], HEX);\n                }\n                Serial.print(\"\\nReceived:\");\n                for (uint8_t j = 0; j < chunkSize; j++) {\n                    Serial.print(\" 0x\");\n                    if (verifyBuffer[i + j] < 16) Serial.print(\"0\");\n                    Serial.print(verifyBuffer[i + j], HEX);\n                }\n                Serial.print(\"\\n\");*/\n                free(verifyBuffer);\n                if (useProgMem) free(progBuffer);\n                return false; // uh oh.\n            }\n        }\n\n        // increase byte index by [chunkSize]\n        i += chunkSize;\n\n        // uint8_t automatically wraps to 0 at 256\n        address += chunkSize;\n\n        // if we aren't done, update bank (if necessary) and address\n        if (i < dataSize) {\n            if (address == 0) bank++;\n            setMemoryBank(bank);\n            setMemoryStartAddress(address);\n        }\n    }\n    if (verify) free(verifyBuffer);\n    if (useProgMem) free(progBuffer);\n    return true;\n}\nbool MPU6050::writeProgMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify) {\n    return writeMemoryBlock(data, dataSize, bank, address, verify, true);\n}\nbool MPU6050::writeDMPConfigurationSet(const uint8_t *data, uint16_t dataSize, bool useProgMem) {\n    uint8_t *progBuffer, success, special;\n    uint16_t i, j;\n    if (useProgMem) {\n        progBuffer = (uint8_t *)malloc(8); // assume 8-byte blocks, realloc later if necessary\n    }\n\n    // config set data is a long string of blocks with the following structure:\n    // [bank] [offset] [length] [byte[0], byte[1], ..., byte[length]]\n    uint8_t bank, offset, length;\n    for (i = 0; i < dataSize;) {\n        if (useProgMem) {\n            bank = pgm_read_byte(data + i++);\n            offset = pgm_read_byte(data + i++);\n            length = pgm_read_byte(data + i++);\n        } else {\n            bank = data[i++];\n            offset = data[i++];\n            length = data[i++];\n        }\n\n        // write data or perform special action\n        if (length > 0) {\n            // regular block of data to write\n            /*Serial.print(\"Writing config block to bank \");\n            Serial.print(bank);\n            Serial.print(\", offset \");\n            Serial.print(offset);\n            Serial.print(\", length=\");\n            Serial.println(length);*/\n            if (useProgMem) {\n                if (sizeof(progBuffer) < length) progBuffer = (uint8_t *)realloc(progBuffer, length);\n                for (j = 0; j < length; j++) progBuffer[j] = pgm_read_byte(data + i + j);\n            } else {\n                progBuffer = (uint8_t *)data + i;\n            }\n            success = writeMemoryBlock(progBuffer, length, bank, offset, true);\n            i += length;\n        } else {\n            // special instruction\n            // NOTE: this kind of behavior (what and when to do certain things)\n            // is totally undocumented. This code is in here based on observed\n            // behavior only, and exactly why (or even whether) it has to be here\n            // is anybody's guess for now.\n            if (useProgMem) {\n                special = pgm_read_byte(data + i++);\n            } else {\n                special = data[i++];\n            }\n            /*Serial.print(\"Special command code \");\n            Serial.print(special, HEX);\n            Serial.println(\" found...\");*/\n            if (special == 0x01) {\n                // enable DMP-related interrupts\n                \n                //setIntZeroMotionEnabled(true);\n                //setIntFIFOBufferOverflowEnabled(true);\n                //setIntDMPEnabled(true);\n                I2Cdev::writeByte(devAddr, MPU6050_RA_INT_ENABLE, 0x32);  // single operation\n\n                success = true;\n            } else {\n                // unknown special command\n                success = false;\n            }\n        }\n        \n        if (!success) {\n            if (useProgMem) free(progBuffer);\n            return false; // uh oh\n        }\n    }\n    if (useProgMem) free(progBuffer);\n    return true;\n}\nbool MPU6050::writeProgDMPConfigurationSet(const uint8_t *data, uint16_t dataSize) {\n    return writeDMPConfigurationSet(data, dataSize, true);\n}\n\n// DMP_CFG_1 register\n\nuint8_t MPU6050::getDMPConfig1() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_DMP_CFG_1, buffer);\n    return buffer[0];\n}\nvoid MPU6050::setDMPConfig1(uint8_t config) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_DMP_CFG_1, config);\n}\n\n// DMP_CFG_2 register\n\nuint8_t MPU6050::getDMPConfig2() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_DMP_CFG_2, buffer);\n    return buffer[0];\n}\nvoid MPU6050::setDMPConfig2(uint8_t config) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_DMP_CFG_2, config);\n}"},{"name":"MPU6050wrapper.cpp","type":"source","group":"legacy","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/../../../MATLAB Add-Ons/Collections/Rensselaer Arduino Support Package Library (RASPLib)/RASPlib/src","tag":"","groupDisplay":"Other files","code":"\n#include \"Wire.h\"\n#include \"twi.h\"\n#include \"I2Cdev.h\"\n#include \"MPU6050.h\"\n\nMPU6050 accelgyro;\n\nextern \"C\" void MPU6050Accel_Init(void)\n{\n    Wire.begin();\n    accelgyro.initialize();\n\t\n/* \t// Make devAddr public and add this line:\n\tif(!accelgyro.testConnection())\n\t{\n\t\t//Serial.println(\"Test Connection Failed Changing I2C addr to 0x69\");\n\t\taccelgyro.devAddr=0x69;\n\t} */\n\t\n\t\n\t//  Enable I2C bypass on MPU6050 so the compass can be accessed\n\tI2Cdev::writeBit(MPU6050_DEFAULT_ADDRESS, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_I2C_MST_EN_BIT, false);\n\tI2Cdev::writeBit(MPU6050_DEFAULT_ADDRESS, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_I2C_BYPASS_EN_BIT, true);\n\tI2Cdev::writeBit(MPU6050_DEFAULT_ADDRESS, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, false);\n}\nextern \"C\" void MPU6050Accel_Read(int* pfData)\n{\n    pfData[0]=accelgyro.getAccelerationX();\n    pfData[1]=accelgyro.getAccelerationY();\n    pfData[2]=accelgyro.getAccelerationZ();\n}\n\nextern \"C\" void MPU6050Gyro_Init(int DLPFmode)\n{\n    Wire.begin();\n\taccelgyro.setDLPFMode(DLPFmode);\n    accelgyro.initialize();\n}\n\nextern \"C\" void MPU6050Gyro_Read(int* pfData)\n{\n    pfData[0]=accelgyro.getRotationX();\n    pfData[1]=accelgyro.getRotationY();\n    pfData[2]=accelgyro.getRotationZ();    \n}\n\nextern \"C\" void MPU6050Temp_Read(int* pfData)\n{\n    pfData[0]=accelgyro.getTemperature();\n}\n\n"},{"name":"MPU9250.cpp","type":"source","group":"other","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"// I2Cdev library collection - MPU9250 I2C device class\n// Based on InvenSense MPU-9250 register map document rev. 2.0, 5/19/2011 (RM-MPU-6000A-00)\n// 8/24/2011 by Jeff Rowberg <jeff@rowberg.net>\n// Updates should (hopefully) always be available at https://github.com/jrowberg/i2cdevlib\n//\n// Changelog:\n//     ... - ongoing debug release\n\n// NOTE: THIS IS ONLY A PARIAL RELEASE. THIS DEVICE CLASS IS CURRENTLY UNDERGOING ACTIVE\n// DEVELOPMENT AND IS STILL MISSING SOME IMPORTANT FEATURES. PLEASE KEEP THIS IN MIND IF\n// YOU DECIDE TO USE THIS PARTICULAR CODE FOR ANYTHING.\n\n/* ============================================\nI2Cdev device library code is placed under the MIT license\nCopyright (c) 2012 Jeff Rowberg\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n===============================================\n*/\n\n#include \"MPU9250.h\"\n\n/** Default constructor, uses default I2C address.\n * @see MPU9250_DEFAULT_ADDRESS\n */\nMPU9250::MPU9250() {\n    devAddr = MPU9250_ADDRESS_AD0_LOW;\n}\n\n/** Specific address constructor.\n * @param address I2C address\n * @see MPU9250_DEFAULT_ADDRESS\n * @see MPU9250_ADDRESS_AD0_LOW\n * @see MPU9250_ADDRESS_AD0_HIGH\n */\nMPU9250::MPU9250(uint8_t address) {\n    devAddr = address;\n}\n\n/** Power on and prepare for general usage.\n * This will activate the device and take it out of sleep mode (which must be done\n * after start-up). This function also sets both the accelerometer and the gyroscope\n * to their most sensitive settings, namely +/- 2g and +/- 250 degrees/sec, and sets\n * the clock source to use the X Gyro for reference, which is slightly better than\n * the default internal clock source.\n */\nvoid MPU9250::initialize() {\n    setClockSource(MPU9250_CLOCK_PLL_XGYRO);\n    setFullScaleGyroRange(MPU9250_GYRO_FS_250);\n    setFullScaleAccelRange(MPU9250_ACCEL_FS_2);\n    setSleepEnabled(false); // thanks to Jack Elston for pointing this one out!\n}\n\n/** Verify the I2C connection.\n * Make sure the device is connected and responds as expected.\n * @return True if connection is valid, false otherwise\n */\nbool MPU9250::testConnection() {\n    return getDeviceID() == 0x71;\n}\n\n// AUX_VDDIO register (InvenSense demo code calls this RA_*G_OFFS_TC)\n\n/** Get the auxiliary I2C supply voltage level.\n * When set to 1, the auxiliary I2C bus high logic level is VDD. When cleared to\n * 0, the auxiliary I2C bus high logic level is VLOGIC. This does not apply to\n * the MPU-6000, which does not have a VLOGIC pin.\n * @return I2C supply voltage level (0=VLOGIC, 1=VDD)\n */\nuint8_t MPU9250::getAuxVDDIOLevel() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_YG_OFFS_TC, MPU9250_TC_PWR_MODE_BIT, buffer);\n    return buffer[0];\n}\n/** Set the auxiliary I2C supply voltage level.\n * When set to 1, the auxiliary I2C bus high logic level is VDD. When cleared to\n * 0, the auxiliary I2C bus high logic level is VLOGIC. This does not apply to\n * the MPU-6000, which does not have a VLOGIC pin.\n * @param level I2C supply voltage level (0=VLOGIC, 1=VDD)\n */\nvoid MPU9250::setAuxVDDIOLevel(uint8_t level) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_YG_OFFS_TC, MPU9250_TC_PWR_MODE_BIT, level);\n}\n\n// SMPLRT_DIV register\n\n/** Get gyroscope output rate divider.\n * The sensor register output, FIFO output, DMP sampling, Motion detection, Zero\n * Motion detection, and Free Fall detection are all based on the Sample Rate.\n * The Sample Rate is generated by dividing the gyroscope output rate by\n * SMPLRT_DIV:\n *\n * Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)\n *\n * where Gyroscope Output Rate = 8kHz when the DLPF is disabled (DLPF_CFG = 0 or\n * 7), and 1kHz when the DLPF is enabled (see Register 26).\n *\n * Note: The accelerometer output rate is 1kHz. This means that for a Sample\n * Rate greater than 1kHz, the same accelerometer sample may be output to the\n * FIFO, DMP, and sensor registers more than once.\n *\n * For a diagram of the gyroscope and accelerometer signal paths, see Section 8\n * of the MPU-6000/MPU-9250 Product Specification document.\n *\n * @return Current sample rate\n * @see MPU9250_RA_SMPLRT_DIV\n */\nuint8_t MPU9250::getRate() {\n    I2Cdev::readByte(devAddr, MPU9250_RA_SMPLRT_DIV, buffer);\n    return buffer[0];\n}\n/** Set gyroscope sample rate divider.\n * @param rate New sample rate divider\n * @see getRate()\n * @see MPU9250_RA_SMPLRT_DIV\n */\nvoid MPU9250::setRate(uint8_t rate) {\n    I2Cdev::writeByte(devAddr, MPU9250_RA_SMPLRT_DIV, rate);\n}\n\n// CONFIG register\n\n/** Get external FSYNC configuration.\n * Configures the external Frame Synchronization (FSYNC) pin sampling. An\n * external signal connected to the FSYNC pin can be sampled by configuring\n * EXT_SYNC_SET. Signal changes to the FSYNC pin are latched so that short\n * strobes may be captured. The latched FSYNC signal will be sampled at the\n * Sampling Rate, as defined in register 25. After sampling, the latch will\n * reset to the current FSYNC signal state.\n *\n * The sampled value will be reported in place of the least significant bit in\n * a sensor data register determined by the value of EXT_SYNC_SET according to\n * the following table.\n *\n * <pre>\n * EXT_SYNC_SET | FSYNC Bit Location\n * -------------+-------------------\n * 0            | Input disabled\n * 1            | TEMP_OUT_L[0]\n * 2            | GYRO_XOUT_L[0]\n * 3            | GYRO_YOUT_L[0]\n * 4            | GYRO_ZOUT_L[0]\n * 5            | ACCEL_XOUT_L[0]\n * 6            | ACCEL_YOUT_L[0]\n * 7            | ACCEL_ZOUT_L[0]\n * </pre>\n *\n * @return FSYNC configuration value\n */\nuint8_t MPU9250::getExternalFrameSync() {\n    I2Cdev::readBits(devAddr, MPU9250_RA_CONFIG, MPU9250_CFG_EXT_SYNC_SET_BIT, MPU9250_CFG_EXT_SYNC_SET_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set external FSYNC configuration.\n * @see getExternalFrameSync()\n * @see MPU9250_RA_CONFIG\n * @param sync New FSYNC configuration value\n */\nvoid MPU9250::setExternalFrameSync(uint8_t sync) {\n    I2Cdev::writeBits(devAddr, MPU9250_RA_CONFIG, MPU9250_CFG_EXT_SYNC_SET_BIT, MPU9250_CFG_EXT_SYNC_SET_LENGTH, sync);\n}\n/** Get digital low-pass filter configuration.\n * The DLPF_CFG parameter sets the digital low pass filter configuration. It\n * also determines the internal sampling rate used by the device as shown in\n * the table below.\n *\n * Note: The accelerometer output rate is 1kHz. This means that for a Sample\n * Rate greater than 1kHz, the same accelerometer sample may be output to the\n * FIFO, DMP, and sensor registers more than once.\n *\n * <pre>\n *          |   ACCELEROMETER    |           GYROSCOPE\n * DLPF_CFG | Bandwidth | Delay  | Bandwidth | Delay  | Sample Rate\n * ---------+-----------+--------+-----------+--------+-------------\n * 0        | 260Hz     | 0ms    | 256Hz     | 0.98ms | 8kHz\n * 1        | 184Hz     | 2.0ms  | 188Hz     | 1.9ms  | 1kHz\n * 2        | 94Hz      | 3.0ms  | 98Hz      | 2.8ms  | 1kHz\n * 3        | 44Hz      | 4.9ms  | 42Hz      | 4.8ms  | 1kHz\n * 4        | 21Hz      | 8.5ms  | 20Hz      | 8.3ms  | 1kHz\n * 5        | 10Hz      | 13.8ms | 10Hz      | 13.4ms | 1kHz\n * 6        | 5Hz       | 19.0ms | 5Hz       | 18.6ms | 1kHz\n * 7        |   -- Reserved --   |   -- Reserved --   | Reserved\n * </pre>\n *\n * @return DLFP configuration\n * @see MPU9250_RA_CONFIG\n * @see MPU9250_CFG_DLPF_CFG_BIT\n * @see MPU9250_CFG_DLPF_CFG_LENGTH\n */\nuint8_t MPU9250::getDLPFMode() {\n    I2Cdev::readBits(devAddr, MPU9250_RA_CONFIG, MPU9250_CFG_DLPF_CFG_BIT, MPU9250_CFG_DLPF_CFG_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set digital low-pass filter configuration.\n * @param mode New DLFP configuration setting\n * @see getDLPFBandwidth()\n * @see MPU9250_DLPF_BW_256\n * @see MPU9250_RA_CONFIG\n * @see MPU9250_CFG_DLPF_CFG_BIT\n * @see MPU9250_CFG_DLPF_CFG_LENGTH\n */\nvoid MPU9250::setDLPFMode(uint8_t mode) {\n    I2Cdev::writeBits(devAddr, MPU9250_RA_CONFIG, MPU9250_CFG_DLPF_CFG_BIT, MPU9250_CFG_DLPF_CFG_LENGTH, mode);\n}\n\n// GYRO_CONFIG register\n\n/** Get full-scale gyroscope range.\n * The FS_SEL parameter allows setting the full-scale range of the gyro sensors,\n * as described in the table below.\n *\n * <pre>\n * 0 = +/- 250 degrees/sec\n * 1 = +/- 500 degrees/sec\n * 2 = +/- 1000 degrees/sec\n * 3 = +/- 2000 degrees/sec\n * </pre>\n *\n * @return Current full-scale gyroscope range setting\n * @see MPU9250_GYRO_FS_250\n * @see MPU9250_RA_GYRO_CONFIG\n * @see MPU9250_GCONFIG_FS_SEL_BIT\n * @see MPU9250_GCONFIG_FS_SEL_LENGTH\n */\nuint8_t MPU9250::getFullScaleGyroRange() {\n    I2Cdev::readBits(devAddr, MPU9250_RA_GYRO_CONFIG, MPU9250_GCONFIG_FS_SEL_BIT, MPU9250_GCONFIG_FS_SEL_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set full-scale gyroscope range.\n * @param range New full-scale gyroscope range value\n * @see getFullScaleRange()\n * @see MPU9250_GYRO_FS_250\n * @see MPU9250_RA_GYRO_CONFIG\n * @see MPU9250_GCONFIG_FS_SEL_BIT\n * @see MPU9250_GCONFIG_FS_SEL_LENGTH\n */\nvoid MPU9250::setFullScaleGyroRange(uint8_t range) {\n    I2Cdev::writeBits(devAddr, MPU9250_RA_GYRO_CONFIG, MPU9250_GCONFIG_FS_SEL_BIT, MPU9250_GCONFIG_FS_SEL_LENGTH, range);\n}\n\n// ACCEL_CONFIG register\n\n/** Get self-test enabled setting for accelerometer X axis.\n * @return Self-test enabled value\n * @see MPU9250_RA_ACCEL_CONFIG\n */\nbool MPU9250::getAccelXSelfTest() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_ACCEL_CONFIG, MPU9250_ACONFIG_XA_ST_BIT, buffer);\n    return buffer[0];\n}\n/** Get self-test enabled setting for accelerometer X axis.\n * @param enabled Self-test enabled value\n * @see MPU9250_RA_ACCEL_CONFIG\n */\nvoid MPU9250::setAccelXSelfTest(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_ACCEL_CONFIG, MPU9250_ACONFIG_XA_ST_BIT, enabled);\n}\n/** Get self-test enabled value for accelerometer Y axis.\n * @return Self-test enabled value\n * @see MPU9250_RA_ACCEL_CONFIG\n */\nbool MPU9250::getAccelYSelfTest() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_ACCEL_CONFIG, MPU9250_ACONFIG_YA_ST_BIT, buffer);\n    return buffer[0];\n}\n/** Get self-test enabled value for accelerometer Y axis.\n * @param enabled Self-test enabled value\n * @see MPU9250_RA_ACCEL_CONFIG\n */\nvoid MPU9250::setAccelYSelfTest(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_ACCEL_CONFIG, MPU9250_ACONFIG_YA_ST_BIT, enabled);\n}\n/** Get self-test enabled value for accelerometer Z axis.\n * @return Self-test enabled value\n * @see MPU9250_RA_ACCEL_CONFIG\n */\nbool MPU9250::getAccelZSelfTest() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_ACCEL_CONFIG, MPU9250_ACONFIG_ZA_ST_BIT, buffer);\n    return buffer[0];\n}\n/** Set self-test enabled value for accelerometer Z axis.\n * @param enabled Self-test enabled value\n * @see MPU9250_RA_ACCEL_CONFIG\n */\nvoid MPU9250::setAccelZSelfTest(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_ACCEL_CONFIG, MPU9250_ACONFIG_ZA_ST_BIT, enabled);\n}\n/** Get full-scale accelerometer range.\n * The FS_SEL parameter allows setting the full-scale range of the accelerometer\n * sensors, as described in the table below.\n *\n * <pre>\n * 0 = +/- 2g\n * 1 = +/- 4g\n * 2 = +/- 8g\n * 3 = +/- 16g\n * </pre>\n *\n * @return Current full-scale accelerometer range setting\n * @see MPU9250_ACCEL_FS_2\n * @see MPU9250_RA_ACCEL_CONFIG\n * @see MPU9250_ACONFIG_AFS_SEL_BIT\n * @see MPU9250_ACONFIG_AFS_SEL_LENGTH\n */\nuint8_t MPU9250::getFullScaleAccelRange() {\n    I2Cdev::readBits(devAddr, MPU9250_RA_ACCEL_CONFIG, MPU9250_ACONFIG_AFS_SEL_BIT, MPU9250_ACONFIG_AFS_SEL_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set full-scale accelerometer range.\n * @param range New full-scale accelerometer range setting\n * @see getFullScaleAccelRange()\n */\nvoid MPU9250::setFullScaleAccelRange(uint8_t range) {\n    I2Cdev::writeBits(devAddr, MPU9250_RA_ACCEL_CONFIG, MPU9250_ACONFIG_AFS_SEL_BIT, MPU9250_ACONFIG_AFS_SEL_LENGTH, range);\n}\n/** Get the high-pass filter configuration.\n * The DHPF is a filter module in the path leading to motion detectors (Free\n * Fall, Motion threshold, and Zero Motion). The high pass filter output is not\n * available to the data registers (see Figure in Section 8 of the MPU-6000/\n * MPU-9250 Product Specification document).\n *\n * The high pass filter has three modes:\n *\n * <pre>\n *    Reset: The filter output settles to zero within one sample. This\n *           effectively disables the high pass filter. This mode may be toggled\n *           to quickly settle the filter.\n *\n *    On:    The high pass filter will pass signals above the cut off frequency.\n *\n *    Hold:  When triggered, the filter holds the present sample. The filter\n *           output will be the difference between the input sample and the held\n *           sample.\n * </pre>\n *\n * <pre>\n * ACCEL_HPF | Filter Mode | Cut-off Frequency\n * ----------+-------------+------------------\n * 0         | Reset       | None\n * 1         | On          | 5Hz\n * 2         | On          | 2.5Hz\n * 3         | On          | 1.25Hz\n * 4         | On          | 0.63Hz\n * 7         | Hold        | None\n * </pre>\n *\n * @return Current high-pass filter configuration\n * @see MPU9250_DHPF_RESET\n * @see MPU9250_RA_ACCEL_CONFIG\n */\nuint8_t MPU9250::getDHPFMode() {\n    I2Cdev::readBits(devAddr, MPU9250_RA_ACCEL_CONFIG, MPU9250_ACONFIG_ACCEL_HPF_BIT, MPU9250_ACONFIG_ACCEL_HPF_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set the high-pass filter configuration.\n * @param bandwidth New high-pass filter configuration\n * @see setDHPFMode()\n * @see MPU9250_DHPF_RESET\n * @see MPU9250_RA_ACCEL_CONFIG\n */\nvoid MPU9250::setDHPFMode(uint8_t bandwidth) {\n    I2Cdev::writeBits(devAddr, MPU9250_RA_ACCEL_CONFIG, MPU9250_ACONFIG_ACCEL_HPF_BIT, MPU9250_ACONFIG_ACCEL_HPF_LENGTH, bandwidth);\n}\n\n// FF_THR register\n\n/** Get free-fall event acceleration threshold.\n * This register configures the detection threshold for Free Fall event\n * detection. The unit of FF_THR is 1LSB = 2mg. Free Fall is detected when the\n * absolute value of the accelerometer measurements for the three axes are each\n * less than the detection threshold. This condition increments the Free Fall\n * duration counter (Register 30). The Free Fall interrupt is triggered when the\n * Free Fall duration counter reaches the time specified in FF_DUR.\n *\n * For more details on the Free Fall detection interrupt, see Section 8.2 of the\n * MPU-6000/MPU-9250 Product Specification document as well as Registers 56 and\n * 58 of this document.\n *\n * @return Current free-fall acceleration threshold value (LSB = 2mg)\n * @see MPU9250_RA_FF_THR\n */\nuint8_t MPU9250::getFreefallDetectionThreshold() {\n    I2Cdev::readByte(devAddr, MPU9250_RA_FF_THR, buffer);\n    return buffer[0];\n}\n/** Get free-fall event acceleration threshold.\n * @param threshold New free-fall acceleration threshold value (LSB = 2mg)\n * @see getFreefallDetectionThreshold()\n * @see MPU9250_RA_FF_THR\n */\nvoid MPU9250::setFreefallDetectionThreshold(uint8_t threshold) {\n    I2Cdev::writeByte(devAddr, MPU9250_RA_FF_THR, threshold);\n}\n\n// FF_DUR register\n\n/** Get free-fall event duration threshold.\n * This register configures the duration counter threshold for Free Fall event\n * detection. The duration counter ticks at 1kHz, therefore FF_DUR has a unit\n * of 1 LSB = 1 ms.\n *\n * The Free Fall duration counter increments while the absolute value of the\n * accelerometer measurements are each less than the detection threshold\n * (Register 29). The Free Fall interrupt is triggered when the Free Fall\n * duration counter reaches the time specified in this register.\n *\n * For more details on the Free Fall detection interrupt, see Section 8.2 of\n * the MPU-6000/MPU-9250 Product Specification document as well as Registers 56\n * and 58 of this document.\n *\n * @return Current free-fall duration threshold value (LSB = 1ms)\n * @see MPU9250_RA_FF_DUR\n */\nuint8_t MPU9250::getFreefallDetectionDuration() {\n    I2Cdev::readByte(devAddr, MPU9250_RA_FF_DUR, buffer);\n    return buffer[0];\n}\n/** Get free-fall event duration threshold.\n * @param duration New free-fall duration threshold value (LSB = 1ms)\n * @see getFreefallDetectionDuration()\n * @see MPU9250_RA_FF_DUR\n */\nvoid MPU9250::setFreefallDetectionDuration(uint8_t duration) {\n    I2Cdev::writeByte(devAddr, MPU9250_RA_FF_DUR, duration);\n}\n\n// MOT_THR register\n\n/** Get motion detection event acceleration threshold.\n * This register configures the detection threshold for Motion interrupt\n * generation. The unit of MOT_THR is 1LSB = 2mg. Motion is detected when the\n * absolute value of any of the accelerometer measurements exceeds this Motion\n * detection threshold. This condition increments the Motion detection duration\n * counter (Register 32). The Motion detection interrupt is triggered when the\n * Motion Detection counter reaches the time count specified in MOT_DUR\n * (Register 32).\n *\n * The Motion interrupt will indicate the axis and polarity of detected motion\n * in MOT_DETECT_STATUS (Register 97).\n *\n * For more details on the Motion detection interrupt, see Section 8.3 of the\n * MPU-6000/MPU-9250 Product Specification document as well as Registers 56 and\n * 58 of this document.\n *\n * @return Current motion detection acceleration threshold value (LSB = 2mg)\n * @see MPU9250_RA_MOT_THR\n */\nuint8_t MPU9250::getMotionDetectionThreshold() {\n    I2Cdev::readByte(devAddr, MPU9250_RA_MOT_THR, buffer);\n    return buffer[0];\n}\n/** Set free-fall event acceleration threshold.\n * @param threshold New motion detection acceleration threshold value (LSB = 2mg)\n * @see getMotionDetectionThreshold()\n * @see MPU9250_RA_MOT_THR\n */\nvoid MPU9250::setMotionDetectionThreshold(uint8_t threshold) {\n    I2Cdev::writeByte(devAddr, MPU9250_RA_MOT_THR, threshold);\n}\n\n// MOT_DUR register\n\n/** Get motion detection event duration threshold.\n * This register configures the duration counter threshold for Motion interrupt\n * generation. The duration counter ticks at 1 kHz, therefore MOT_DUR has a unit\n * of 1LSB = 1ms. The Motion detection duration counter increments when the\n * absolute value of any of the accelerometer measurements exceeds the Motion\n * detection threshold (Register 31). The Motion detection interrupt is\n * triggered when the Motion detection counter reaches the time count specified\n * in this register.\n *\n * For more details on the Motion detection interrupt, see Section 8.3 of the\n * MPU-6000/MPU-9250 Product Specification document.\n *\n * @return Current motion detection duration threshold value (LSB = 1ms)\n * @see MPU9250_RA_MOT_DUR\n */\nuint8_t MPU9250::getMotionDetectionDuration() {\n    I2Cdev::readByte(devAddr, MPU9250_RA_MOT_DUR, buffer);\n    return buffer[0];\n}\n/** Set motion detection event duration threshold.\n * @param duration New motion detection duration threshold value (LSB = 1ms)\n * @see getMotionDetectionDuration()\n * @see MPU9250_RA_MOT_DUR\n */\nvoid MPU9250::setMotionDetectionDuration(uint8_t duration) {\n    I2Cdev::writeByte(devAddr, MPU9250_RA_MOT_DUR, duration);\n}\n\n// ZRMOT_THR register\n\n/** Get zero motion detection event acceleration threshold.\n * This register configures the detection threshold for Zero Motion interrupt\n * generation. The unit of ZRMOT_THR is 1LSB = 2mg. Zero Motion is detected when\n * the absolute value of the accelerometer measurements for the 3 axes are each\n * less than the detection threshold. This condition increments the Zero Motion\n * duration counter (Register 34). The Zero Motion interrupt is triggered when\n * the Zero Motion duration counter reaches the time count specified in\n * ZRMOT_DUR (Register 34).\n *\n * Unlike Free Fall or Motion detection, Zero Motion detection triggers an\n * interrupt both when Zero Motion is first detected and when Zero Motion is no\n * longer detected.\n *\n * When a zero motion event is detected, a Zero Motion Status will be indicated\n * in the MOT_DETECT_STATUS register (Register 97). When a motion-to-zero-motion\n * condition is detected, the status bit is set to 1. When a zero-motion-to-\n * motion condition is detected, the status bit is set to 0.\n *\n * For more details on the Zero Motion detection interrupt, see Section 8.4 of\n * the MPU-6000/MPU-9250 Product Specification document as well as Registers 56\n * and 58 of this document.\n *\n * @return Current zero motion detection acceleration threshold value (LSB = 2mg)\n * @see MPU9250_RA_ZRMOT_THR\n */\nuint8_t MPU9250::getZeroMotionDetectionThreshold() {\n    I2Cdev::readByte(devAddr, MPU9250_RA_ZRMOT_THR, buffer);\n    return buffer[0];\n}\n/** Set zero motion detection event acceleration threshold.\n * @param threshold New zero motion detection acceleration threshold value (LSB = 2mg)\n * @see getZeroMotionDetectionThreshold()\n * @see MPU9250_RA_ZRMOT_THR\n */\nvoid MPU9250::setZeroMotionDetectionThreshold(uint8_t threshold) {\n    I2Cdev::writeByte(devAddr, MPU9250_RA_ZRMOT_THR, threshold);\n}\n\n// ZRMOT_DUR register\n\n/** Get zero motion detection event duration threshold.\n * This register configures the duration counter threshold for Zero Motion\n * interrupt generation. The duration counter ticks at 16 Hz, therefore\n * ZRMOT_DUR has a unit of 1 LSB = 64 ms. The Zero Motion duration counter\n * increments while the absolute value of the accelerometer measurements are\n * each less than the detection threshold (Register 33). The Zero Motion\n * interrupt is triggered when the Zero Motion duration counter reaches the time\n * count specified in this register.\n *\n * For more details on the Zero Motion detection interrupt, see Section 8.4 of\n * the MPU-6000/MPU-9250 Product Specification document, as well as Registers 56\n * and 58 of this document.\n *\n * @return Current zero motion detection duration threshold value (LSB = 64ms)\n * @see MPU9250_RA_ZRMOT_DUR\n */\nuint8_t MPU9250::getZeroMotionDetectionDuration() {\n    I2Cdev::readByte(devAddr, MPU9250_RA_ZRMOT_DUR, buffer);\n    return buffer[0];\n}\n/** Set zero motion detection event duration threshold.\n * @param duration New zero motion detection duration threshold value (LSB = 1ms)\n * @see getZeroMotionDetectionDuration()\n * @see MPU9250_RA_ZRMOT_DUR\n */\nvoid MPU9250::setZeroMotionDetectionDuration(uint8_t duration) {\n    I2Cdev::writeByte(devAddr, MPU9250_RA_ZRMOT_DUR, duration);\n}\n\n// FIFO_EN register\n\n/** Get temperature FIFO enabled value.\n * When set to 1, this bit enables TEMP_OUT_H and TEMP_OUT_L (Registers 65 and\n * 66) to be written into the FIFO buffer.\n * @return Current temperature FIFO enabled value\n * @see MPU9250_RA_FIFO_EN\n */\nbool MPU9250::getTempFIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_FIFO_EN, MPU9250_TEMP_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set temperature FIFO enabled value.\n * @param enabled New temperature FIFO enabled value\n * @see getTempFIFOEnabled()\n * @see MPU9250_RA_FIFO_EN\n */\nvoid MPU9250::setTempFIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_FIFO_EN, MPU9250_TEMP_FIFO_EN_BIT, enabled);\n}\n/** Get gyroscope X-axis FIFO enabled value.\n * When set to 1, this bit enables GYRO_XOUT_H and GYRO_XOUT_L (Registers 67 and\n * 68) to be written into the FIFO buffer.\n * @return Current gyroscope X-axis FIFO enabled value\n * @see MPU9250_RA_FIFO_EN\n */\nbool MPU9250::getXGyroFIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_FIFO_EN, MPU9250_XG_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set gyroscope X-axis FIFO enabled value.\n * @param enabled New gyroscope X-axis FIFO enabled value\n * @see getXGyroFIFOEnabled()\n * @see MPU9250_RA_FIFO_EN\n */\nvoid MPU9250::setXGyroFIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_FIFO_EN, MPU9250_XG_FIFO_EN_BIT, enabled);\n}\n/** Get gyroscope Y-axis FIFO enabled value.\n * When set to 1, this bit enables GYRO_YOUT_H and GYRO_YOUT_L (Registers 69 and\n * 70) to be written into the FIFO buffer.\n * @return Current gyroscope Y-axis FIFO enabled value\n * @see MPU9250_RA_FIFO_EN\n */\nbool MPU9250::getYGyroFIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_FIFO_EN, MPU9250_YG_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set gyroscope Y-axis FIFO enabled value.\n * @param enabled New gyroscope Y-axis FIFO enabled value\n * @see getYGyroFIFOEnabled()\n * @see MPU9250_RA_FIFO_EN\n */\nvoid MPU9250::setYGyroFIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_FIFO_EN, MPU9250_YG_FIFO_EN_BIT, enabled);\n}\n/** Get gyroscope Z-axis FIFO enabled value.\n * When set to 1, this bit enables GYRO_ZOUT_H and GYRO_ZOUT_L (Registers 71 and\n * 72) to be written into the FIFO buffer.\n * @return Current gyroscope Z-axis FIFO enabled value\n * @see MPU9250_RA_FIFO_EN\n */\nbool MPU9250::getZGyroFIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_FIFO_EN, MPU9250_ZG_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set gyroscope Z-axis FIFO enabled value.\n * @param enabled New gyroscope Z-axis FIFO enabled value\n * @see getZGyroFIFOEnabled()\n * @see MPU9250_RA_FIFO_EN\n */\nvoid MPU9250::setZGyroFIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_FIFO_EN, MPU9250_ZG_FIFO_EN_BIT, enabled);\n}\n/** Get accelerometer FIFO enabled value.\n * When set to 1, this bit enables ACCEL_XOUT_H, ACCEL_XOUT_L, ACCEL_YOUT_H,\n * ACCEL_YOUT_L, ACCEL_ZOUT_H, and ACCEL_ZOUT_L (Registers 59 to 64) to be\n * written into the FIFO buffer.\n * @return Current accelerometer FIFO enabled value\n * @see MPU9250_RA_FIFO_EN\n */\nbool MPU9250::getAccelFIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_FIFO_EN, MPU9250_ACCEL_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set accelerometer FIFO enabled value.\n * @param enabled New accelerometer FIFO enabled value\n * @see getAccelFIFOEnabled()\n * @see MPU9250_RA_FIFO_EN\n */\nvoid MPU9250::setAccelFIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_FIFO_EN, MPU9250_ACCEL_FIFO_EN_BIT, enabled);\n}\n/** Get Slave 2 FIFO enabled value.\n * When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96)\n * associated with Slave 2 to be written into the FIFO buffer.\n * @return Current Slave 2 FIFO enabled value\n * @see MPU9250_RA_FIFO_EN\n */\nbool MPU9250::getSlave2FIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_FIFO_EN, MPU9250_SLV2_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set Slave 2 FIFO enabled value.\n * @param enabled New Slave 2 FIFO enabled value\n * @see getSlave2FIFOEnabled()\n * @see MPU9250_RA_FIFO_EN\n */\nvoid MPU9250::setSlave2FIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_FIFO_EN, MPU9250_SLV2_FIFO_EN_BIT, enabled);\n}\n/** Get Slave 1 FIFO enabled value.\n * When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96)\n * associated with Slave 1 to be written into the FIFO buffer.\n * @return Current Slave 1 FIFO enabled value\n * @see MPU9250_RA_FIFO_EN\n */\nbool MPU9250::getSlave1FIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_FIFO_EN, MPU9250_SLV1_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set Slave 1 FIFO enabled value.\n * @param enabled New Slave 1 FIFO enabled value\n * @see getSlave1FIFOEnabled()\n * @see MPU9250_RA_FIFO_EN\n */\nvoid MPU9250::setSlave1FIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_FIFO_EN, MPU9250_SLV1_FIFO_EN_BIT, enabled);\n}\n/** Get Slave 0 FIFO enabled value.\n * When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96)\n * associated with Slave 0 to be written into the FIFO buffer.\n * @return Current Slave 0 FIFO enabled value\n * @see MPU9250_RA_FIFO_EN\n */\nbool MPU9250::getSlave0FIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_FIFO_EN, MPU9250_SLV0_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set Slave 0 FIFO enabled value.\n * @param enabled New Slave 0 FIFO enabled value\n * @see getSlave0FIFOEnabled()\n * @see MPU9250_RA_FIFO_EN\n */\nvoid MPU9250::setSlave0FIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_FIFO_EN, MPU9250_SLV0_FIFO_EN_BIT, enabled);\n}\n\n// I2C_MST_CTRL register\n\n/** Get multi-master enabled value.\n * Multi-master capability allows multiple I2C masters to operate on the same\n * bus. In circuits where multi-master capability is required, set MULT_MST_EN\n * to 1. This will increase current drawn by approximately 30uA.\n *\n * In circuits where multi-master capability is required, the state of the I2C\n * bus must always be monitored by each separate I2C Master. Before an I2C\n * Master can assume arbitration of the bus, it must first confirm that no other\n * I2C Master has arbitration of the bus. When MULT_MST_EN is set to 1, the\n * MPU-60X0's bus arbitration detection logic is turned on, enabling it to\n * detect when the bus is available.\n *\n * @return Current multi-master enabled value\n * @see MPU9250_RA_I2C_MST_CTRL\n */\nbool MPU9250::getMultiMasterEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_I2C_MST_CTRL, MPU9250_MULT_MST_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set multi-master enabled value.\n * @param enabled New multi-master enabled value\n * @see getMultiMasterEnabled()\n * @see MPU9250_RA_I2C_MST_CTRL\n */\nvoid MPU9250::setMultiMasterEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_I2C_MST_CTRL, MPU9250_MULT_MST_EN_BIT, enabled);\n}\n/** Get wait-for-external-sensor-data enabled value.\n * When the WAIT_FOR_ES bit is set to 1, the Data Ready interrupt will be\n * delayed until External Sensor data from the Slave Devices are loaded into the\n * EXT_SENS_DATA registers. This is used to ensure that both the internal sensor\n * data (i.e. from gyro and accel) and external sensor data have been loaded to\n * their respective data registers (i.e. the data is synced) when the Data Ready\n * interrupt is triggered.\n *\n * @return Current wait-for-external-sensor-data enabled value\n * @see MPU9250_RA_I2C_MST_CTRL\n */\nbool MPU9250::getWaitForExternalSensorEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_I2C_MST_CTRL, MPU9250_WAIT_FOR_ES_BIT, buffer);\n    return buffer[0];\n}\n/** Set wait-for-external-sensor-data enabled value.\n * @param enabled New wait-for-external-sensor-data enabled value\n * @see getWaitForExternalSensorEnabled()\n * @see MPU9250_RA_I2C_MST_CTRL\n */\nvoid MPU9250::setWaitForExternalSensorEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_I2C_MST_CTRL, MPU9250_WAIT_FOR_ES_BIT, enabled);\n}\n/** Get Slave 3 FIFO enabled value.\n * When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96)\n * associated with Slave 3 to be written into the FIFO buffer.\n * @return Current Slave 3 FIFO enabled value\n * @see MPU9250_RA_MST_CTRL\n */\nbool MPU9250::getSlave3FIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_I2C_MST_CTRL, MPU9250_SLV_3_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set Slave 3 FIFO enabled value.\n * @param enabled New Slave 3 FIFO enabled value\n * @see getSlave3FIFOEnabled()\n * @see MPU9250_RA_MST_CTRL\n */\nvoid MPU9250::setSlave3FIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_I2C_MST_CTRL, MPU9250_SLV_3_FIFO_EN_BIT, enabled);\n}\n/** Get slave read/write transition enabled value.\n * The I2C_MST_P_NSR bit configures the I2C Master's transition from one slave\n * read to the next slave read. If the bit equals 0, there will be a restart\n * between reads. If the bit equals 1, there will be a stop followed by a start\n * of the following read. When a write transaction follows a read transaction,\n * the stop followed by a start of the successive write will be always used.\n *\n * @return Current slave read/write transition enabled value\n * @see MPU9250_RA_I2C_MST_CTRL\n */\nbool MPU9250::getSlaveReadWriteTransitionEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_I2C_MST_CTRL, MPU9250_I2C_MST_P_NSR_BIT, buffer);\n    return buffer[0];\n}\n/** Set slave read/write transition enabled value.\n * @param enabled New slave read/write transition enabled value\n * @see getSlaveReadWriteTransitionEnabled()\n * @see MPU9250_RA_I2C_MST_CTRL\n */\nvoid MPU9250::setSlaveReadWriteTransitionEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_I2C_MST_CTRL, MPU9250_I2C_MST_P_NSR_BIT, enabled);\n}\n/** Get I2C master clock speed.\n * I2C_MST_CLK is a 4 bit unsigned value which configures a divider on the\n * MPU-60X0 internal 8MHz clock. It sets the I2C master clock speed according to\n * the following table:\n *\n * <pre>\n * I2C_MST_CLK | I2C Master Clock Speed | 8MHz Clock Divider\n * ------------+------------------------+-------------------\n * 0           | 348kHz                 | 23\n * 1           | 333kHz                 | 24\n * 2           | 320kHz                 | 25\n * 3           | 308kHz                 | 26\n * 4           | 296kHz                 | 27\n * 5           | 286kHz                 | 28\n * 6           | 276kHz                 | 29\n * 7           | 267kHz                 | 30\n * 8           | 258kHz                 | 31\n * 9           | 500kHz                 | 16\n * 10          | 471kHz                 | 17\n * 11          | 444kHz                 | 18\n * 12          | 421kHz                 | 19\n * 13          | 400kHz                 | 20\n * 14          | 381kHz                 | 21\n * 15          | 364kHz                 | 22\n * </pre>\n *\n * @return Current I2C master clock speed\n * @see MPU9250_RA_I2C_MST_CTRL\n */\nuint8_t MPU9250::getMasterClockSpeed() {\n    I2Cdev::readBits(devAddr, MPU9250_RA_I2C_MST_CTRL, MPU9250_I2C_MST_CLK_BIT, MPU9250_I2C_MST_CLK_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set I2C master clock speed.\n * @reparam speed Current I2C master clock speed\n * @see MPU9250_RA_I2C_MST_CTRL\n */\nvoid MPU9250::setMasterClockSpeed(uint8_t speed) {\n    I2Cdev::writeBits(devAddr, MPU9250_RA_I2C_MST_CTRL, MPU9250_I2C_MST_CLK_BIT, MPU9250_I2C_MST_CLK_LENGTH, speed);\n}\n\n// I2C_SLV* registers (Slave 0-3)\n\n/** Get the I2C address of the specified slave (0-3).\n * Note that Bit 7 (MSB) controls read/write mode. If Bit 7 is set, it's a read\n * operation, and if it is cleared, then it's a write operation. The remaining\n * bits (6-0) are the 7-bit device address of the slave device.\n *\n * In read mode, the result of the read is placed in the lowest available \n * EXT_SENS_DATA register. For further information regarding the allocation of\n * read results, please refer to the EXT_SENS_DATA register description\n * (Registers 73 - 96).\n *\n * The MPU-9250 supports a total of five slaves, but Slave 4 has unique\n * characteristics, and so it has its own functions (getSlave4* and setSlave4*).\n *\n * I2C data transactions are performed at the Sample Rate, as defined in\n * Register 25. The user is responsible for ensuring that I2C data transactions\n * to and from each enabled Slave can be completed within a single period of the\n * Sample Rate.\n *\n * The I2C slave access rate can be reduced relative to the Sample Rate. This\n * reduced access rate is determined by I2C_MST_DLY (Register 52). Whether a\n * slave's access rate is reduced relative to the Sample Rate is determined by\n * I2C_MST_DELAY_CTRL (Register 103).\n *\n * The processing order for the slaves is fixed. The sequence followed for\n * processing the slaves is Slave 0, Slave 1, Slave 2, Slave 3 and Slave 4. If a\n * particular Slave is disabled it will be skipped.\n *\n * Each slave can either be accessed at the sample rate or at a reduced sample\n * rate. In a case where some slaves are accessed at the Sample Rate and some\n * slaves are accessed at the reduced rate, the sequence of accessing the slaves\n * (Slave 0 to Slave 4) is still followed. However, the reduced rate slaves will\n * be skipped if their access rate dictates that they should not be accessed\n * during that particular cycle. For further information regarding the reduced\n * access rate, please refer to Register 52. Whether a slave is accessed at the\n * Sample Rate or at the reduced rate is determined by the Delay Enable bits in\n * Register 103.\n *\n * @param num Slave number (0-3)\n * @return Current address for specified slave\n * @see MPU9250_RA_I2C_SLV0_ADDR\n */\nuint8_t MPU9250::getSlaveAddress(uint8_t num) {\n    if (num > 3) return 0;\n    I2Cdev::readByte(devAddr, MPU9250_RA_I2C_SLV0_ADDR + num*3, buffer);\n    return buffer[0];\n}\n/** Set the I2C address of the specified slave (0-3).\n * @param num Slave number (0-3)\n * @param address New address for specified slave\n * @see getSlaveAddress()\n * @see MPU9250_RA_I2C_SLV0_ADDR\n */\nvoid MPU9250::setSlaveAddress(uint8_t num, uint8_t address) {\n    if (num > 3) return;\n    I2Cdev::writeByte(devAddr, MPU9250_RA_I2C_SLV0_ADDR + num*3, address);\n}\n/** Get the active internal register for the specified slave (0-3).\n * Read/write operations for this slave will be done to whatever internal\n * register address is stored in this MPU register.\n *\n * The MPU-9250 supports a total of five slaves, but Slave 4 has unique\n * characteristics, and so it has its own functions.\n *\n * @param num Slave number (0-3)\n * @return Current active register for specified slave\n * @see MPU9250_RA_I2C_SLV0_REG\n */\nuint8_t MPU9250::getSlaveRegister(uint8_t num) {\n    if (num > 3) return 0;\n    I2Cdev::readByte(devAddr, MPU9250_RA_I2C_SLV0_REG + num*3, buffer);\n    return buffer[0];\n}\n/** Set the active internal register for the specified slave (0-3).\n * @param num Slave number (0-3)\n * @param reg New active register for specified slave\n * @see getSlaveRegister()\n * @see MPU9250_RA_I2C_SLV0_REG\n */\nvoid MPU9250::setSlaveRegister(uint8_t num, uint8_t reg) {\n    if (num > 3) return;\n    I2Cdev::writeByte(devAddr, MPU9250_RA_I2C_SLV0_REG + num*3, reg);\n}\n/** Get the enabled value for the specified slave (0-3).\n * When set to 1, this bit enables Slave 0 for data transfer operations. When\n * cleared to 0, this bit disables Slave 0 from data transfer operations.\n * @param num Slave number (0-3)\n * @return Current enabled value for specified slave\n * @see MPU9250_RA_I2C_SLV0_CTRL\n */\nbool MPU9250::getSlaveEnabled(uint8_t num) {\n    if (num > 3) return 0;\n    I2Cdev::readBit(devAddr, MPU9250_RA_I2C_SLV0_CTRL + num*3, MPU9250_I2C_SLV_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set the enabled value for the specified slave (0-3).\n * @param num Slave number (0-3)\n * @param enabled New enabled value for specified slave\n * @see getSlaveEnabled()\n * @see MPU9250_RA_I2C_SLV0_CTRL\n */\nvoid MPU9250::setSlaveEnabled(uint8_t num, bool enabled) {\n    if (num > 3) return;\n    I2Cdev::writeBit(devAddr, MPU9250_RA_I2C_SLV0_CTRL + num*3, MPU9250_I2C_SLV_EN_BIT, enabled);\n}\n/** Get word pair byte-swapping enabled for the specified slave (0-3).\n * When set to 1, this bit enables byte swapping. When byte swapping is enabled,\n * the high and low bytes of a word pair are swapped. Please refer to\n * I2C_SLV0_GRP for the pairing convention of the word pairs. When cleared to 0,\n * bytes transferred to and from Slave 0 will be written to EXT_SENS_DATA\n * registers in the order they were transferred.\n *\n * @param num Slave number (0-3)\n * @return Current word pair byte-swapping enabled value for specified slave\n * @see MPU9250_RA_I2C_SLV0_CTRL\n */\nbool MPU9250::getSlaveWordByteSwap(uint8_t num) {\n    if (num > 3) return 0;\n    I2Cdev::readBit(devAddr, MPU9250_RA_I2C_SLV0_CTRL + num*3, MPU9250_I2C_SLV_BYTE_SW_BIT, buffer);\n    return buffer[0];\n}\n/** Set word pair byte-swapping enabled for the specified slave (0-3).\n * @param num Slave number (0-3)\n * @param enabled New word pair byte-swapping enabled value for specified slave\n * @see getSlaveWordByteSwap()\n * @see MPU9250_RA_I2C_SLV0_CTRL\n */\nvoid MPU9250::setSlaveWordByteSwap(uint8_t num, bool enabled) {\n    if (num > 3) return;\n    I2Cdev::writeBit(devAddr, MPU9250_RA_I2C_SLV0_CTRL + num*3, MPU9250_I2C_SLV_BYTE_SW_BIT, enabled);\n}\n/** Get write mode for the specified slave (0-3).\n * When set to 1, the transaction will read or write data only. When cleared to\n * 0, the transaction will write a register address prior to reading or writing\n * data. This should equal 0 when specifying the register address within the\n * Slave device to/from which the ensuing data transaction will take place.\n *\n * @param num Slave number (0-3)\n * @return Current write mode for specified slave (0 = register address + data, 1 = data only)\n * @see MPU9250_RA_I2C_SLV0_CTRL\n */\nbool MPU9250::getSlaveWriteMode(uint8_t num) {\n    if (num > 3) return 0;\n    I2Cdev::readBit(devAddr, MPU9250_RA_I2C_SLV0_CTRL + num*3, MPU9250_I2C_SLV_REG_DIS_BIT, buffer);\n    return buffer[0];\n}\n/** Set write mode for the specified slave (0-3).\n * @param num Slave number (0-3)\n * @param mode New write mode for specified slave (0 = register address + data, 1 = data only)\n * @see getSlaveWriteMode()\n * @see MPU9250_RA_I2C_SLV0_CTRL\n */\nvoid MPU9250::setSlaveWriteMode(uint8_t num, bool mode) {\n    if (num > 3) return;\n    I2Cdev::writeBit(devAddr, MPU9250_RA_I2C_SLV0_CTRL + num*3, MPU9250_I2C_SLV_REG_DIS_BIT, mode);\n}\n/** Get word pair grouping order offset for the specified slave (0-3).\n * This sets specifies the grouping order of word pairs received from registers.\n * When cleared to 0, bytes from register addresses 0 and 1, 2 and 3, etc (even,\n * then odd register addresses) are paired to form a word. When set to 1, bytes\n * from register addresses are paired 1 and 2, 3 and 4, etc. (odd, then even\n * register addresses) are paired to form a word.\n *\n * @param num Slave number (0-3)\n * @return Current word pair grouping order offset for specified slave\n * @see MPU9250_RA_I2C_SLV0_CTRL\n */\nbool MPU9250::getSlaveWordGroupOffset(uint8_t num) {\n    if (num > 3) return 0;\n    I2Cdev::readBit(devAddr, MPU9250_RA_I2C_SLV0_CTRL + num*3, MPU9250_I2C_SLV_GRP_BIT, buffer);\n    return buffer[0];\n}\n/** Set word pair grouping order offset for the specified slave (0-3).\n * @param num Slave number (0-3)\n * @param enabled New word pair grouping order offset for specified slave\n * @see getSlaveWordGroupOffset()\n * @see MPU9250_RA_I2C_SLV0_CTRL\n */\nvoid MPU9250::setSlaveWordGroupOffset(uint8_t num, bool enabled) {\n    if (num > 3) return;\n    I2Cdev::writeBit(devAddr, MPU9250_RA_I2C_SLV0_CTRL + num*3, MPU9250_I2C_SLV_GRP_BIT, enabled);\n}\n/** Get number of bytes to read for the specified slave (0-3).\n * Specifies the number of bytes transferred to and from Slave 0. Clearing this\n * bit to 0 is equivalent to disabling the register by writing 0 to I2C_SLV0_EN.\n * @param num Slave number (0-3)\n * @return Number of bytes to read for specified slave\n * @see MPU9250_RA_I2C_SLV0_CTRL\n */\nuint8_t MPU9250::getSlaveDataLength(uint8_t num) {\n    if (num > 3) return 0;\n    I2Cdev::readBits(devAddr, MPU9250_RA_I2C_SLV0_CTRL + num*3, MPU9250_I2C_SLV_LEN_BIT, MPU9250_I2C_SLV_LEN_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set number of bytes to read for the specified slave (0-3).\n * @param num Slave number (0-3)\n * @param length Number of bytes to read for specified slave\n * @see getSlaveDataLength()\n * @see MPU9250_RA_I2C_SLV0_CTRL\n */\nvoid MPU9250::setSlaveDataLength(uint8_t num, uint8_t length) {\n    if (num > 3) return;\n    I2Cdev::writeBits(devAddr, MPU9250_RA_I2C_SLV0_CTRL + num*3, MPU9250_I2C_SLV_LEN_BIT, MPU9250_I2C_SLV_LEN_LENGTH, length);\n}\n\n// I2C_SLV* registers (Slave 4)\n\n/** Get the I2C address of Slave 4.\n * Note that Bit 7 (MSB) controls read/write mode. If Bit 7 is set, it's a read\n * operation, and if it is cleared, then it's a write operation. The remaining\n * bits (6-0) are the 7-bit device address of the slave device.\n *\n * @return Current address for Slave 4\n * @see getSlaveAddress()\n * @see MPU9250_RA_I2C_SLV4_ADDR\n */\nuint8_t MPU9250::getSlave4Address() {\n    I2Cdev::readByte(devAddr, MPU9250_RA_I2C_SLV4_ADDR, buffer);\n    return buffer[0];\n}\n/** Set the I2C address of Slave 4.\n * @param address New address for Slave 4\n * @see getSlave4Address()\n * @see MPU9250_RA_I2C_SLV4_ADDR\n */\nvoid MPU9250::setSlave4Address(uint8_t address) {\n    I2Cdev::writeByte(devAddr, MPU9250_RA_I2C_SLV4_ADDR, address);\n}\n/** Get the active internal register for the Slave 4.\n * Read/write operations for this slave will be done to whatever internal\n * register address is stored in this MPU register.\n *\n * @return Current active register for Slave 4\n * @see MPU9250_RA_I2C_SLV4_REG\n */\nuint8_t MPU9250::getSlave4Register() {\n    I2Cdev::readByte(devAddr, MPU9250_RA_I2C_SLV4_REG, buffer);\n    return buffer[0];\n}\n/** Set the active internal register for Slave 4.\n * @param reg New active register for Slave 4\n * @see getSlave4Register()\n * @see MPU9250_RA_I2C_SLV4_REG\n */\nvoid MPU9250::setSlave4Register(uint8_t reg) {\n    I2Cdev::writeByte(devAddr, MPU9250_RA_I2C_SLV4_REG, reg);\n}\n/** Set new byte to write to Slave 4.\n * This register stores the data to be written into the Slave 4. If I2C_SLV4_RW\n * is set 1 (set to read), this register has no effect.\n * @param data New byte to write to Slave 4\n * @see MPU9250_RA_I2C_SLV4_DO\n */\nvoid MPU9250::setSlave4OutputByte(uint8_t data) {\n    I2Cdev::writeByte(devAddr, MPU9250_RA_I2C_SLV4_DO, data);\n}\n/** Get the enabled value for the Slave 4.\n * When set to 1, this bit enables Slave 4 for data transfer operations. When\n * cleared to 0, this bit disables Slave 4 from data transfer operations.\n * @return Current enabled value for Slave 4\n * @see MPU9250_RA_I2C_SLV4_CTRL\n */\nbool MPU9250::getSlave4Enabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_I2C_SLV4_CTRL, MPU9250_I2C_SLV4_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set the enabled value for Slave 4.\n * @param enabled New enabled value for Slave 4\n * @see getSlave4Enabled()\n * @see MPU9250_RA_I2C_SLV4_CTRL\n */\nvoid MPU9250::setSlave4Enabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_I2C_SLV4_CTRL, MPU9250_I2C_SLV4_EN_BIT, enabled);\n}\n/** Get the enabled value for Slave 4 transaction interrupts.\n * When set to 1, this bit enables the generation of an interrupt signal upon\n * completion of a Slave 4 transaction. When cleared to 0, this bit disables the\n * generation of an interrupt signal upon completion of a Slave 4 transaction.\n * The interrupt status can be observed in Register 54.\n *\n * @return Current enabled value for Slave 4 transaction interrupts.\n * @see MPU9250_RA_I2C_SLV4_CTRL\n */\nbool MPU9250::getSlave4InterruptEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_I2C_SLV4_CTRL, MPU9250_I2C_SLV4_INT_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set the enabled value for Slave 4 transaction interrupts.\n * @param enabled New enabled value for Slave 4 transaction interrupts.\n * @see getSlave4InterruptEnabled()\n * @see MPU9250_RA_I2C_SLV4_CTRL\n */\nvoid MPU9250::setSlave4InterruptEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_I2C_SLV4_CTRL, MPU9250_I2C_SLV4_INT_EN_BIT, enabled);\n}\n/** Get write mode for Slave 4.\n * When set to 1, the transaction will read or write data only. When cleared to\n * 0, the transaction will write a register address prior to reading or writing\n * data. This should equal 0 when specifying the register address within the\n * Slave device to/from which the ensuing data transaction will take place.\n *\n * @return Current write mode for Slave 4 (0 = register address + data, 1 = data only)\n * @see MPU9250_RA_I2C_SLV4_CTRL\n */\nbool MPU9250::getSlave4WriteMode() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_I2C_SLV4_CTRL, MPU9250_I2C_SLV4_REG_DIS_BIT, buffer);\n    return buffer[0];\n}\n/** Set write mode for the Slave 4.\n * @param mode New write mode for Slave 4 (0 = register address + data, 1 = data only)\n * @see getSlave4WriteMode()\n * @see MPU9250_RA_I2C_SLV4_CTRL\n */\nvoid MPU9250::setSlave4WriteMode(bool mode) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_I2C_SLV4_CTRL, MPU9250_I2C_SLV4_REG_DIS_BIT, mode);\n}\n/** Get Slave 4 master delay value.\n * This configures the reduced access rate of I2C slaves relative to the Sample\n * Rate. When a slave's access rate is decreased relative to the Sample Rate,\n * the slave is accessed every:\n *\n *     1 / (1 + I2C_MST_DLY) samples\n *\n * This base Sample Rate in turn is determined by SMPLRT_DIV (register 25) and\n * DLPF_CFG (register 26). Whether a slave's access rate is reduced relative to\n * the Sample Rate is determined by I2C_MST_DELAY_CTRL (register 103). For\n * further information regarding the Sample Rate, please refer to register 25.\n *\n * @return Current Slave 4 master delay value\n * @see MPU9250_RA_I2C_SLV4_CTRL\n */\nuint8_t MPU9250::getSlave4MasterDelay() {\n    I2Cdev::readBits(devAddr, MPU9250_RA_I2C_SLV4_CTRL, MPU9250_I2C_SLV4_MST_DLY_BIT, MPU9250_I2C_SLV4_MST_DLY_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set Slave 4 master delay value.\n * @param delay New Slave 4 master delay value\n * @see getSlave4MasterDelay()\n * @see MPU9250_RA_I2C_SLV4_CTRL\n */\nvoid MPU9250::setSlave4MasterDelay(uint8_t delay) {\n    I2Cdev::writeBits(devAddr, MPU9250_RA_I2C_SLV4_CTRL, MPU9250_I2C_SLV4_MST_DLY_BIT, MPU9250_I2C_SLV4_MST_DLY_LENGTH, delay);\n}\n/** Get last available byte read from Slave 4.\n * This register stores the data read from Slave 4. This field is populated\n * after a read transaction.\n * @return Last available byte read from to Slave 4\n * @see MPU9250_RA_I2C_SLV4_DI\n */\nuint8_t MPU9250::getSlate4InputByte() {\n    I2Cdev::readByte(devAddr, MPU9250_RA_I2C_SLV4_DI, buffer);\n    return buffer[0];\n}\n\n// I2C_MST_STATUS register\n\n/** Get FSYNC interrupt status.\n * This bit reflects the status of the FSYNC interrupt from an external device\n * into the MPU-60X0. This is used as a way to pass an external interrupt\n * through the MPU-60X0 to the host application processor. When set to 1, this\n * bit will cause an interrupt if FSYNC_INT_EN is asserted in INT_PIN_CFG\n * (Register 55).\n * @return FSYNC interrupt status\n * @see MPU9250_RA_I2C_MST_STATUS\n */\nbool MPU9250::getPassthroughStatus() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_I2C_MST_STATUS, MPU9250_MST_PASS_THROUGH_BIT, buffer);\n    return buffer[0];\n}\n/** Get Slave 4 transaction done status.\n * Automatically sets to 1 when a Slave 4 transaction has completed. This\n * triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register\n * (Register 56) is asserted and if the SLV_4_DONE_INT bit is asserted in the\n * I2C_SLV4_CTRL register (Register 52).\n * @return Slave 4 transaction done status\n * @see MPU9250_RA_I2C_MST_STATUS\n */\nbool MPU9250::getSlave4IsDone() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_I2C_MST_STATUS, MPU9250_MST_I2C_SLV4_DONE_BIT, buffer);\n    return buffer[0];\n}\n/** Get master arbitration lost status.\n * This bit automatically sets to 1 when the I2C Master has lost arbitration of\n * the auxiliary I2C bus (an error condition). This triggers an interrupt if the\n * I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted.\n * @return Master arbitration lost status\n * @see MPU9250_RA_I2C_MST_STATUS\n */\nbool MPU9250::getLostArbitration() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_I2C_MST_STATUS, MPU9250_MST_I2C_LOST_ARB_BIT, buffer);\n    return buffer[0];\n}\n/** Get Slave 4 NACK status.\n * This bit automatically sets to 1 when the I2C Master receives a NACK in a\n * transaction with Slave 4. This triggers an interrupt if the I2C_MST_INT_EN\n * bit in the INT_ENABLE register (Register 56) is asserted.\n * @return Slave 4 NACK interrupt status\n * @see MPU9250_RA_I2C_MST_STATUS\n */\nbool MPU9250::getSlave4Nack() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_I2C_MST_STATUS, MPU9250_MST_I2C_SLV4_NACK_BIT, buffer);\n    return buffer[0];\n}\n/** Get Slave 3 NACK status.\n * This bit automatically sets to 1 when the I2C Master receives a NACK in a\n * transaction with Slave 3. This triggers an interrupt if the I2C_MST_INT_EN\n * bit in the INT_ENABLE register (Register 56) is asserted.\n * @return Slave 3 NACK interrupt status\n * @see MPU9250_RA_I2C_MST_STATUS\n */\nbool MPU9250::getSlave3Nack() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_I2C_MST_STATUS, MPU9250_MST_I2C_SLV3_NACK_BIT, buffer);\n    return buffer[0];\n}\n/** Get Slave 2 NACK status.\n * This bit automatically sets to 1 when the I2C Master receives a NACK in a\n * transaction with Slave 2. This triggers an interrupt if the I2C_MST_INT_EN\n * bit in the INT_ENABLE register (Register 56) is asserted.\n * @return Slave 2 NACK interrupt status\n * @see MPU9250_RA_I2C_MST_STATUS\n */\nbool MPU9250::getSlave2Nack() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_I2C_MST_STATUS, MPU9250_MST_I2C_SLV2_NACK_BIT, buffer);\n    return buffer[0];\n}\n/** Get Slave 1 NACK status.\n * This bit automatically sets to 1 when the I2C Master receives a NACK in a\n * transaction with Slave 1. This triggers an interrupt if the I2C_MST_INT_EN\n * bit in the INT_ENABLE register (Register 56) is asserted.\n * @return Slave 1 NACK interrupt status\n * @see MPU9250_RA_I2C_MST_STATUS\n */\nbool MPU9250::getSlave1Nack() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_I2C_MST_STATUS, MPU9250_MST_I2C_SLV1_NACK_BIT, buffer);\n    return buffer[0];\n}\n/** Get Slave 0 NACK status.\n * This bit automatically sets to 1 when the I2C Master receives a NACK in a\n * transaction with Slave 0. This triggers an interrupt if the I2C_MST_INT_EN\n * bit in the INT_ENABLE register (Register 56) is asserted.\n * @return Slave 0 NACK interrupt status\n * @see MPU9250_RA_I2C_MST_STATUS\n */\nbool MPU9250::getSlave0Nack() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_I2C_MST_STATUS, MPU9250_MST_I2C_SLV0_NACK_BIT, buffer);\n    return buffer[0];\n}\n\n// INT_PIN_CFG register\n\n/** Get interrupt logic level mode.\n * Will be set 0 for active-high, 1 for active-low.\n * @return Current interrupt mode (0=active-high, 1=active-low)\n * @see MPU9250_RA_INT_PIN_CFG\n * @see MPU9250_INTCFG_INT_LEVEL_BIT\n */\nbool MPU9250::getInterruptMode() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_INT_PIN_CFG, MPU9250_INTCFG_INT_LEVEL_BIT, buffer);\n    return buffer[0];\n}\n/** Set interrupt logic level mode.\n * @param mode New interrupt mode (0=active-high, 1=active-low)\n * @see getInterruptMode()\n * @see MPU9250_RA_INT_PIN_CFG\n * @see MPU9250_INTCFG_INT_LEVEL_BIT\n */\nvoid MPU9250::setInterruptMode(bool mode) {\n   I2Cdev::writeBit(devAddr, MPU9250_RA_INT_PIN_CFG, MPU9250_INTCFG_INT_LEVEL_BIT, mode);\n}\n/** Get interrupt drive mode.\n * Will be set 0 for push-pull, 1 for open-drain.\n * @return Current interrupt drive mode (0=push-pull, 1=open-drain)\n * @see MPU9250_RA_INT_PIN_CFG\n * @see MPU9250_INTCFG_INT_OPEN_BIT\n */\nbool MPU9250::getInterruptDrive() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_INT_PIN_CFG, MPU9250_INTCFG_INT_OPEN_BIT, buffer);\n    return buffer[0];\n}\n/** Set interrupt drive mode.\n * @param drive New interrupt drive mode (0=push-pull, 1=open-drain)\n * @see getInterruptDrive()\n * @see MPU9250_RA_INT_PIN_CFG\n * @see MPU9250_INTCFG_INT_OPEN_BIT\n */\nvoid MPU9250::setInterruptDrive(bool drive) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_INT_PIN_CFG, MPU9250_INTCFG_INT_OPEN_BIT, drive);\n}\n/** Get interrupt latch mode.\n * Will be set 0 for 50us-pulse, 1 for latch-until-int-cleared.\n * @return Current latch mode (0=50us-pulse, 1=latch-until-int-cleared)\n * @see MPU9250_RA_INT_PIN_CFG\n * @see MPU9250_INTCFG_LATCH_INT_EN_BIT\n */\nbool MPU9250::getInterruptLatch() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_INT_PIN_CFG, MPU9250_INTCFG_LATCH_INT_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set interrupt latch mode.\n * @param latch New latch mode (0=50us-pulse, 1=latch-until-int-cleared)\n * @see getInterruptLatch()\n * @see MPU9250_RA_INT_PIN_CFG\n * @see MPU9250_INTCFG_LATCH_INT_EN_BIT\n */\nvoid MPU9250::setInterruptLatch(bool latch) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_INT_PIN_CFG, MPU9250_INTCFG_LATCH_INT_EN_BIT, latch);\n}\n/** Get interrupt latch clear mode.\n * Will be set 0 for status-read-only, 1 for any-register-read.\n * @return Current latch clear mode (0=status-read-only, 1=any-register-read)\n * @see MPU9250_RA_INT_PIN_CFG\n * @see MPU9250_INTCFG_INT_RD_CLEAR_BIT\n */\nbool MPU9250::getInterruptLatchClear() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_INT_PIN_CFG, MPU9250_INTCFG_INT_RD_CLEAR_BIT, buffer);\n    return buffer[0];\n}\n/** Set interrupt latch clear mode.\n * @param clear New latch clear mode (0=status-read-only, 1=any-register-read)\n * @see getInterruptLatchClear()\n * @see MPU9250_RA_INT_PIN_CFG\n * @see MPU9250_INTCFG_INT_RD_CLEAR_BIT\n */\nvoid MPU9250::setInterruptLatchClear(bool clear) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_INT_PIN_CFG, MPU9250_INTCFG_INT_RD_CLEAR_BIT, clear);\n}\n/** Get FSYNC interrupt logic level mode.\n * @return Current FSYNC interrupt mode (0=active-high, 1=active-low)\n * @see getFSyncInterruptMode()\n * @see MPU9250_RA_INT_PIN_CFG\n * @see MPU9250_INTCFG_FSYNC_INT_LEVEL_BIT\n */\nbool MPU9250::getFSyncInterruptLevel() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_INT_PIN_CFG, MPU9250_INTCFG_FSYNC_INT_LEVEL_BIT, buffer);\n    return buffer[0];\n}\n/** Set FSYNC interrupt logic level mode.\n * @param mode New FSYNC interrupt mode (0=active-high, 1=active-low)\n * @see getFSyncInterruptMode()\n * @see MPU9250_RA_INT_PIN_CFG\n * @see MPU9250_INTCFG_FSYNC_INT_LEVEL_BIT\n */\nvoid MPU9250::setFSyncInterruptLevel(bool level) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_INT_PIN_CFG, MPU9250_INTCFG_FSYNC_INT_LEVEL_BIT, level);\n}\n/** Get FSYNC pin interrupt enabled setting.\n * Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled setting\n * @see MPU9250_RA_INT_PIN_CFG\n * @see MPU9250_INTCFG_FSYNC_INT_EN_BIT\n */\nbool MPU9250::getFSyncInterruptEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_INT_PIN_CFG, MPU9250_INTCFG_FSYNC_INT_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set FSYNC pin interrupt enabled setting.\n * @param enabled New FSYNC pin interrupt enabled setting\n * @see getFSyncInterruptEnabled()\n * @see MPU9250_RA_INT_PIN_CFG\n * @see MPU9250_INTCFG_FSYNC_INT_EN_BIT\n */\nvoid MPU9250::setFSyncInterruptEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_INT_PIN_CFG, MPU9250_INTCFG_FSYNC_INT_EN_BIT, enabled);\n}\n/** Get I2C bypass enabled status.\n * When this bit is equal to 1 and I2C_MST_EN (Register 106 bit[5]) is equal to\n * 0, the host application processor will be able to directly access the\n * auxiliary I2C bus of the MPU-60X0. When this bit is equal to 0, the host\n * application processor will not be able to directly access the auxiliary I2C\n * bus of the MPU-60X0 regardless of the state of I2C_MST_EN (Register 106\n * bit[5]).\n * @return Current I2C bypass enabled status\n * @see MPU9250_RA_INT_PIN_CFG\n * @see MPU9250_INTCFG_I2C_BYPASS_EN_BIT\n */\nbool MPU9250::getI2CBypassEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_INT_PIN_CFG, MPU9250_INTCFG_I2C_BYPASS_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set I2C bypass enabled status.\n * When this bit is equal to 1 and I2C_MST_EN (Register 106 bit[5]) is equal to\n * 0, the host application processor will be able to directly access the\n * auxiliary I2C bus of the MPU-60X0. When this bit is equal to 0, the host\n * application processor will not be able to directly access the auxiliary I2C\n * bus of the MPU-60X0 regardless of the state of I2C_MST_EN (Register 106\n * bit[5]).\n * @param enabled New I2C bypass enabled status\n * @see MPU9250_RA_INT_PIN_CFG\n * @see MPU9250_INTCFG_I2C_BYPASS_EN_BIT\n */\nvoid MPU9250::setI2CBypassEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_INT_PIN_CFG, MPU9250_INTCFG_I2C_BYPASS_EN_BIT, enabled);\n}\n/** Get reference clock output enabled status.\n * When this bit is equal to 1, a reference clock output is provided at the\n * CLKOUT pin. When this bit is equal to 0, the clock output is disabled. For\n * further information regarding CLKOUT, please refer to the MPU-60X0 Product\n * Specification document.\n * @return Current reference clock output enabled status\n * @see MPU9250_RA_INT_PIN_CFG\n * @see MPU9250_INTCFG_CLKOUT_EN_BIT\n */\nbool MPU9250::getClockOutputEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_INT_PIN_CFG, MPU9250_INTCFG_CLKOUT_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set reference clock output enabled status.\n * When this bit is equal to 1, a reference clock output is provided at the\n * CLKOUT pin. When this bit is equal to 0, the clock output is disabled. For\n * further information regarding CLKOUT, please refer to the MPU-60X0 Product\n * Specification document.\n * @param enabled New reference clock output enabled status\n * @see MPU9250_RA_INT_PIN_CFG\n * @see MPU9250_INTCFG_CLKOUT_EN_BIT\n */\nvoid MPU9250::setClockOutputEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_INT_PIN_CFG, MPU9250_INTCFG_CLKOUT_EN_BIT, enabled);\n}\n\n// INT_ENABLE register\n\n/** Get full interrupt enabled status.\n * Full register byte for all interrupts, for quick reading. Each bit will be\n * set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see MPU9250_RA_INT_ENABLE\n * @see MPU9250_INTERRUPT_FF_BIT\n **/\nuint8_t MPU9250::getIntEnabled() {\n    I2Cdev::readByte(devAddr, MPU9250_RA_INT_ENABLE, buffer);\n    return buffer[0];\n}\n/** Set full interrupt enabled status.\n * Full register byte for all interrupts, for quick reading. Each bit should be\n * set 0 for disabled, 1 for enabled.\n * @param enabled New interrupt enabled status\n * @see getIntFreefallEnabled()\n * @see MPU9250_RA_INT_ENABLE\n * @see MPU9250_INTERRUPT_FF_BIT\n **/\nvoid MPU9250::setIntEnabled(uint8_t enabled) {\n    I2Cdev::writeByte(devAddr, MPU9250_RA_INT_ENABLE, enabled);\n}\n/** Get Free Fall interrupt enabled status.\n * Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see MPU9250_RA_INT_ENABLE\n * @see MPU9250_INTERRUPT_FF_BIT\n **/\nbool MPU9250::getIntFreefallEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_INT_ENABLE, MPU9250_INTERRUPT_FF_BIT, buffer);\n    return buffer[0];\n}\n/** Set Free Fall interrupt enabled status.\n * @param enabled New interrupt enabled status\n * @see getIntFreefallEnabled()\n * @see MPU9250_RA_INT_ENABLE\n * @see MPU9250_INTERRUPT_FF_BIT\n **/\nvoid MPU9250::setIntFreefallEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_INT_ENABLE, MPU9250_INTERRUPT_FF_BIT, enabled);\n}\n/** Get Motion Detection interrupt enabled status.\n * Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see MPU9250_RA_INT_ENABLE\n * @see MPU9250_INTERRUPT_MOT_BIT\n **/\nbool MPU9250::getIntMotionEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_INT_ENABLE, MPU9250_INTERRUPT_MOT_BIT, buffer);\n    return buffer[0];\n}\n/** Set Motion Detection interrupt enabled status.\n * @param enabled New interrupt enabled status\n * @see getIntMotionEnabled()\n * @see MPU9250_RA_INT_ENABLE\n * @see MPU9250_INTERRUPT_MOT_BIT\n **/\nvoid MPU9250::setIntMotionEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_INT_ENABLE, MPU9250_INTERRUPT_MOT_BIT, enabled);\n}\n/** Get Zero Motion Detection interrupt enabled status.\n * Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see MPU9250_RA_INT_ENABLE\n * @see MPU9250_INTERRUPT_ZMOT_BIT\n **/\nbool MPU9250::getIntZeroMotionEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_INT_ENABLE, MPU9250_INTERRUPT_ZMOT_BIT, buffer);\n    return buffer[0];\n}\n/** Set Zero Motion Detection interrupt enabled status.\n * @param enabled New interrupt enabled status\n * @see getIntZeroMotionEnabled()\n * @see MPU9250_RA_INT_ENABLE\n * @see MPU9250_INTERRUPT_ZMOT_BIT\n **/\nvoid MPU9250::setIntZeroMotionEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_INT_ENABLE, MPU9250_INTERRUPT_ZMOT_BIT, enabled);\n}\n/** Get FIFO Buffer Overflow interrupt enabled status.\n * Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see MPU9250_RA_INT_ENABLE\n * @see MPU9250_INTERRUPT_FIFO_OFLOW_BIT\n **/\nbool MPU9250::getIntFIFOBufferOverflowEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_INT_ENABLE, MPU9250_INTERRUPT_FIFO_OFLOW_BIT, buffer);\n    return buffer[0];\n}\n/** Set FIFO Buffer Overflow interrupt enabled status.\n * @param enabled New interrupt enabled status\n * @see getIntFIFOBufferOverflowEnabled()\n * @see MPU9250_RA_INT_ENABLE\n * @see MPU9250_INTERRUPT_FIFO_OFLOW_BIT\n **/\nvoid MPU9250::setIntFIFOBufferOverflowEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_INT_ENABLE, MPU9250_INTERRUPT_FIFO_OFLOW_BIT, enabled);\n}\n/** Get I2C Master interrupt enabled status.\n * This enables any of the I2C Master interrupt sources to generate an\n * interrupt. Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see MPU9250_RA_INT_ENABLE\n * @see MPU9250_INTERRUPT_I2C_MST_INT_BIT\n **/\nbool MPU9250::getIntI2CMasterEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_INT_ENABLE, MPU9250_INTERRUPT_I2C_MST_INT_BIT, buffer);\n    return buffer[0];\n}\n/** Set I2C Master interrupt enabled status.\n * @param enabled New interrupt enabled status\n * @see getIntI2CMasterEnabled()\n * @see MPU9250_RA_INT_ENABLE\n * @see MPU9250_INTERRUPT_I2C_MST_INT_BIT\n **/\nvoid MPU9250::setIntI2CMasterEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_INT_ENABLE, MPU9250_INTERRUPT_I2C_MST_INT_BIT, enabled);\n}\n/** Get Data Ready interrupt enabled setting.\n * This event occurs each time a write operation to all of the sensor registers\n * has been completed. Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see MPU9250_RA_INT_ENABLE\n * @see MPU9250_INTERRUPT_DATA_RDY_BIT\n */\nbool MPU9250::getIntDataReadyEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_INT_ENABLE, MPU9250_INTERRUPT_DATA_RDY_BIT, buffer);\n    return buffer[0];\n}\n/** Set Data Ready interrupt enabled status.\n * @param enabled New interrupt enabled status\n * @see getIntDataReadyEnabled()\n * @see MPU9250_RA_INT_CFG\n * @see MPU9250_INTERRUPT_DATA_RDY_BIT\n */\nvoid MPU9250::setIntDataReadyEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_INT_ENABLE, MPU9250_INTERRUPT_DATA_RDY_BIT, enabled);\n}\n\n// INT_STATUS register\n\n/** Get full set of interrupt status bits.\n * These bits clear to 0 after the register has been read. Very useful\n * for getting multiple INT statuses, since each single bit read clears\n * all of them because it has to read the whole byte.\n * @return Current interrupt status\n * @see MPU9250_RA_INT_STATUS\n */\nuint8_t MPU9250::getIntStatus() {\n    I2Cdev::readByte(devAddr, MPU9250_RA_INT_STATUS, buffer);\n    return buffer[0];\n}\n/** Get Free Fall interrupt status.\n * This bit automatically sets to 1 when a Free Fall interrupt has been\n * generated. The bit clears to 0 after the register has been read.\n * @return Current interrupt status\n * @see MPU9250_RA_INT_STATUS\n * @see MPU9250_INTERRUPT_FF_BIT\n */\nbool MPU9250::getIntFreefallStatus() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_INT_STATUS, MPU9250_INTERRUPT_FF_BIT, buffer);\n    return buffer[0];\n}\n/** Get Motion Detection interrupt status.\n * This bit automatically sets to 1 when a Motion Detection interrupt has been\n * generated. The bit clears to 0 after the register has been read.\n * @return Current interrupt status\n * @see MPU9250_RA_INT_STATUS\n * @see MPU9250_INTERRUPT_MOT_BIT\n */\nbool MPU9250::getIntMotionStatus() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_INT_STATUS, MPU9250_INTERRUPT_MOT_BIT, buffer);\n    return buffer[0];\n}\n/** Get Zero Motion Detection interrupt status.\n * This bit automatically sets to 1 when a Zero Motion Detection interrupt has\n * been generated. The bit clears to 0 after the register has been read.\n * @return Current interrupt status\n * @see MPU9250_RA_INT_STATUS\n * @see MPU9250_INTERRUPT_ZMOT_BIT\n */\nbool MPU9250::getIntZeroMotionStatus() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_INT_STATUS, MPU9250_INTERRUPT_ZMOT_BIT, buffer);\n    return buffer[0];\n}\n/** Get FIFO Buffer Overflow interrupt status.\n * This bit automatically sets to 1 when a Free Fall interrupt has been\n * generated. The bit clears to 0 after the register has been read.\n * @return Current interrupt status\n * @see MPU9250_RA_INT_STATUS\n * @see MPU9250_INTERRUPT_FIFO_OFLOW_BIT\n */\nbool MPU9250::getIntFIFOBufferOverflowStatus() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_INT_STATUS, MPU9250_INTERRUPT_FIFO_OFLOW_BIT, buffer);\n    return buffer[0];\n}\n/** Get I2C Master interrupt status.\n * This bit automatically sets to 1 when an I2C Master interrupt has been\n * generated. For a list of I2C Master interrupts, please refer to Register 54.\n * The bit clears to 0 after the register has been read.\n * @return Current interrupt status\n * @see MPU9250_RA_INT_STATUS\n * @see MPU9250_INTERRUPT_I2C_MST_INT_BIT\n */\nbool MPU9250::getIntI2CMasterStatus() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_INT_STATUS, MPU9250_INTERRUPT_I2C_MST_INT_BIT, buffer);\n    return buffer[0];\n}\n/** Get Data Ready interrupt status.\n * This bit automatically sets to 1 when a Data Ready interrupt has been\n * generated. The bit clears to 0 after the register has been read.\n * @return Current interrupt status\n * @see MPU9250_RA_INT_STATUS\n * @see MPU9250_INTERRUPT_DATA_RDY_BIT\n */\nbool MPU9250::getIntDataReadyStatus() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_INT_STATUS, MPU9250_INTERRUPT_DATA_RDY_BIT, buffer);\n    return buffer[0];\n}\n\n// ACCEL_*OUT_* registers\n\n/** Get raw 9-axis motion sensor readings (accel/gyro/compass).\n * FUNCTION NOT FULLY IMPLEMENTED YET.\n * @param ax 16-bit signed integer container for accelerometer X-axis value\n * @param ay 16-bit signed integer container for accelerometer Y-axis value\n * @param az 16-bit signed integer container for accelerometer Z-axis value\n * @param gx 16-bit signed integer container for gyroscope X-axis value\n * @param gy 16-bit signed integer container for gyroscope Y-axis value\n * @param gz 16-bit signed integer container for gyroscope Z-axis value\n * @param mx 16-bit signed integer container for magnetometer X-axis value\n * @param my 16-bit signed integer container for magnetometer Y-axis value\n * @param mz 16-bit signed integer container for magnetometer Z-axis value\n * @see getMotion6()\n * @see getAcceleration()\n * @see getRotation()\n * @see MPU9250_RA_ACCEL_XOUT_H\n */\nvoid MPU9250::getMotion9(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz, int16_t* mx, int16_t* my, int16_t* mz) {\n    \n\t//get accel and gyro\n\tgetMotion6(ax, ay, az, gx, gy, gz);\n\t\n\t//read mag\n\tI2Cdev::writeByte(devAddr, MPU9250_RA_INT_PIN_CFG, 0x02); //set i2c bypass enable pin to true to access magnetometer\n\tdelay(10);\n\tI2Cdev::writeByte(MPU9150_RA_MAG_ADDRESS, 0x0A, 0x01); //enable the magnetometer\n\tdelay(10);\n\tI2Cdev::readBytes(MPU9150_RA_MAG_ADDRESS, MPU9150_RA_MAG_XOUT_L, 6, buffer);\n\t*mx = (((int16_t)buffer[1]) << 8) | buffer[0];\n    *my = (((int16_t)buffer[3]) << 8) | buffer[2];\n    *mz = (((int16_t)buffer[5]) << 8) | buffer[4];\t\t\n}\n\nvoid MPU9250::getMag(int16_t* mx, int16_t* my, int16_t* mz) {\n    \n\t//get accel and gyro\n\t//getMotion6(ax, ay, az, gx, gy, gz);\n\t\n\t//read mag\n\tI2Cdev::writeByte(devAddr, MPU9250_RA_INT_PIN_CFG, 0x02); //set i2c bypass enable pin to true to access magnetometer\n\tdelay(10);\n\tI2Cdev::writeByte(MPU9150_RA_MAG_ADDRESS, 0x0A, 0x01); //enable the magnetometer\n\tdelay(10);\n\tI2Cdev::readBytes(MPU9150_RA_MAG_ADDRESS, MPU9150_RA_MAG_XOUT_L, 6, buffer);\n\t*mx = (((int16_t)buffer[1]) << 8) | buffer[0];\n    *my = (((int16_t)buffer[3]) << 8) | buffer[2];\n    *mz = (((int16_t)buffer[5]) << 8) | buffer[4];\t\t\n}\n\n/** Get raw 6-axis motion sensor readings (accel/gyro).\n * Retrieves all currently available motion sensor values.\n * @param ax 16-bit signed integer container for accelerometer X-axis value\n * @param ay 16-bit signed integer container for accelerometer Y-axis value\n * @param az 16-bit signed integer container for accelerometer Z-axis value\n * @param gx 16-bit signed integer container for gyroscope X-axis value\n * @param gy 16-bit signed integer container for gyroscope Y-axis value\n * @param gz 16-bit signed integer container for gyroscope Z-axis value\n * @see getAcceleration()\n * @see getRotation()\n * @see MPU9250_RA_ACCEL_XOUT_H\n */\nvoid MPU9250::getMotion6(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz) {\n    I2Cdev::readBytes(devAddr, MPU9250_RA_ACCEL_XOUT_H, 14, buffer);\n    *ax = (((int16_t)buffer[0]) << 8) | buffer[1];\n    *ay = (((int16_t)buffer[2]) << 8) | buffer[3];\n    *az = (((int16_t)buffer[4]) << 8) | buffer[5];\n    *gx = (((int16_t)buffer[8]) << 8) | buffer[9];\n    *gy = (((int16_t)buffer[10]) << 8) | buffer[11];\n    *gz = (((int16_t)buffer[12]) << 8) | buffer[13];\n}\n/** Get 3-axis accelerometer readings.\n * These registers store the most recent accelerometer measurements.\n * Accelerometer measurements are written to these registers at the Sample Rate\n * as defined in Register 25.\n *\n * The accelerometer measurement registers, along with the temperature\n * measurement registers, gyroscope measurement registers, and external sensor\n * data registers, are composed of two sets of registers: an internal register\n * set and a user-facing read register set.\n *\n * The data within the accelerometer sensors' internal register set is always\n * updated at the Sample Rate. Meanwhile, the user-facing read register set\n * duplicates the internal register set's data values whenever the serial\n * interface is idle. This guarantees that a burst read of sensor registers will\n * read measurements from the same sampling instant. Note that if burst reads\n * are not used, the user is responsible for ensuring a set of single byte reads\n * correspond to a single sampling instant by checking the Data Ready interrupt.\n *\n * Each 16-bit accelerometer measurement has a full scale defined in ACCEL_FS\n * (Register 28). For each full scale setting, the accelerometers' sensitivity\n * per LSB in ACCEL_xOUT is shown in the table below:\n *\n * <pre>\n * AFS_SEL | Full Scale Range | LSB Sensitivity\n * --------+------------------+----------------\n * 0       | +/- 2g           | 8192 LSB/mg\n * 1       | +/- 4g           | 4096 LSB/mg\n * 2       | +/- 8g           | 2048 LSB/mg\n * 3       | +/- 16g          | 1024 LSB/mg\n * </pre>\n *\n * @param x 16-bit signed integer container for X-axis acceleration\n * @param y 16-bit signed integer container for Y-axis acceleration\n * @param z 16-bit signed integer container for Z-axis acceleration\n * @see MPU9250_RA_GYRO_XOUT_H\n */\nvoid MPU9250::getAcceleration(int16_t* x, int16_t* y, int16_t* z) {\n    I2Cdev::readBytes(devAddr, MPU9250_RA_ACCEL_XOUT_H, 6, buffer);\n    *x = (((int16_t)buffer[0]) << 8) | buffer[1];\n    *y = (((int16_t)buffer[2]) << 8) | buffer[3];\n    *z = (((int16_t)buffer[4]) << 8) | buffer[5];\n}\n/** Get X-axis accelerometer reading.\n * @return X-axis acceleration measurement in 16-bit 2's complement format\n * @see getMotion6()\n * @see MPU9250_RA_ACCEL_XOUT_H\n */\nint16_t MPU9250::getAccelerationX() {\n    I2Cdev::readBytes(devAddr, MPU9250_RA_ACCEL_XOUT_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\n/** Get Y-axis accelerometer reading.\n * @return Y-axis acceleration measurement in 16-bit 2's complement format\n * @see getMotion6()\n * @see MPU9250_RA_ACCEL_YOUT_H\n */\nint16_t MPU9250::getAccelerationY() {\n    I2Cdev::readBytes(devAddr, MPU9250_RA_ACCEL_YOUT_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\n/** Get Z-axis accelerometer reading.\n * @return Z-axis acceleration measurement in 16-bit 2's complement format\n * @see getMotion6()\n * @see MPU9250_RA_ACCEL_ZOUT_H\n */\nint16_t MPU9250::getAccelerationZ() {\n    I2Cdev::readBytes(devAddr, MPU9250_RA_ACCEL_ZOUT_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\n\n// TEMP_OUT_* registers\n\n/** Get current internal temperature.\n * @return Temperature reading in 16-bit 2's complement format\n * @see MPU9250_RA_TEMP_OUT_H\n */\nint16_t MPU9250::getTemperature() {\n    I2Cdev::readBytes(devAddr, MPU9250_RA_TEMP_OUT_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\n\n// GYRO_*OUT_* registers\n\n/** Get 3-axis gyroscope readings.\n * These gyroscope measurement registers, along with the accelerometer\n * measurement registers, temperature measurement registers, and external sensor\n * data registers, are composed of two sets of registers: an internal register\n * set and a user-facing read register set.\n * The data within the gyroscope sensors' internal register set is always\n * updated at the Sample Rate. Meanwhile, the user-facing read register set\n * duplicates the internal register set's data values whenever the serial\n * interface is idle. This guarantees that a burst read of sensor registers will\n * read measurements from the same sampling instant. Note that if burst reads\n * are not used, the user is responsible for ensuring a set of single byte reads\n * correspond to a single sampling instant by checking the Data Ready interrupt.\n *\n * Each 16-bit gyroscope measurement has a full scale defined in FS_SEL\n * (Register 27). For each full scale setting, the gyroscopes' sensitivity per\n * LSB in GYRO_xOUT is shown in the table below:\n *\n * <pre>\n * FS_SEL | Full Scale Range   | LSB Sensitivity\n * -------+--------------------+----------------\n * 0      | +/- 250 degrees/s  | 131 LSB/deg/s\n * 1      | +/- 500 degrees/s  | 65.5 LSB/deg/s\n * 2      | +/- 1000 degrees/s | 32.8 LSB/deg/s\n * 3      | +/- 2000 degrees/s | 16.4 LSB/deg/s\n * </pre>\n *\n * @param x 16-bit signed integer container for X-axis rotation\n * @param y 16-bit signed integer container for Y-axis rotation\n * @param z 16-bit signed integer container for Z-axis rotation\n * @see getMotion6()\n * @see MPU9250_RA_GYRO_XOUT_H\n */\nvoid MPU9250::getRotation(int16_t* x, int16_t* y, int16_t* z) {\n    I2Cdev::readBytes(devAddr, MPU9250_RA_GYRO_XOUT_H, 6, buffer);\n    *x = (((int16_t)buffer[0]) << 8) | buffer[1];\n    *y = (((int16_t)buffer[2]) << 8) | buffer[3];\n    *z = (((int16_t)buffer[4]) << 8) | buffer[5];\n}\n/** Get X-axis gyroscope reading.\n * @return X-axis rotation measurement in 16-bit 2's complement format\n * @see getMotion6()\n * @see MPU9250_RA_GYRO_XOUT_H\n */\nint16_t MPU9250::getRotationX() {\n    I2Cdev::readBytes(devAddr, MPU9250_RA_GYRO_XOUT_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\n/** Get Y-axis gyroscope reading.\n * @return Y-axis rotation measurement in 16-bit 2's complement format\n * @see getMotion6()\n * @see MPU9250_RA_GYRO_YOUT_H\n */\nint16_t MPU9250::getRotationY() {\n    I2Cdev::readBytes(devAddr, MPU9250_RA_GYRO_YOUT_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\n/** Get Z-axis gyroscope reading.\n * @return Z-axis rotation measurement in 16-bit 2's complement format\n * @see getMotion6()\n * @see MPU9250_RA_GYRO_ZOUT_H\n */\nint16_t MPU9250::getRotationZ() {\n    I2Cdev::readBytes(devAddr, MPU9250_RA_GYRO_ZOUT_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\n\n// EXT_SENS_DATA_* registers\n\n/** Read single byte from external sensor data register.\n * These registers store data read from external sensors by the Slave 0, 1, 2,\n * and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in\n * I2C_SLV4_DI (Register 53).\n *\n * External sensor data is written to these registers at the Sample Rate as\n * defined in Register 25. This access rate can be reduced by using the Slave\n * Delay Enable registers (Register 103).\n *\n * External sensor data registers, along with the gyroscope measurement\n * registers, accelerometer measurement registers, and temperature measurement\n * registers, are composed of two sets of registers: an internal register set\n * and a user-facing read register set.\n *\n * The data within the external sensors' internal register set is always updated\n * at the Sample Rate (or the reduced access rate) whenever the serial interface\n * is idle. This guarantees that a burst read of sensor registers will read\n * measurements from the same sampling instant. Note that if burst reads are not\n * used, the user is responsible for ensuring a set of single byte reads\n * correspond to a single sampling instant by checking the Data Ready interrupt.\n *\n * Data is placed in these external sensor data registers according to\n * I2C_SLV0_CTRL, I2C_SLV1_CTRL, I2C_SLV2_CTRL, and I2C_SLV3_CTRL (Registers 39,\n * 42, 45, and 48). When more than zero bytes are read (I2C_SLVx_LEN > 0) from\n * an enabled slave (I2C_SLVx_EN = 1), the slave is read at the Sample Rate (as\n * defined in Register 25) or delayed rate (if specified in Register 52 and\n * 103). During each Sample cycle, slave reads are performed in order of Slave\n * number. If all slaves are enabled with more than zero bytes to be read, the\n * order will be Slave 0, followed by Slave 1, Slave 2, and Slave 3.\n *\n * Each enabled slave will have EXT_SENS_DATA registers associated with it by\n * number of bytes read (I2C_SLVx_LEN) in order of slave number, starting from\n * EXT_SENS_DATA_00. Note that this means enabling or disabling a slave may\n * change the higher numbered slaves' associated registers. Furthermore, if\n * fewer total bytes are being read from the external sensors as a result of\n * such a change, then the data remaining in the registers which no longer have\n * an associated slave device (i.e. high numbered registers) will remain in\n * these previously allocated registers unless reset.\n *\n * If the sum of the read lengths of all SLVx transactions exceed the number of\n * available EXT_SENS_DATA registers, the excess bytes will be dropped. There\n * are 24 EXT_SENS_DATA registers and hence the total read lengths between all\n * the slaves cannot be greater than 24 or some bytes will be lost.\n *\n * Note: Slave 4's behavior is distinct from that of Slaves 0-3. For further\n * information regarding the characteristics of Slave 4, please refer to\n * Registers 49 to 53.\n *\n * EXAMPLE:\n * Suppose that Slave 0 is enabled with 4 bytes to be read (I2C_SLV0_EN = 1 and\n * I2C_SLV0_LEN = 4) while Slave 1 is enabled with 2 bytes to be read so that\n * I2C_SLV1_EN = 1 and I2C_SLV1_LEN = 2. In such a situation, EXT_SENS_DATA _00\n * through _03 will be associated with Slave 0, while EXT_SENS_DATA _04 and 05\n * will be associated with Slave 1. If Slave 2 is enabled as well, registers\n * starting from EXT_SENS_DATA_06 will be allocated to Slave 2.\n *\n * If Slave 2 is disabled while Slave 3 is enabled in this same situation, then\n * registers starting from EXT_SENS_DATA_06 will be allocated to Slave 3\n * instead.\n *\n * REGISTER ALLOCATION FOR DYNAMIC DISABLE VS. NORMAL DISABLE:\n * If a slave is disabled at any time, the space initially allocated to the\n * slave in the EXT_SENS_DATA register, will remain associated with that slave.\n * This is to avoid dynamic adjustment of the register allocation.\n *\n * The allocation of the EXT_SENS_DATA registers is recomputed only when (1) all\n * slaves are disabled, or (2) the I2C_MST_RST bit is set (Register 106).\n *\n * This above is also true if one of the slaves gets NACKed and stops\n * functioning.\n *\n * @param position Starting position (0-23)\n * @return Byte read from register\n */\nuint8_t MPU9250::getExternalSensorByte(int position) {\n    I2Cdev::readByte(devAddr, MPU9250_RA_EXT_SENS_DATA_00 + position, buffer);\n    return buffer[0];\n}\n/** Read word (2 bytes) from external sensor data registers.\n * @param position Starting position (0-21)\n * @return Word read from register\n * @see getExternalSensorByte()\n */\nuint16_t MPU9250::getExternalSensorWord(int position) {\n    I2Cdev::readBytes(devAddr, MPU9250_RA_EXT_SENS_DATA_00 + position, 2, buffer);\n    return (((uint16_t)buffer[0]) << 8) | buffer[1];\n}\n/** Read double word (4 bytes) from external sensor data registers.\n * @param position Starting position (0-20)\n * @return Double word read from registers\n * @see getExternalSensorByte()\n */\nuint32_t MPU9250::getExternalSensorDWord(int position) {\n    I2Cdev::readBytes(devAddr, MPU9250_RA_EXT_SENS_DATA_00 + position, 4, buffer);\n    return (((uint32_t)buffer[0]) << 24) | (((uint32_t)buffer[1]) << 16) | (((uint16_t)buffer[2]) << 8) | buffer[3];\n}\n\n// MOT_DETECT_STATUS register\n\n/** Get X-axis negative motion detection interrupt status.\n * @return Motion detection status\n * @see MPU9250_RA_MOT_DETECT_STATUS\n * @see MPU9250_MOTION_MOT_XNEG_BIT\n */\nbool MPU9250::getXNegMotionDetected() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_MOT_DETECT_STATUS, MPU9250_MOTION_MOT_XNEG_BIT, buffer);\n    return buffer[0];\n}\n/** Get X-axis positive motion detection interrupt status.\n * @return Motion detection status\n * @see MPU9250_RA_MOT_DETECT_STATUS\n * @see MPU9250_MOTION_MOT_XPOS_BIT\n */\nbool MPU9250::getXPosMotionDetected() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_MOT_DETECT_STATUS, MPU9250_MOTION_MOT_XPOS_BIT, buffer);\n    return buffer[0];\n}\n/** Get Y-axis negative motion detection interrupt status.\n * @return Motion detection status\n * @see MPU9250_RA_MOT_DETECT_STATUS\n * @see MPU9250_MOTION_MOT_YNEG_BIT\n */\nbool MPU9250::getYNegMotionDetected() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_MOT_DETECT_STATUS, MPU9250_MOTION_MOT_YNEG_BIT, buffer);\n    return buffer[0];\n}\n/** Get Y-axis positive motion detection interrupt status.\n * @return Motion detection status\n * @see MPU9250_RA_MOT_DETECT_STATUS\n * @see MPU9250_MOTION_MOT_YPOS_BIT\n */\nbool MPU9250::getYPosMotionDetected() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_MOT_DETECT_STATUS, MPU9250_MOTION_MOT_YPOS_BIT, buffer);\n    return buffer[0];\n}\n/** Get Z-axis negative motion detection interrupt status.\n * @return Motion detection status\n * @see MPU9250_RA_MOT_DETECT_STATUS\n * @see MPU9250_MOTION_MOT_ZNEG_BIT\n */\nbool MPU9250::getZNegMotionDetected() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_MOT_DETECT_STATUS, MPU9250_MOTION_MOT_ZNEG_BIT, buffer);\n    return buffer[0];\n}\n/** Get Z-axis positive motion detection interrupt status.\n * @return Motion detection status\n * @see MPU9250_RA_MOT_DETECT_STATUS\n * @see MPU9250_MOTION_MOT_ZPOS_BIT\n */\nbool MPU9250::getZPosMotionDetected() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_MOT_DETECT_STATUS, MPU9250_MOTION_MOT_ZPOS_BIT, buffer);\n    return buffer[0];\n}\n/** Get zero motion detection interrupt status.\n * @return Motion detection status\n * @see MPU9250_RA_MOT_DETECT_STATUS\n * @see MPU9250_MOTION_MOT_ZRMOT_BIT\n */\nbool MPU9250::getZeroMotionDetected() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_MOT_DETECT_STATUS, MPU9250_MOTION_MOT_ZRMOT_BIT, buffer);\n    return buffer[0];\n}\n\n// I2C_SLV*_DO register\n\n/** Write byte to Data Output container for specified slave.\n * This register holds the output data written into Slave when Slave is set to\n * write mode. For further information regarding Slave control, please\n * refer to Registers 37 to 39 and immediately following.\n * @param num Slave number (0-3)\n * @param data Byte to write\n * @see MPU9250_RA_I2C_SLV0_DO\n */\nvoid MPU9250::setSlaveOutputByte(uint8_t num, uint8_t data) {\n    if (num > 3) return;\n    I2Cdev::writeByte(devAddr, MPU9250_RA_I2C_SLV0_DO + num, data);\n}\n\n// I2C_MST_DELAY_CTRL register\n\n/** Get external data shadow delay enabled status.\n * This register is used to specify the timing of external sensor data\n * shadowing. When DELAY_ES_SHADOW is set to 1, shadowing of external\n * sensor data is delayed until all data has been received.\n * @return Current external data shadow delay enabled status.\n * @see MPU9250_RA_I2C_MST_DELAY_CTRL\n * @see MPU9250_DELAYCTRL_DELAY_ES_SHADOW_BIT\n */\nbool MPU9250::getExternalShadowDelayEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_I2C_MST_DELAY_CTRL, MPU9250_DELAYCTRL_DELAY_ES_SHADOW_BIT, buffer);\n    return buffer[0];\n}\n/** Set external data shadow delay enabled status.\n * @param enabled New external data shadow delay enabled status.\n * @see getExternalShadowDelayEnabled()\n * @see MPU9250_RA_I2C_MST_DELAY_CTRL\n * @see MPU9250_DELAYCTRL_DELAY_ES_SHADOW_BIT\n */\nvoid MPU9250::setExternalShadowDelayEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_I2C_MST_DELAY_CTRL, MPU9250_DELAYCTRL_DELAY_ES_SHADOW_BIT, enabled);\n}\n/** Get slave delay enabled status.\n * When a particular slave delay is enabled, the rate of access for the that\n * slave device is reduced. When a slave's access rate is decreased relative to\n * the Sample Rate, the slave is accessed every:\n *\n *     1 / (1 + I2C_MST_DLY) Samples\n *\n * This base Sample Rate in turn is determined by SMPLRT_DIV (register  * 25)\n * and DLPF_CFG (register 26).\n *\n * For further information regarding I2C_MST_DLY, please refer to register 52.\n * For further information regarding the Sample Rate, please refer to register 25.\n *\n * @param num Slave number (0-4)\n * @return Current slave delay enabled status.\n * @see MPU9250_RA_I2C_MST_DELAY_CTRL\n * @see MPU9250_DELAYCTRL_I2C_SLV0_DLY_EN_BIT\n */\nbool MPU9250::getSlaveDelayEnabled(uint8_t num) {\n    // MPU9250_DELAYCTRL_I2C_SLV4_DLY_EN_BIT is 4, SLV3 is 3, etc.\n    if (num > 4) return 0;\n    I2Cdev::readBit(devAddr, MPU9250_RA_I2C_MST_DELAY_CTRL, num, buffer);\n    return buffer[0];\n}\n/** Set slave delay enabled status.\n * @param num Slave number (0-4)\n * @param enabled New slave delay enabled status.\n * @see MPU9250_RA_I2C_MST_DELAY_CTRL\n * @see MPU9250_DELAYCTRL_I2C_SLV0_DLY_EN_BIT\n */\nvoid MPU9250::setSlaveDelayEnabled(uint8_t num, bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_I2C_MST_DELAY_CTRL, num, enabled);\n}\n\n// SIGNAL_PATH_RESET register\n\n/** Reset gyroscope signal path.\n * The reset will revert the signal path analog to digital converters and\n * filters to their power up configurations.\n * @see MPU9250_RA_SIGNAL_PATH_RESET\n * @see MPU9250_PATHRESET_GYRO_RESET_BIT\n */\nvoid MPU9250::resetGyroscopePath() {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_SIGNAL_PATH_RESET, MPU9250_PATHRESET_GYRO_RESET_BIT, true);\n}\n/** Reset accelerometer signal path.\n * The reset will revert the signal path analog to digital converters and\n * filters to their power up configurations.\n * @see MPU9250_RA_SIGNAL_PATH_RESET\n * @see MPU9250_PATHRESET_ACCEL_RESET_BIT\n */\nvoid MPU9250::resetAccelerometerPath() {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_SIGNAL_PATH_RESET, MPU9250_PATHRESET_ACCEL_RESET_BIT, true);\n}\n/** Reset temperature sensor signal path.\n * The reset will revert the signal path analog to digital converters and\n * filters to their power up configurations.\n * @see MPU9250_RA_SIGNAL_PATH_RESET\n * @see MPU9250_PATHRESET_TEMP_RESET_BIT\n */\nvoid MPU9250::resetTemperaturePath() {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_SIGNAL_PATH_RESET, MPU9250_PATHRESET_TEMP_RESET_BIT, true);\n}\n\n// MOT_DETECT_CTRL register\n\n/** Get accelerometer power-on delay.\n * The accelerometer data path provides samples to the sensor registers, Motion\n * detection, Zero Motion detection, and Free Fall detection modules. The\n * signal path contains filters which must be flushed on wake-up with new\n * samples before the detection modules begin operations. The default wake-up\n * delay, of 4ms can be lengthened by up to 3ms. This additional delay is\n * specified in ACCEL_ON_DELAY in units of 1 LSB = 1 ms. The user may select\n * any value above zero unless instructed otherwise by InvenSense. Please refer\n * to Section 8 of the MPU-6000/MPU-9250 Product Specification document for\n * further information regarding the detection modules.\n * @return Current accelerometer power-on delay\n * @see MPU9250_RA_MOT_DETECT_CTRL\n * @see MPU9250_DETECT_ACCEL_ON_DELAY_BIT\n */\nuint8_t MPU9250::getAccelerometerPowerOnDelay() {\n    I2Cdev::readBits(devAddr, MPU9250_RA_MOT_DETECT_CTRL, MPU9250_DETECT_ACCEL_ON_DELAY_BIT, MPU9250_DETECT_ACCEL_ON_DELAY_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set accelerometer power-on delay.\n * @param delay New accelerometer power-on delay (0-3)\n * @see getAccelerometerPowerOnDelay()\n * @see MPU9250_RA_MOT_DETECT_CTRL\n * @see MPU9250_DETECT_ACCEL_ON_DELAY_BIT\n */\nvoid MPU9250::setAccelerometerPowerOnDelay(uint8_t delay) {\n    I2Cdev::writeBits(devAddr, MPU9250_RA_MOT_DETECT_CTRL, MPU9250_DETECT_ACCEL_ON_DELAY_BIT, MPU9250_DETECT_ACCEL_ON_DELAY_LENGTH, delay);\n}\n/** Get Free Fall detection counter decrement configuration.\n * Detection is registered by the Free Fall detection module after accelerometer\n * measurements meet their respective threshold conditions over a specified\n * number of samples. When the threshold conditions are met, the corresponding\n * detection counter increments by 1. The user may control the rate at which the\n * detection counter decrements when the threshold condition is not met by\n * configuring FF_COUNT. The decrement rate can be set according to the\n * following table:\n *\n * <pre>\n * FF_COUNT | Counter Decrement\n * ---------+------------------\n * 0        | Reset\n * 1        | 1\n * 2        | 2\n * 3        | 4\n * </pre>\n *\n * When FF_COUNT is configured to 0 (reset), any non-qualifying sample will\n * reset the counter to 0. For further information on Free Fall detection,\n * please refer to Registers 29 to 32.\n *\n * @return Current decrement configuration\n * @see MPU9250_RA_MOT_DETECT_CTRL\n * @see MPU9250_DETECT_FF_COUNT_BIT\n */\nuint8_t MPU9250::getFreefallDetectionCounterDecrement() {\n    I2Cdev::readBits(devAddr, MPU9250_RA_MOT_DETECT_CTRL, MPU9250_DETECT_FF_COUNT_BIT, MPU9250_DETECT_FF_COUNT_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set Free Fall detection counter decrement configuration.\n * @param decrement New decrement configuration value\n * @see getFreefallDetectionCounterDecrement()\n * @see MPU9250_RA_MOT_DETECT_CTRL\n * @see MPU9250_DETECT_FF_COUNT_BIT\n */\nvoid MPU9250::setFreefallDetectionCounterDecrement(uint8_t decrement) {\n    I2Cdev::writeBits(devAddr, MPU9250_RA_MOT_DETECT_CTRL, MPU9250_DETECT_FF_COUNT_BIT, MPU9250_DETECT_FF_COUNT_LENGTH, decrement);\n}\n/** Get Motion detection counter decrement configuration.\n * Detection is registered by the Motion detection module after accelerometer\n * measurements meet their respective threshold conditions over a specified\n * number of samples. When the threshold conditions are met, the corresponding\n * detection counter increments by 1. The user may control the rate at which the\n * detection counter decrements when the threshold condition is not met by\n * configuring MOT_COUNT. The decrement rate can be set according to the\n * following table:\n *\n * <pre>\n * MOT_COUNT | Counter Decrement\n * ----------+------------------\n * 0         | Reset\n * 1         | 1\n * 2         | 2\n * 3         | 4\n * </pre>\n *\n * When MOT_COUNT is configured to 0 (reset), any non-qualifying sample will\n * reset the counter to 0. For further information on Motion detection,\n * please refer to Registers 29 to 32.\n *\n */\nuint8_t MPU9250::getMotionDetectionCounterDecrement() {\n    I2Cdev::readBits(devAddr, MPU9250_RA_MOT_DETECT_CTRL, MPU9250_DETECT_MOT_COUNT_BIT, MPU9250_DETECT_MOT_COUNT_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set Motion detection counter decrement configuration.\n * @param decrement New decrement configuration value\n * @see getMotionDetectionCounterDecrement()\n * @see MPU9250_RA_MOT_DETECT_CTRL\n * @see MPU9250_DETECT_MOT_COUNT_BIT\n */\nvoid MPU9250::setMotionDetectionCounterDecrement(uint8_t decrement) {\n    I2Cdev::writeBits(devAddr, MPU9250_RA_MOT_DETECT_CTRL, MPU9250_DETECT_MOT_COUNT_BIT, MPU9250_DETECT_MOT_COUNT_LENGTH, decrement);\n}\n\n// USER_CTRL register\n\n/** Get FIFO enabled status.\n * When this bit is set to 0, the FIFO buffer is disabled. The FIFO buffer\n * cannot be written to or read from while disabled. The FIFO buffer's state\n * does not change unless the MPU-60X0 is power cycled.\n * @return Current FIFO enabled status\n * @see MPU9250_RA_USER_CTRL\n * @see MPU9250_USERCTRL_FIFO_EN_BIT\n */\nbool MPU9250::getFIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_USER_CTRL, MPU9250_USERCTRL_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set FIFO enabled status.\n * @param enabled New FIFO enabled status\n * @see getFIFOEnabled()\n * @see MPU9250_RA_USER_CTRL\n * @see MPU9250_USERCTRL_FIFO_EN_BIT\n */\nvoid MPU9250::setFIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_USER_CTRL, MPU9250_USERCTRL_FIFO_EN_BIT, enabled);\n}\n/** Get I2C Master Mode enabled status.\n * When this mode is enabled, the MPU-60X0 acts as the I2C Master to the\n * external sensor slave devices on the auxiliary I2C bus. When this bit is\n * cleared to 0, the auxiliary I2C bus lines (AUX_DA and AUX_CL) are logically\n * driven by the primary I2C bus (SDA and SCL). This is a precondition to\n * enabling Bypass Mode. For further information regarding Bypass Mode, please\n * refer to Register 55.\n * @return Current I2C Master Mode enabled status\n * @see MPU9250_RA_USER_CTRL\n * @see MPU9250_USERCTRL_I2C_MST_EN_BIT\n */\nbool MPU9250::getI2CMasterModeEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_USER_CTRL, MPU9250_USERCTRL_I2C_MST_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set I2C Master Mode enabled status.\n * @param enabled New I2C Master Mode enabled status\n * @see getI2CMasterModeEnabled()\n * @see MPU9250_RA_USER_CTRL\n * @see MPU9250_USERCTRL_I2C_MST_EN_BIT\n */\nvoid MPU9250::setI2CMasterModeEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_USER_CTRL, MPU9250_USERCTRL_I2C_MST_EN_BIT, enabled);\n}\n/** Switch from I2C to SPI mode (MPU-6000 only)\n * If this is set, the primary SPI interface will be enabled in place of the\n * disabled primary I2C interface.\n */\nvoid MPU9250::switchSPIEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_USER_CTRL, MPU9250_USERCTRL_I2C_IF_DIS_BIT, enabled);\n}\n/** Reset the FIFO.\n * This bit resets the FIFO buffer when set to 1 while FIFO_EN equals 0. This\n * bit automatically clears to 0 after the reset has been triggered.\n * @see MPU9250_RA_USER_CTRL\n * @see MPU9250_USERCTRL_FIFO_RESET_BIT\n */\nvoid MPU9250::resetFIFO() {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_USER_CTRL, MPU9250_USERCTRL_FIFO_RESET_BIT, true);\n}\n/** Reset the I2C Master.\n * This bit resets the I2C Master when set to 1 while I2C_MST_EN equals 0.\n * This bit automatically clears to 0 after the reset has been triggered.\n * @see MPU9250_RA_USER_CTRL\n * @see MPU9250_USERCTRL_I2C_MST_RESET_BIT\n */\nvoid MPU9250::resetI2CMaster() {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_USER_CTRL, MPU9250_USERCTRL_I2C_MST_RESET_BIT, true);\n}\n/** Reset all sensor registers and signal paths.\n * When set to 1, this bit resets the signal paths for all sensors (gyroscopes,\n * accelerometers, and temperature sensor). This operation will also clear the\n * sensor registers. This bit automatically clears to 0 after the reset has been\n * triggered.\n *\n * When resetting only the signal path (and not the sensor registers), please\n * use Register 104, SIGNAL_PATH_RESET.\n *\n * @see MPU9250_RA_USER_CTRL\n * @see MPU9250_USERCTRL_SIG_COND_RESET_BIT\n */\nvoid MPU9250::resetSensors() {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_USER_CTRL, MPU9250_USERCTRL_SIG_COND_RESET_BIT, true);\n}\n\n// PWR_MGMT_1 register\n\n/** Trigger a full device reset.\n * A small delay of ~50ms may be desirable after triggering a reset.\n * @see MPU9250_RA_PWR_MGMT_1\n * @see MPU9250_PWR1_DEVICE_RESET_BIT\n */\nvoid MPU9250::reset() {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_PWR_MGMT_1, MPU9250_PWR1_DEVICE_RESET_BIT, true);\n}\n/** Get sleep mode status.\n * Setting the SLEEP bit in the register puts the device into very low power\n * sleep mode. In this mode, only the serial interface and internal registers\n * remain active, allowing for a very low standby current. Clearing this bit\n * puts the device back into normal mode. To save power, the individual standby\n * selections for each of the gyros should be used if any gyro axis is not used\n * by the application.\n * @return Current sleep mode enabled status\n * @see MPU9250_RA_PWR_MGMT_1\n * @see MPU9250_PWR1_SLEEP_BIT\n */\nbool MPU9250::getSleepEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_PWR_MGMT_1, MPU9250_PWR1_SLEEP_BIT, buffer);\n    return buffer[0];\n}\n/** Set sleep mode status.\n * @param enabled New sleep mode enabled status\n * @see getSleepEnabled()\n * @see MPU9250_RA_PWR_MGMT_1\n * @see MPU9250_PWR1_SLEEP_BIT\n */\nvoid MPU9250::setSleepEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_PWR_MGMT_1, MPU9250_PWR1_SLEEP_BIT, enabled);\n}\n/** Get wake cycle enabled status.\n * When this bit is set to 1 and SLEEP is disabled, the MPU-60X0 will cycle\n * between sleep mode and waking up to take a single sample of data from active\n * sensors at a rate determined by LP_WAKE_CTRL (register 108).\n * @return Current sleep mode enabled status\n * @see MPU9250_RA_PWR_MGMT_1\n * @see MPU9250_PWR1_CYCLE_BIT\n */\nbool MPU9250::getWakeCycleEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_PWR_MGMT_1, MPU9250_PWR1_CYCLE_BIT, buffer);\n    return buffer[0];\n}\n/** Set wake cycle enabled status.\n * @param enabled New sleep mode enabled status\n * @see getWakeCycleEnabled()\n * @see MPU9250_RA_PWR_MGMT_1\n * @see MPU9250_PWR1_CYCLE_BIT\n */\nvoid MPU9250::setWakeCycleEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_PWR_MGMT_1, MPU9250_PWR1_CYCLE_BIT, enabled);\n}\n/** Get temperature sensor enabled status.\n * Control the usage of the internal temperature sensor.\n *\n * Note: this register stores the *disabled* value, but for consistency with the\n * rest of the code, the function is named and used with standard true/false\n * values to indicate whether the sensor is enabled or disabled, respectively.\n *\n * @return Current temperature sensor enabled status\n * @see MPU9250_RA_PWR_MGMT_1\n * @see MPU9250_PWR1_TEMP_DIS_BIT\n */\nbool MPU9250::getTempSensorEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_PWR_MGMT_1, MPU9250_PWR1_TEMP_DIS_BIT, buffer);\n    return buffer[0] == 0; // 1 is actually disabled here\n}\n/** Set temperature sensor enabled status.\n * Note: this register stores the *disabled* value, but for consistency with the\n * rest of the code, the function is named and used with standard true/false\n * values to indicate whether the sensor is enabled or disabled, respectively.\n *\n * @param enabled New temperature sensor enabled status\n * @see getTempSensorEnabled()\n * @see MPU9250_RA_PWR_MGMT_1\n * @see MPU9250_PWR1_TEMP_DIS_BIT\n */\nvoid MPU9250::setTempSensorEnabled(bool enabled) {\n    // 1 is actually disabled here\n    I2Cdev::writeBit(devAddr, MPU9250_RA_PWR_MGMT_1, MPU9250_PWR1_TEMP_DIS_BIT, !enabled);\n}\n/** Get clock source setting.\n * @return Current clock source setting\n * @see MPU9250_RA_PWR_MGMT_1\n * @see MPU9250_PWR1_CLKSEL_BIT\n * @see MPU9250_PWR1_CLKSEL_LENGTH\n */\nuint8_t MPU9250::getClockSource() {\n    I2Cdev::readBits(devAddr, MPU9250_RA_PWR_MGMT_1, MPU9250_PWR1_CLKSEL_BIT, MPU9250_PWR1_CLKSEL_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set clock source setting.\n * An internal 8MHz oscillator, gyroscope based clock, or external sources can\n * be selected as the MPU-60X0 clock source. When the internal 8 MHz oscillator\n * or an external source is chosen as the clock source, the MPU-60X0 can operate\n * in low power modes with the gyroscopes disabled.\n *\n * Upon power up, the MPU-60X0 clock source defaults to the internal oscillator.\n * However, it is highly recommended that the device be configured to use one of\n * the gyroscopes (or an external clock source) as the clock reference for\n * improved stability. The clock source can be selected according to the following table:\n *\n * <pre>\n * CLK_SEL | Clock Source\n * --------+--------------------------------------\n * 0       | Internal oscillator\n * 1       | PLL with X Gyro reference\n * 2       | PLL with Y Gyro reference\n * 3       | PLL with Z Gyro reference\n * 4       | PLL with external 32.768kHz reference\n * 5       | PLL with external 19.2MHz reference\n * 6       | Reserved\n * 7       | Stops the clock and keeps the timing generator in reset\n * </pre>\n *\n * @param source New clock source setting\n * @see getClockSource()\n * @see MPU9250_RA_PWR_MGMT_1\n * @see MPU9250_PWR1_CLKSEL_BIT\n * @see MPU9250_PWR1_CLKSEL_LENGTH\n */\nvoid MPU9250::setClockSource(uint8_t source) {\n    I2Cdev::writeBits(devAddr, MPU9250_RA_PWR_MGMT_1, MPU9250_PWR1_CLKSEL_BIT, MPU9250_PWR1_CLKSEL_LENGTH, source);\n}\n\n// PWR_MGMT_2 register\n\n/** Get wake frequency in Accel-Only Low Power Mode.\n * The MPU-60X0 can be put into Accerlerometer Only Low Power Mode by setting\n * PWRSEL to 1 in the Power Management 1 register (Register 107). In this mode,\n * the device will power off all devices except for the primary I2C interface,\n * waking only the accelerometer at fixed intervals to take a single\n * measurement. The frequency of wake-ups can be configured with LP_WAKE_CTRL\n * as shown below:\n *\n * <pre>\n * LP_WAKE_CTRL | Wake-up Frequency\n * -------------+------------------\n * 0            | 1.25 Hz\n * 1            | 2.5 Hz\n * 2            | 5 Hz\n * 3            | 10 Hz\n * <pre>\n *\n * For further information regarding the MPU-60X0's power modes, please refer to\n * Register 107.\n *\n * @return Current wake frequency\n * @see MPU9250_RA_PWR_MGMT_2\n */\nuint8_t MPU9250::getWakeFrequency() {\n    I2Cdev::readBits(devAddr, MPU9250_RA_PWR_MGMT_2, MPU9250_PWR2_LP_WAKE_CTRL_BIT, MPU9250_PWR2_LP_WAKE_CTRL_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set wake frequency in Accel-Only Low Power Mode.\n * @param frequency New wake frequency\n * @see MPU9250_RA_PWR_MGMT_2\n */\nvoid MPU9250::setWakeFrequency(uint8_t frequency) {\n    I2Cdev::writeBits(devAddr, MPU9250_RA_PWR_MGMT_2, MPU9250_PWR2_LP_WAKE_CTRL_BIT, MPU9250_PWR2_LP_WAKE_CTRL_LENGTH, frequency);\n}\n\n/** Get X-axis accelerometer standby enabled status.\n * If enabled, the X-axis will not gather or report data (or use power).\n * @return Current X-axis standby enabled status\n * @see MPU9250_RA_PWR_MGMT_2\n * @see MPU9250_PWR2_STBY_XA_BIT\n */\nbool MPU9250::getStandbyXAccelEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_PWR_MGMT_2, MPU9250_PWR2_STBY_XA_BIT, buffer);\n    return buffer[0];\n}\n/** Set X-axis accelerometer standby enabled status.\n * @param New X-axis standby enabled status\n * @see getStandbyXAccelEnabled()\n * @see MPU9250_RA_PWR_MGMT_2\n * @see MPU9250_PWR2_STBY_XA_BIT\n */\nvoid MPU9250::setStandbyXAccelEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_PWR_MGMT_2, MPU9250_PWR2_STBY_XA_BIT, enabled);\n}\n/** Get Y-axis accelerometer standby enabled status.\n * If enabled, the Y-axis will not gather or report data (or use power).\n * @return Current Y-axis standby enabled status\n * @see MPU9250_RA_PWR_MGMT_2\n * @see MPU9250_PWR2_STBY_YA_BIT\n */\nbool MPU9250::getStandbyYAccelEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_PWR_MGMT_2, MPU9250_PWR2_STBY_YA_BIT, buffer);\n    return buffer[0];\n}\n/** Set Y-axis accelerometer standby enabled status.\n * @param New Y-axis standby enabled status\n * @see getStandbyYAccelEnabled()\n * @see MPU9250_RA_PWR_MGMT_2\n * @see MPU9250_PWR2_STBY_YA_BIT\n */\nvoid MPU9250::setStandbyYAccelEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_PWR_MGMT_2, MPU9250_PWR2_STBY_YA_BIT, enabled);\n}\n/** Get Z-axis accelerometer standby enabled status.\n * If enabled, the Z-axis will not gather or report data (or use power).\n * @return Current Z-axis standby enabled status\n * @see MPU9250_RA_PWR_MGMT_2\n * @see MPU9250_PWR2_STBY_ZA_BIT\n */\nbool MPU9250::getStandbyZAccelEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_PWR_MGMT_2, MPU9250_PWR2_STBY_ZA_BIT, buffer);\n    return buffer[0];\n}\n/** Set Z-axis accelerometer standby enabled status.\n * @param New Z-axis standby enabled status\n * @see getStandbyZAccelEnabled()\n * @see MPU9250_RA_PWR_MGMT_2\n * @see MPU9250_PWR2_STBY_ZA_BIT\n */\nvoid MPU9250::setStandbyZAccelEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_PWR_MGMT_2, MPU9250_PWR2_STBY_ZA_BIT, enabled);\n}\n/** Get X-axis gyroscope standby enabled status.\n * If enabled, the X-axis will not gather or report data (or use power).\n * @return Current X-axis standby enabled status\n * @see MPU9250_RA_PWR_MGMT_2\n * @see MPU9250_PWR2_STBY_XG_BIT\n */\nbool MPU9250::getStandbyXGyroEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_PWR_MGMT_2, MPU9250_PWR2_STBY_XG_BIT, buffer);\n    return buffer[0];\n}\n/** Set X-axis gyroscope standby enabled status.\n * @param New X-axis standby enabled status\n * @see getStandbyXGyroEnabled()\n * @see MPU9250_RA_PWR_MGMT_2\n * @see MPU9250_PWR2_STBY_XG_BIT\n */\nvoid MPU9250::setStandbyXGyroEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_PWR_MGMT_2, MPU9250_PWR2_STBY_XG_BIT, enabled);\n}\n/** Get Y-axis gyroscope standby enabled status.\n * If enabled, the Y-axis will not gather or report data (or use power).\n * @return Current Y-axis standby enabled status\n * @see MPU9250_RA_PWR_MGMT_2\n * @see MPU9250_PWR2_STBY_YG_BIT\n */\nbool MPU9250::getStandbyYGyroEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_PWR_MGMT_2, MPU9250_PWR2_STBY_YG_BIT, buffer);\n    return buffer[0];\n}\n/** Set Y-axis gyroscope standby enabled status.\n * @param New Y-axis standby enabled status\n * @see getStandbyYGyroEnabled()\n * @see MPU9250_RA_PWR_MGMT_2\n * @see MPU9250_PWR2_STBY_YG_BIT\n */\nvoid MPU9250::setStandbyYGyroEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_PWR_MGMT_2, MPU9250_PWR2_STBY_YG_BIT, enabled);\n}\n/** Get Z-axis gyroscope standby enabled status.\n * If enabled, the Z-axis will not gather or report data (or use power).\n * @return Current Z-axis standby enabled status\n * @see MPU9250_RA_PWR_MGMT_2\n * @see MPU9250_PWR2_STBY_ZG_BIT\n */\nbool MPU9250::getStandbyZGyroEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_PWR_MGMT_2, MPU9250_PWR2_STBY_ZG_BIT, buffer);\n    return buffer[0];\n}\n/** Set Z-axis gyroscope standby enabled status.\n * @param New Z-axis standby enabled status\n * @see getStandbyZGyroEnabled()\n * @see MPU9250_RA_PWR_MGMT_2\n * @see MPU9250_PWR2_STBY_ZG_BIT\n */\nvoid MPU9250::setStandbyZGyroEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_PWR_MGMT_2, MPU9250_PWR2_STBY_ZG_BIT, enabled);\n}\n\n// FIFO_COUNT* registers\n\n/** Get current FIFO buffer size.\n * This value indicates the number of bytes stored in the FIFO buffer. This\n * number is in turn the number of bytes that can be read from the FIFO buffer\n * and it is directly proportional to the number of samples available given the\n * set of sensor data bound to be stored in the FIFO (register 35 and 36).\n * @return Current FIFO buffer size\n */\nuint16_t MPU9250::getFIFOCount() {\n    I2Cdev::readBytes(devAddr, MPU9250_RA_FIFO_COUNTH, 2, buffer);\n    return (((uint16_t)buffer[0]) << 8) | buffer[1];\n}\n\n// FIFO_R_W register\n\n/** Get byte from FIFO buffer.\n * This register is used to read and write data from the FIFO buffer. Data is\n * written to the FIFO in order of register number (from lowest to highest). If\n * all the FIFO enable flags (see below) are enabled and all External Sensor\n * Data registers (Registers 73 to 96) are associated with a Slave device, the\n * contents of registers 59 through 96 will be written in order at the Sample\n * Rate.\n *\n * The contents of the sensor data registers (Registers 59 to 96) are written\n * into the FIFO buffer when their corresponding FIFO enable flags are set to 1\n * in FIFO_EN (Register 35). An additional flag for the sensor data registers\n * associated with I2C Slave 3 can be found in I2C_MST_CTRL (Register 36).\n *\n * If the FIFO buffer has overflowed, the status bit FIFO_OFLOW_INT is\n * automatically set to 1. This bit is located in INT_STATUS (Register 58).\n * When the FIFO buffer has overflowed, the oldest data will be lost and new\n * data will be written to the FIFO.\n *\n * If the FIFO buffer is empty, reading this register will return the last byte\n * that was previously read from the FIFO until new data is available. The user\n * should check FIFO_COUNT to ensure that the FIFO buffer is not read when\n * empty.\n *\n * @return Byte from FIFO buffer\n */\nuint8_t MPU9250::getFIFOByte() {\n    I2Cdev::readByte(devAddr, MPU9250_RA_FIFO_R_W, buffer);\n    return buffer[0];\n}\nvoid MPU9250::getFIFOBytes(uint8_t *data, uint8_t length) {\n    I2Cdev::readBytes(devAddr, MPU9250_RA_FIFO_R_W, length, data);\n}\n/** Write byte to FIFO buffer.\n * @see getFIFOByte()\n * @see MPU9250_RA_FIFO_R_W\n */\nvoid MPU9250::setFIFOByte(uint8_t data) {\n    I2Cdev::writeByte(devAddr, MPU9250_RA_FIFO_R_W, data);\n}\n\n// WHO_AM_I register\n\n/** Get Device ID.\n * This register is used to verify the identity of the device (0b110100, 0x34).\n * @return Device ID (6 bits only! should be 0x34)\n * @see MPU9250_RA_WHO_AM_I\n * @see MPU9250_WHO_AM_I_BIT\n * @see MPU9250_WHO_AM_I_LENGTH\n */\nuint8_t MPU9250::getDeviceID() {\n    I2Cdev::readBits(devAddr, MPU9250_RA_WHO_AM_I, MPU9250_WHO_AM_I_BIT, MPU9250_WHO_AM_I_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set Device ID.\n * Write a new ID into the WHO_AM_I register (no idea why this should ever be\n * necessary though).\n * @param id New device ID to set.\n * @see getDeviceID()\n * @see MPU9250_RA_WHO_AM_I\n * @see MPU9250_WHO_AM_I_BIT\n * @see MPU9250_WHO_AM_I_LENGTH\n */\nvoid MPU9250::setDeviceID(uint8_t id) {\n    I2Cdev::writeBits(devAddr, MPU9250_RA_WHO_AM_I, MPU9250_WHO_AM_I_BIT, MPU9250_WHO_AM_I_LENGTH, id);\n}\n\n// ======== UNDOCUMENTED/DMP REGISTERS/METHODS ========\n\n// XG_OFFS_TC register\n\nuint8_t MPU9250::getOTPBankValid() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_XG_OFFS_TC, MPU9250_TC_OTP_BNK_VLD_BIT, buffer);\n    return buffer[0];\n}\nvoid MPU9250::setOTPBankValid(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_XG_OFFS_TC, MPU9250_TC_OTP_BNK_VLD_BIT, enabled);\n}\nint8_t MPU9250::getXGyroOffset() {\n    I2Cdev::readBits(devAddr, MPU9250_RA_XG_OFFS_TC, MPU9250_TC_OFFSET_BIT, MPU9250_TC_OFFSET_LENGTH, buffer);\n    return buffer[0];\n}\nvoid MPU9250::setXGyroOffset(int8_t offset) {\n    I2Cdev::writeBits(devAddr, MPU9250_RA_XG_OFFS_TC, MPU9250_TC_OFFSET_BIT, MPU9250_TC_OFFSET_LENGTH, offset);\n}\n\n// YG_OFFS_TC register\n\nint8_t MPU9250::getYGyroOffset() {\n    I2Cdev::readBits(devAddr, MPU9250_RA_YG_OFFS_TC, MPU9250_TC_OFFSET_BIT, MPU9250_TC_OFFSET_LENGTH, buffer);\n    return buffer[0];\n}\nvoid MPU9250::setYGyroOffset(int8_t offset) {\n    I2Cdev::writeBits(devAddr, MPU9250_RA_YG_OFFS_TC, MPU9250_TC_OFFSET_BIT, MPU9250_TC_OFFSET_LENGTH, offset);\n}\n\n// ZG_OFFS_TC register\n\nint8_t MPU9250::getZGyroOffset() {\n    I2Cdev::readBits(devAddr, MPU9250_RA_ZG_OFFS_TC, MPU9250_TC_OFFSET_BIT, MPU9250_TC_OFFSET_LENGTH, buffer);\n    return buffer[0];\n}\nvoid MPU9250::setZGyroOffset(int8_t offset) {\n    I2Cdev::writeBits(devAddr, MPU9250_RA_ZG_OFFS_TC, MPU9250_TC_OFFSET_BIT, MPU9250_TC_OFFSET_LENGTH, offset);\n}\n\n// X_FINE_GAIN register\n\nint8_t MPU9250::getXFineGain() {\n    I2Cdev::readByte(devAddr, MPU9250_RA_X_FINE_GAIN, buffer);\n    return buffer[0];\n}\nvoid MPU9250::setXFineGain(int8_t gain) {\n    I2Cdev::writeByte(devAddr, MPU9250_RA_X_FINE_GAIN, gain);\n}\n\n// Y_FINE_GAIN register\n\nint8_t MPU9250::getYFineGain() {\n    I2Cdev::readByte(devAddr, MPU9250_RA_Y_FINE_GAIN, buffer);\n    return buffer[0];\n}\nvoid MPU9250::setYFineGain(int8_t gain) {\n    I2Cdev::writeByte(devAddr, MPU9250_RA_Y_FINE_GAIN, gain);\n}\n\n// Z_FINE_GAIN register\n\nint8_t MPU9250::getZFineGain() {\n    I2Cdev::readByte(devAddr, MPU9250_RA_Z_FINE_GAIN, buffer);\n    return buffer[0];\n}\nvoid MPU9250::setZFineGain(int8_t gain) {\n    I2Cdev::writeByte(devAddr, MPU9250_RA_Z_FINE_GAIN, gain);\n}\n\n// XA_OFFS_* registers\n\nint16_t MPU9250::getXAccelOffset() {\n    I2Cdev::readBytes(devAddr, MPU9250_RA_XA_OFFS_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\nvoid MPU9250::setXAccelOffset(int16_t offset) {\n    I2Cdev::writeWord(devAddr, MPU9250_RA_XA_OFFS_H, offset);\n}\n\n// YA_OFFS_* register\n\nint16_t MPU9250::getYAccelOffset() {\n    I2Cdev::readBytes(devAddr, MPU9250_RA_YA_OFFS_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\nvoid MPU9250::setYAccelOffset(int16_t offset) {\n    I2Cdev::writeWord(devAddr, MPU9250_RA_YA_OFFS_H, offset);\n}\n\n// ZA_OFFS_* register\n\nint16_t MPU9250::getZAccelOffset() {\n    I2Cdev::readBytes(devAddr, MPU9250_RA_ZA_OFFS_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\nvoid MPU9250::setZAccelOffset(int16_t offset) {\n    I2Cdev::writeWord(devAddr, MPU9250_RA_ZA_OFFS_H, offset);\n}\n\n// XG_OFFS_USR* registers\n\nint16_t MPU9250::getXGyroOffsetUser() {\n    I2Cdev::readBytes(devAddr, MPU9250_RA_XG_OFFS_USRH, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\nvoid MPU9250::setXGyroOffsetUser(int16_t offset) {\n    I2Cdev::writeWord(devAddr, MPU9250_RA_XG_OFFS_USRH, offset);\n}\n\n// YG_OFFS_USR* register\n\nint16_t MPU9250::getYGyroOffsetUser() {\n    I2Cdev::readBytes(devAddr, MPU9250_RA_YG_OFFS_USRH, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\nvoid MPU9250::setYGyroOffsetUser(int16_t offset) {\n    I2Cdev::writeWord(devAddr, MPU9250_RA_YG_OFFS_USRH, offset);\n}\n\n// ZG_OFFS_USR* register\n\nint16_t MPU9250::getZGyroOffsetUser() {\n    I2Cdev::readBytes(devAddr, MPU9250_RA_ZG_OFFS_USRH, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\nvoid MPU9250::setZGyroOffsetUser(int16_t offset) {\n    I2Cdev::writeWord(devAddr, MPU9250_RA_ZG_OFFS_USRH, offset);\n}\n\n// INT_ENABLE register (DMP functions)\n\nbool MPU9250::getIntPLLReadyEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_INT_ENABLE, MPU9250_INTERRUPT_PLL_RDY_INT_BIT, buffer);\n    return buffer[0];\n}\nvoid MPU9250::setIntPLLReadyEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_INT_ENABLE, MPU9250_INTERRUPT_PLL_RDY_INT_BIT, enabled);\n}\nbool MPU9250::getIntDMPEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_INT_ENABLE, MPU9250_INTERRUPT_DMP_INT_BIT, buffer);\n    return buffer[0];\n}\nvoid MPU9250::setIntDMPEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_INT_ENABLE, MPU9250_INTERRUPT_DMP_INT_BIT, enabled);\n}\n\n// DMP_INT_STATUS\n\nbool MPU9250::getDMPInt5Status() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_DMP_INT_STATUS, MPU9250_DMPINT_5_BIT, buffer);\n    return buffer[0];\n}\nbool MPU9250::getDMPInt4Status() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_DMP_INT_STATUS, MPU9250_DMPINT_4_BIT, buffer);\n    return buffer[0];\n}\nbool MPU9250::getDMPInt3Status() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_DMP_INT_STATUS, MPU9250_DMPINT_3_BIT, buffer);\n    return buffer[0];\n}\nbool MPU9250::getDMPInt2Status() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_DMP_INT_STATUS, MPU9250_DMPINT_2_BIT, buffer);\n    return buffer[0];\n}\nbool MPU9250::getDMPInt1Status() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_DMP_INT_STATUS, MPU9250_DMPINT_1_BIT, buffer);\n    return buffer[0];\n}\nbool MPU9250::getDMPInt0Status() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_DMP_INT_STATUS, MPU9250_DMPINT_0_BIT, buffer);\n    return buffer[0];\n}\n\n// INT_STATUS register (DMP functions)\n\nbool MPU9250::getIntPLLReadyStatus() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_INT_STATUS, MPU9250_INTERRUPT_PLL_RDY_INT_BIT, buffer);\n    return buffer[0];\n}\nbool MPU9250::getIntDMPStatus() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_INT_STATUS, MPU9250_INTERRUPT_DMP_INT_BIT, buffer);\n    return buffer[0];\n}\n\n// USER_CTRL register (DMP functions)\n\nbool MPU9250::getDMPEnabled() {\n    I2Cdev::readBit(devAddr, MPU9250_RA_USER_CTRL, MPU9250_USERCTRL_DMP_EN_BIT, buffer);\n    return buffer[0];\n}\nvoid MPU9250::setDMPEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_USER_CTRL, MPU9250_USERCTRL_DMP_EN_BIT, enabled);\n}\nvoid MPU9250::resetDMP() {\n    I2Cdev::writeBit(devAddr, MPU9250_RA_USER_CTRL, MPU9250_USERCTRL_DMP_RESET_BIT, true);\n}\n\n// BANK_SEL register\n\nvoid MPU9250::setMemoryBank(uint8_t bank, bool prefetchEnabled, bool userBank) {\n    bank &= 0x1F;\n    if (userBank) bank |= 0x20;\n    if (prefetchEnabled) bank |= 0x40;\n    I2Cdev::writeByte(devAddr, MPU9250_RA_BANK_SEL, bank);\n}\n\n// MEM_START_ADDR register\n\nvoid MPU9250::setMemoryStartAddress(uint8_t address) {\n    I2Cdev::writeByte(devAddr, MPU9250_RA_MEM_START_ADDR, address);\n}\n\n// MEM_R_W register\n\nuint8_t MPU9250::readMemoryByte() {\n    I2Cdev::readByte(devAddr, MPU9250_RA_MEM_R_W, buffer);\n    return buffer[0];\n}\nvoid MPU9250::writeMemoryByte(uint8_t data) {\n    I2Cdev::writeByte(devAddr, MPU9250_RA_MEM_R_W, data);\n}\nvoid MPU9250::readMemoryBlock(uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address) {\n    setMemoryBank(bank);\n    setMemoryStartAddress(address);\n    uint8_t chunkSize;\n    for (uint16_t i = 0; i < dataSize;) {\n        // determine correct chunk size according to bank position and data size\n        chunkSize = MPU9250_DMP_MEMORY_CHUNK_SIZE;\n\n        // make sure we don't go past the data size\n        if (i + chunkSize > dataSize) chunkSize = dataSize - i;\n\n        // make sure this chunk doesn't go past the bank boundary (256 bytes)\n        if (chunkSize > 256 - address) chunkSize = 256 - address;\n\n        // read the chunk of data as specified\n        I2Cdev::readBytes(devAddr, MPU9250_RA_MEM_R_W, chunkSize, data + i);\n        \n        // increase byte index by [chunkSize]\n        i += chunkSize;\n\n        // uint8_t automatically wraps to 0 at 256\n        address += chunkSize;\n\n        // if we aren't done, update bank (if necessary) and address\n        if (i < dataSize) {\n            if (address == 0) bank++;\n            setMemoryBank(bank);\n            setMemoryStartAddress(address);\n        }\n    }\n}\nbool MPU9250::writeMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify, bool useProgMem) {\n    setMemoryBank(bank);\n    setMemoryStartAddress(address);\n    uint8_t chunkSize;\n    uint8_t *verifyBuffer;\n    uint8_t *progBuffer;\n    uint16_t i;\n    uint8_t j;\n    if (verify) verifyBuffer = (uint8_t *)malloc(MPU9250_DMP_MEMORY_CHUNK_SIZE);\n    if (useProgMem) progBuffer = (uint8_t *)malloc(MPU9250_DMP_MEMORY_CHUNK_SIZE);\n    for (i = 0; i < dataSize;) {\n        // determine correct chunk size according to bank position and data size\n        chunkSize = MPU9250_DMP_MEMORY_CHUNK_SIZE;\n\n        // make sure we don't go past the data size\n        if (i + chunkSize > dataSize) chunkSize = dataSize - i;\n\n        // make sure this chunk doesn't go past the bank boundary (256 bytes)\n        if (chunkSize > 256 - address) chunkSize = 256 - address;\n        \n        if (useProgMem) {\n            // write the chunk of data as specified\n            for (j = 0; j < chunkSize; j++) progBuffer[j] = pgm_read_byte(data + i + j);\n        } else {\n            // write the chunk of data as specified\n            progBuffer = (uint8_t *)data + i;\n        }\n\n        I2Cdev::writeBytes(devAddr, MPU9250_RA_MEM_R_W, chunkSize, progBuffer);\n\n        // verify data if needed\n        if (verify && verifyBuffer) {\n            setMemoryBank(bank);\n            setMemoryStartAddress(address);\n            I2Cdev::readBytes(devAddr, MPU9250_RA_MEM_R_W, chunkSize, verifyBuffer);\n            if (memcmp(progBuffer, verifyBuffer, chunkSize) != 0) {\n                /*Serial.print(\"Block write verification error, bank \");\n                Serial.print(bank, DEC);\n                Serial.print(\", address \");\n                Serial.print(address, DEC);\n                Serial.print(\"!\\nExpected:\");\n                for (j = 0; j < chunkSize; j++) {\n                    Serial.print(\" 0x\");\n                    if (progBuffer[j] < 16) Serial.print(\"0\");\n                    Serial.print(progBuffer[j], HEX);\n                }\n                Serial.print(\"\\nReceived:\");\n                for (uint8_t j = 0; j < chunkSize; j++) {\n                    Serial.print(\" 0x\");\n                    if (verifyBuffer[i + j] < 16) Serial.print(\"0\");\n                    Serial.print(verifyBuffer[i + j], HEX);\n                }\n                Serial.print(\"\\n\");*/\n                free(verifyBuffer);\n                if (useProgMem) free(progBuffer);\n                return false; // uh oh.\n            }\n        }\n\n        // increase byte index by [chunkSize]\n        i += chunkSize;\n\n        // uint8_t automatically wraps to 0 at 256\n        address += chunkSize;\n\n        // if we aren't done, update bank (if necessary) and address\n        if (i < dataSize) {\n            if (address == 0) bank++;\n            setMemoryBank(bank);\n            setMemoryStartAddress(address);\n        }\n    }\n    if (verify) free(verifyBuffer);\n    if (useProgMem) free(progBuffer);\n    return true;\n}\nbool MPU9250::writeProgMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify) {\n    return writeMemoryBlock(data, dataSize, bank, address, verify, true);\n}\nbool MPU9250::writeDMPConfigurationSet(const uint8_t *data, uint16_t dataSize, bool useProgMem) {\n    uint8_t *progBuffer, success, special;\n    uint16_t i, j;\n    if (useProgMem) {\n        progBuffer = (uint8_t *)malloc(8); // assume 8-byte blocks, realloc later if necessary\n    }\n\n    // config set data is a long string of blocks with the following structure:\n    // [bank] [offset] [length] [byte[0], byte[1], ..., byte[length]]\n    uint8_t bank, offset, length;\n    for (i = 0; i < dataSize;) {\n        if (useProgMem) {\n            bank = pgm_read_byte(data + i++);\n            offset = pgm_read_byte(data + i++);\n            length = pgm_read_byte(data + i++);\n        } else {\n            bank = data[i++];\n            offset = data[i++];\n            length = data[i++];\n        }\n\n        // write data or perform special action\n        if (length > 0) {\n            // regular block of data to write\n            /*Serial.print(\"Writing config block to bank \");\n            Serial.print(bank);\n            Serial.print(\", offset \");\n            Serial.print(offset);\n            Serial.print(\", length=\");\n            Serial.println(length);*/\n            if (useProgMem) {\n                if (sizeof(progBuffer) < length) progBuffer = (uint8_t *)realloc(progBuffer, length);\n                for (j = 0; j < length; j++) progBuffer[j] = pgm_read_byte(data + i + j);\n            } else {\n                progBuffer = (uint8_t *)data + i;\n            }\n            success = writeMemoryBlock(progBuffer, length, bank, offset, true);\n            i += length;\n        } else {\n            // special instruction\n            // NOTE: this kind of behavior (what and when to do certain things)\n            // is totally undocumented. This code is in here based on observed\n            // behavior only, and exactly why (or even whether) it has to be here\n            // is anybody's guess for now.\n            if (useProgMem) {\n                special = pgm_read_byte(data + i++);\n            } else {\n                special = data[i++];\n            }\n            /*Serial.print(\"Special command code \");\n            Serial.print(special, HEX);\n            Serial.println(\" found...\");*/\n            if (special == 0x01) {\n                // enable DMP-related interrupts\n                \n                //setIntZeroMotionEnabled(true);\n                //setIntFIFOBufferOverflowEnabled(true);\n                //setIntDMPEnabled(true);\n                I2Cdev::writeByte(devAddr, MPU9250_RA_INT_ENABLE, 0x32);  // single operation\n\n                success = true;\n            } else {\n                // unknown special command\n                success = false;\n            }\n        }\n        \n        if (!success) {\n            if (useProgMem) free(progBuffer);\n            return false; // uh oh\n        }\n    }\n    if (useProgMem) free(progBuffer);\n    return true;\n}\nbool MPU9250::writeProgDMPConfigurationSet(const uint8_t *data, uint16_t dataSize) {\n    return writeDMPConfigurationSet(data, dataSize, true);\n}\n\n// DMP_CFG_1 register\n\nuint8_t MPU9250::getDMPConfig1() {\n    I2Cdev::readByte(devAddr, MPU9250_RA_DMP_CFG_1, buffer);\n    return buffer[0];\n}\nvoid MPU9250::setDMPConfig1(uint8_t config) {\n    I2Cdev::writeByte(devAddr, MPU9250_RA_DMP_CFG_1, config);\n}\n\n// DMP_CFG_2 register\n\nuint8_t MPU9250::getDMPConfig2() {\n    I2Cdev::readByte(devAddr, MPU9250_RA_DMP_CFG_2, buffer);\n    return buffer[0];\n}\nvoid MPU9250::setDMPConfig2(uint8_t config) {\n    I2Cdev::writeByte(devAddr, MPU9250_RA_DMP_CFG_2, config);\n}"},{"name":"MPU9250wrapper.cpp","type":"source","group":"other","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"\n#include \"Wire.h\"\n#include \"twi.h\"\n#include \"I2Cdev.h\"\n#include \"MPU9250.h\"\n\nMPU9250 accgyro;\nint16_t ax, ay, az;\nint16_t gx, gy, gz;\nint16_t mx, my, mz;\n\nextern \"C\" void MPU9250_Init(void)\n{\n    Wire.begin();\n    accgyro.initialize();\n\t\n/*   // Make devAddr public and add this line:\n  if(!accgyro.testConnection())\n  {\n    //Serial.println(\"Test Connection Failed Changing I2C addr to 0x69\");\n    accgyro.devAddr=0x69;\n  } */\n}\n\nextern \"C\" void MPU9250_ReadRAW(int* pfData)\n{\n\n    accgyro.getMotion9(&ax, &ay, &az, &gx, &gy, &gz, &mx, &my, &mz);\n\t\n    pfData[0]=ax;\n\tpfData[1]=ay;\n    pfData[2]=az;\n    pfData[3]=gx;\n    pfData[4]=gy;\n    pfData[5]=gz;\n    pfData[6]=mx;\n    pfData[7]=my;\n    pfData[8]=mz;\n    pfData[9]=accgyro.getTemperature();\n\t\n}\n\nextern \"C\" void MPU9250_ReadMag(int* pfData)\n{\n\n    accgyro.getMag(&mx, &my, &mz);\n\t\n    pfData[0]=mx;\n\tpfData[1]=my;\n    pfData[2]=mz;\n\t\n\t\n}"},{"name":"MS5611.cpp","type":"source","group":"other","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/*\nMS5611.cpp - Class file for the MS5611 Barometric Pressure & Temperature Sensor Arduino Library.\n\nVersion: 1.0.0\n(c) 2014 Korneliusz Jarzebski\nwww.jarzebski.pl\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the version 3 GNU General Public License as\npublished by the Free Software Foundation.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#if ARDUINO >= 100\n#include \"Arduino.h\"\n#else\n#include \"WProgram.h\"\n#endif\n\n#include <Wire.h>\n#include <math.h>\n\n#include \"MS5611.h\"\n\nbool MS5611::begin(ms5611_osr_t osr)\n{\n    Wire.begin();\n\n    reset();\n\n    setOversampling(osr);\n\n    delay(100);\n\n    readPROM();\n\n    return true;\n}\n\n// Set oversampling value\nvoid MS5611::setOversampling(ms5611_osr_t osr)\n{\n    switch (osr)\n    {\n\tcase MS5611_ULTRA_LOW_POWER:\n\t    ct = 1;\n\t    break;\n\tcase MS5611_LOW_POWER:\n\t    ct = 2;\n\t    break;\n\tcase MS5611_STANDARD:\n\t    ct = 3;\n\t    break;\n\tcase MS5611_HIGH_RES:\n\t    ct = 5;\n\t    break;\n\tcase MS5611_ULTRA_HIGH_RES:\n\t    ct = 10;\n\t    break;\n    }\n\n    uosr = osr;\n}\n\n// Get oversampling value\nms5611_osr_t MS5611::getOversampling(void)\n{\n    return (ms5611_osr_t)uosr;\n}\n\nvoid MS5611::reset(void)\n{\n    Wire.beginTransmission(MS5611_ADDRESS);\n\n    #if ARDUINO >= 100\n\tWire.write(MS5611_CMD_RESET);\n    #else\n\tWire.send(MS5611_CMD_RESET);\n    #endif\n\n    Wire.endTransmission();\n}\n\nvoid MS5611::readPROM(void)\n{\n    for (uint8_t offset = 0; offset < 6; offset++)\n    {\n\tfc[offset] = readRegister16(MS5611_CMD_READ_PROM + (offset * 2));\n    }\n}\n\nuint32_t MS5611::readRawTemperature(void)\n{\n    Wire.beginTransmission(MS5611_ADDRESS);\n\n    #if ARDUINO >= 100\n\tWire.write(MS5611_CMD_CONV_D2 + uosr);\n    #else\n\tWire.send(MS5611_CMD_CONV_D2 + uosr);\n    #endif\n\n    Wire.endTransmission();\n\n    delay(ct);\n\n    return readRegister24(MS5611_CMD_ADC_READ);\n}\n\nuint32_t MS5611::readRawPressure(void)\n{\n    Wire.beginTransmission(MS5611_ADDRESS);\n\n    #if ARDUINO >= 100\n\tWire.write(MS5611_CMD_CONV_D1 + uosr);\n    #else\n\tWire.send(MS5611_CMD_CONV_D1 + uosr);\n    #endif\n\n    Wire.endTransmission();\n\n    delay(ct);\n\n    return readRegister24(MS5611_CMD_ADC_READ);\n}\n\nint32_t MS5611::readPressure(bool compensation)\n{\n    uint32_t D1 = readRawPressure();\n\n    uint32_t D2 = readRawTemperature();\n    int32_t dT = D2 - (uint32_t)fc[4] * 256;\n\n    int64_t OFF = (int64_t)fc[1] * 65536 + (int64_t)fc[3] * dT / 128;\n    int64_t SENS = (int64_t)fc[0] * 32768 + (int64_t)fc[2] * dT / 256;\n\n    if (compensation)\n    {\n\tint32_t TEMP = 2000 + ((int64_t) dT * fc[5]) / 8388608;\n\n\tOFF2 = 0;\n\tSENS2 = 0;\n\n\tif (TEMP < 2000)\n\t{\n\t    OFF2 = 5 * ((TEMP - 2000) * (TEMP - 2000)) / 2;\n\t    SENS2 = 5 * ((TEMP - 2000) * (TEMP - 2000)) / 4;\n\t}\n\n\tif (TEMP < -1500)\n\t{\n\t    OFF2 = OFF2 + 7 * ((TEMP + 1500) * (TEMP + 1500));\n\t    SENS2 = SENS2 + 11 * ((TEMP + 1500) * (TEMP + 1500)) / 2;\n\t}\n\n\tOFF = OFF - OFF2;\n\tSENS = SENS - SENS2;\n    }\n\n    uint32_t P = (D1 * SENS / 2097152 - OFF) / 32768;\n\n    return P;\n}\n\ndouble MS5611::readTemperature(bool compensation)\n{\n    uint32_t D2 = readRawTemperature();\n    int32_t dT = D2 - (uint32_t)fc[4] * 256;\n\n    int32_t TEMP = 2000 + ((int64_t) dT * fc[5]) / 8388608;\n\n    TEMP2 = 0;\n\n    if (compensation)\n    {\n\tif (TEMP < 2000)\n\t{\n\t    TEMP2 = (dT * dT) / (2 << 30);\n\t}\n    }\n\n    TEMP = TEMP - TEMP2;\n\n    return ((double)TEMP/100);\n}\n\n// Calculate altitude from Pressure & Sea level pressure\ndouble MS5611::getAltitude(double pressure, double seaLevelPressure)\n{\n    return (44330.0f * (1.0f - pow((double)pressure / (double)seaLevelPressure, 0.1902949f)));\n}\n\n// Calculate sea level from Pressure given on specific altitude\ndouble MS5611::getSeaLevel(double pressure, double altitude)\n{\n    return ((double)pressure / pow(1.0f - ((double)altitude / 44330.0f), 5.255f));\n}\n\n// Read 16-bit from register (oops MSB, LSB)\nuint16_t MS5611::readRegister16(uint8_t reg)\n{\n    uint16_t value;\n    Wire.beginTransmission(MS5611_ADDRESS);\n    #if ARDUINO >= 100\n        Wire.write(reg);\n    #else\n        Wire.send(reg);\n    #endif\n    Wire.endTransmission();\n\n    Wire.beginTransmission(MS5611_ADDRESS);\n    Wire.requestFrom(MS5611_ADDRESS, 2);\n    while(!Wire.available()) {};\n    #if ARDUINO >= 100\n        uint8_t vha = Wire.read();\n        uint8_t vla = Wire.read();\n    #else\n        uint8_t vha = Wire.receive();\n        uint8_t vla = Wire.receive();\n    #endif;\n    Wire.endTransmission();\n\n    value = vha << 8 | vla;\n\n    return value;\n}\n\n// Read 24-bit from register (oops XSB, MSB, LSB)\nuint32_t MS5611::readRegister24(uint8_t reg)\n{\n    uint32_t value;\n    Wire.beginTransmission(MS5611_ADDRESS);\n    #if ARDUINO >= 100\n        Wire.write(reg);\n    #else\n        Wire.send(reg);\n    #endif\n    Wire.endTransmission();\n\n    Wire.beginTransmission(MS5611_ADDRESS);\n    Wire.requestFrom(MS5611_ADDRESS, 3);\n    while(!Wire.available()) {};\n    #if ARDUINO >= 100\n        uint8_t vxa = Wire.read();\n        uint8_t vha = Wire.read();\n        uint8_t vla = Wire.read();\n    #else\n        uint8_t vxa = Wire.receive();\n        uint8_t vha = Wire.receive();\n        uint8_t vla = Wire.receive();\n    #endif;\n    Wire.endTransmission();\n\n    value = ((int32_t)vxa << 16) | ((int32_t)vha << 8) | vla;\n\n    return value;\n}\n"},{"name":"MS5611wrapper.cpp","type":"source","group":"other","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"// MS5611wrapper.cpp\n\n#include \"Wire.h\"\n// #include \"HMC58X3.h\"\n#include \"twi.h\"\n#include \"I2Cdev.h\"\n#include \"MS5611.h\"\n\nMS5611 baro;\ndouble referencePressure;\n\nextern \"C\" void MS5611Baro_Init(void)\n{\n\t\n\tbaro.begin();\n    referencePressure = baro.readPressure();\n}\n\nextern \"C\" void MS5611Baro_ReadRAW(float* pfData)\n{\n    pfData[0]=baro.readRawPressure();\n\tpfData[1]=baro.readRawTemperature();\n}\n\nextern \"C\" void MS5611Baro_Read(float* pfData)\n{\n    long realPressure = baro.readPressure();\n    pfData[0]=baro.readPressure();\n\tpfData[1]=baro.readTemperature();\n    pfData[2]=baro.getAltitude(realPressure);\n\tpfData[3]=baro.getAltitude(realPressure, referencePressure);\n}\n\nextern \"C\" void MS5611Baro_ReadALT(float* pfData)\n{\n    long realPressure = baro.readPressure();\n    pfData[0]=baro.getAltitude(realPressure);\n\tpfData[1]=baro.getAltitude(realPressure);\n}\n\nextern \"C\" void MS5611Baro_ReadPT(float* pfData)\n{\n    pfData[0]=baro.readPressure();\n\tpfData[1]=baro.readTemperature();\n}"},{"name":"MW_ArduinoHWInit.cpp","type":"source","group":"legacy","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/../../../Documents/MATLAB/SupportPackages/R2025b/toolbox/target/supportpackages/arduinotarget/src","tag":"","groupDisplay":"Other files","code":"/* Arduino AVR Bareboard scheduler\n*\n* Copyright 2014-2024 The MathWorks, Inc.\n*/\n\n#include \"Arduino.h\"\n#include \"io_wrappers.h\"\n#if defined(ARDUINO_ARM_CORTEX_M0_PLUS)\n#include \"arduinoARM_M0plusScheduler.h\"\n#elif defined(ARDUINO_ARM_CORTEX_M3)\n#include \"arduinoARMScheduler.h\"\n#include \"watchdog.h\"\n#else\n#include \"arduinoAVRScheduler.h\"\n#endif\n\n#if (defined(ARDUINO_ARCH_RENESAS_UNO))\n#include \"MW_ArduinoUnoR4.h\"\n#endif\n\n#if defined(ESP_PLATFORM)\n#include \"esp_wpa2.h\" //wpa2 library for connections to Enterprise networks\n#endif\n\n#ifdef _RTT_NUMI2C_\n#include \"MW_arduinoI2C.h\"\n#endif\n\n#if defined(ARDUINO_ARDUINO_NANO33BLE)\n#include <USB/PluggableUSBSerial.h> // for PluggableUSBD\n#include \"MW_PWM_NANO33BLE.h\"\n#endif\n\n#if defined(ARDUINO_NANO_RP2040_CONNECT)\n#include <USB/PluggableUSBSerial.h>\n#include \"double_tap_usb_boot.cpp\" // to force double tap detection\n#endif\n\n#if (defined(ARDUINO_RASPBERRY_PI_PICO_W) || defined(ARDUINO_RASPBERRY_PI_PICO))\n#include \"RP2040USB.h\"\n#include \"pico_bootsel_via_double_reset.c\" // to force double tap detection\n#include <pico/stdlib.h>\n// Weak empty variant initialization. May be redefined by variant files.\nvoid initVariant() __attribute__((weak));\nvoid initVariant() { }\n#endif\n\n#if (defined(MW_ARDUINO_OV2640CSPIN)) || (defined(_RTT_SPI_SSPIN_)) || (defined(_RTT_DUE_SPI_SSPIN4_)) || (defined(_RTT_DUE_SPI_SSPIN10_)) || (defined(_RTT_DUE_SPI_SSPIN52_))\n#include \"MW_SPIwriteRead.h\"\n#endif\n\n#if (defined(_RTT_RS485_INUSE_))\n#include \"ArduinoRS485.h\"\n#endif\n\n#if (defined(_RTT_MODBUS_MASTER_)) || (defined(_RTT_MODBUS_SLAVE_))\n#include \"ArduinoModbus.h\"\n#endif\n\n#ifdef NANO_MOTOR_CARRIER\n#include <Wire.h>\n#define PMIC_ADDRESS  0x6B\n#define PMIC_REG00    0x00\n#define PMIC_REG01    0x01\n#define PMIC_REG02    0x02\n#define PMIC_REG04    0x04\n#define PMIC_REG05    0x05\nvoid MW_EnableNanoCarrierBatteryCharging(void);\n#endif\n\n// Wifi init routines\n#include <inttypes.h>\n#if (defined(_RTT_WIFI_EXTMODE_) && (_RTT_WIFI_EXTMODE_ == 1)) || (defined(_RTT_WIFI_UDP_) && (_RTT_WIFI_UDP_ != 0)) || (defined(_RTT_WIFI_TCP_) && (_RTT_WIFI_TCP_ != 0))|| defined(_RTT_THINGSPEAK_WIFI_) || defined(_RTT_WEBSOCKET_PORT_) || defined(_RTT_MQTT_WIFI_) || defined(_RTT_HTTP_CLIENT_) || defined(OTA_SETUP) || defined(OTA_UPLOAD)\n#if defined(ARDUINO_WIFI_LIB_101)\n#include <WiFi101.h>\n#elif defined(ARDUINO_WIFI_LIB_NINA)\n#include <WiFiNINA.h>\n#elif defined(ARDUINO_UNOR4_WIFI)\n#include <WiFiS3.h>\n#else\n#include <WiFi.h>\n#endif\n#include <SPI.h>\n\n/*#define that helps to stringify build flags\n//Double evaluation is needed so that the double quotes can be derived out\n//of the build flag and can be assigned to a character array */\n#define RTT_StringifyBuildFlag(x) RTT_StringParamExpanded(x)\n#define RTT_StringParamExpanded(x)  #x\n\n#if (_RTT_DISABLE_Wifi_DHCP_ == 1)\nIPAddress wifiLocalIpAddress(_RTT_WIFI_Local_IP1, _RTT_WIFI_Local_IP2, _RTT_WIFI_Local_IP3, _RTT_WIFI_Local_IP4);\n#endif\n\n#if (_RTT_DISABLE_Wifi_DHCP_ == 2)\nIPAddress wifiLocalIpAddress(_RTT_WIFI_Local_IP1, _RTT_WIFI_Local_IP2, _RTT_WIFI_Local_IP3, _RTT_WIFI_Local_IP4);\nIPAddress wifiGatewayAddress(_RTT_WIFI_Gateway_IP1, _RTT_WIFI_Gateway_IP2, _RTT_WIFI_Gateway_IP3, _RTT_WIFI_Gateway_IP4);\nIPAddress wifiSubnetMask(_RTT_WIFI_Subnet_IP1, _RTT_WIFI_Subnet_IP2, _RTT_WIFI_Subnet_IP3, _RTT_WIFI_Subnet_IP4);\nIPAddress wifiDNSAddress(_RTT_WIFI_DNS_IP1, _RTT_WIFI_DNS_IP2, _RTT_WIFI_DNS_IP3, _RTT_WIFI_DNS_IP4);\n#endif\n\n#if defined(ESP_PLATFORM) || defined(ARDUINO_UNOR4_WIFI)\nIPAddress wifigateway(_RTT_WIFI_Local_IP1, _RTT_WIFI_Local_IP2, _RTT_WIFI_Local_IP3, uint8_t(1));\nIPAddress subnet(uint8_t(255),uint8_t(255),uint8_t(255),uint8_t(0));\nIPAddress dns1 = (uint32_t)0x00000000;\nIPAddress dns2 = (uint32_t)0x00000000;\n#endif\n\nchar ssid[] = RTT_StringifyBuildFlag(_RTT_WIFI_SSID);\nint configureSuccess = WL_IDLE_STATUS;\nint trialcount;\n\n#ifdef _RTT_WIFI_WEP\nchar key[] = RTT_StringifyBuildFlag(_RTT_WIFI_KEY);\nint keyIndex = _RTT_WIFI_KEY_INDEX;\n#endif //_RTT_WIFI_WEP\n\n#ifdef _RTT_WIFI_WPA\nchar wpapass[] = RTT_StringifyBuildFlag(_RTT_WIFI_WPA_PASSWORD);\n#endif //_RTT_WIFI_WPA\n\n#ifdef _RTT_WIFI_WPA2_ENTERPRISE\nchar wpa2username[] = RTT_StringifyBuildFlag(_RTT_WIFI_WPA2_USERNAME);\nchar wpa2password[] = RTT_StringifyBuildFlag(_RTT_WIFI_WPA2_PASSWORD);\n#endif //_RTT_WIFI_WPA2_ENTERPRISE\n#endif //(defined(_RTT_THINGSPEAK_WIFI_) || (_RTT_WIFI_TCP_ !=0) || defined(_RTT_WEBSOCKET_PORT_))\n\n#include \"MW_ArduinoHWInit.h\"\n#ifdef _MW_DASHBOARD_BLOCK_PRESENT_\n#include \"MW_graphicPrimitive.h\"\n#endif\n\n#if defined(OTA_SETUP) || defined(OTA_UPLOAD)\n#include \"WiFiServer.h\"\n#include \"WiFiClient.h\"\n#include \"WiFiUdp.h\"\n#include \"ArduinoOTA.h\"\nchar OTA_Device_Name[] = RTT_StringifyBuildFlag(_RTT_OTA_DEVICE_NAME);\nchar OTA_Device_Pass[] = RTT_StringifyBuildFlag(_RTT_OTA_DEVICE_PASS);\n#endif\n\nvoid MW_OTA_Setup(void) // initialize OTA handlers\n{\n  #if defined(OTA_SETUP) || defined(OTA_UPLOAD)\n  ArduinoOTA.begin(WiFi.localIP(), OTA_Device_Name, OTA_Device_Pass, InternalStorage);\n  #endif\n}\n\nvoid MW_OTA_Poll(void) // check for OTA updates\n{\n  #if defined(OTA_SETUP) || defined(OTA_UPLOAD)\n  ArduinoOTA.poll(); \n  #endif\n}\n\nvoid MW_Modbus_Slave_Poll(void)\n{\n    #if defined(_RTT_MODBUS_SLAVE_)\n    ModbusRTUServer.poll();\n    #endif\n}\n\nvoid MW_ArduinoNano33BLESenseInit(void)\n{\n    #if (defined(ARDUINO_ARDUINO_NANO33BLE))\n    initVariant();\n    #if defined(SERIAL_CDC)\n    PluggableUSBD().begin();\n    _SerialUSB.begin(115200);\n    #endif\n    #if defined(_RTT_PWM_NANO33BLE_INUSE)\n    MW_NANO33BLE_PWM_Setup();\n    #endif\n    #endif\n}\n\nvoid MW_ArduinoNanoRP2040Init(void)\n{\n    #if defined(ARDUINO_NANO_RP2040_CONNECT)\n\tinit();\n\tinitVariant();\n    #if defined(SERIAL_CDC)\n    PluggableUSBD().begin();\n    _SerialUSB.begin(115200);\n    #endif\n    #endif\n}\n\nvoid UNOR4_Init(void) \n{   \n     #if(defined(ARDUINO_ARCH_RENESAS_UNO))\n    // Disable stack pointer protection\n    // TODO: the best thing would be keeping SPMON active but changing\n    // R_MPU_SPMON->SP[0].EA = __stack_top; // on every call to malloc()\n    // When stack and heap would collide, we could signal the NMI with mbed style leds patterns\n    #if defined(__ARM_ARCH_8M_MAIN__) || defined(__ARM_ARCH_8M_BASE__)\n        __set_MSPLIM(0);\n        #if FSP_PRIV_TZ_USE_SECURE_REGS\n            unsecure_registers();\n        #endif\n    #else\n        R_MPU_SPMON->SP[0].CTL = 0;\n    #endif\n\n   __disable_irq();\n   irq_vector_table = (volatile uint32_t *)APPLICATION_VECTOR_TABLE_ADDRESS_RAM;\n   size_t _i;\n   for (_i=0; _i<BSP_CORTEX_VECTOR_TABLE_ENTRIES; _i++) {\n      *(irq_vector_table + _i) = (uint32_t)__VECTOR_TABLE[_i];\n   }\n   for (_i=0; _i<BSP_ICU_VECTOR_MAX_ENTRIES; _i++) {\n      *(irq_vector_table + _i +BSP_CORTEX_VECTOR_TABLE_ENTRIES) = (uint32_t)g_vector_table[_i];\n   }\n\n   SCB->VTOR = (uint32_t)irq_vector_table;\n\n   __DSB();\n   __enable_irq();\n\n    #ifdef BACKTRACE_SUPPORT\n       // \"install\" stacktrace print over Hardfault handler\n       *(irq_vector_table + 3) = (uint32_t)Stacktrace_Handler;\n       cm_backtrace_init(stringify(PROJECT_NAME), \"RA\", __DATE__ \"\\0\");\n    #endif\n\n    _init();\n     initVariant();\n    analogReference();\n\n   #ifndef NO_USB\n       __USBStart();\n       Serial.begin(115200);\n   #endif\n   startAgt();\n   #endif\n}\n\nvoid MW_ArduinoRaspberryPiPicoWInit(void)\n{\n    #if (defined(ARDUINO_RASPBERRY_PI_PICO_W) || defined(ARDUINO_RASPBERRY_PI_PICO))\n\n    #if F_CPU != 125000000\n        set_sys_clock_khz(F_CPU / 1000, true);\n    #endif\n        \n    rp2040.begin();\n    initVariant();\n    rp2040.enableDoubleResetBootloader();\n\n    #ifndef NO_USB\n    #ifdef USE_TINYUSB\n    TinyUSB_Device_Init(0);\n\n    #else\n    __USBStart();\n\n    #ifndef DISABLE_USB_SERIAL\n    // Enable serial port for reset/upload always\n    Serial.begin(115200);\n    #endif\n    #endif\n    #endif\n\n    #endif\n}\n\nvoid MW_Arduino_Init(void)\n{\n    //Hardware specific init for Arduino nano 33 ble sense\n    #if (defined(ARDUINO_ARDUINO_NANO33BLE))\n    MW_ArduinoNano33BLESenseInit();\n    #endif\n    #if defined(ARDUINO_NANO_RP2040_CONNECT)\n    MW_ArduinoNanoRP2040Init();\n    #endif\n    #if (defined(ARDUINO_RASPBERRY_PI_PICO_W) || defined(ARDUINO_RASPBERRY_PI_PICO))\n    MW_ArduinoRaspberryPiPicoWInit();\n    #endif\n    //Disable watchdog for Arduino Due. watchdog\n    #if (defined(_ROTH_DUE_))\n    watchdogDisable();\n    #endif\n    //Disable watchdog for ESP32\n    #if (defined(ESP_PLATFORM))\n    initArduino();\n    disableCore0WDT();\n    #endif\n\n    //Hardware specific init for Arduino UNO R4 WiFi\n    #if(defined(ARDUINO_ARCH_RENESAS_UNO))\n    UNOR4_Init();\n    #endif\n\n    /*\n    * Initialize Serial Peripheral\n    */\n    // Always Initialize Serial0\n    #if (defined(ESP_PLATFORM))\n    #else\n    Serial_begin(0, _RTT_BAUDRATE_SERIAL0_, _RTT_CONFIG_SERIAL0_);\n    #endif\n\n    /* Overrun Detection Initialization */\n    #ifdef _RTT_OVERRUN_DIGITAL_PIN_\n    pinMode(_RTT_OVERRUN_DIGITAL_PIN_, OUTPUT);\n\n    /* Init the overrun detection pin to zero or else the Pin is always in a\n    * high/tristate giving the user a wrong indication of overrun conditions */\n    digitalWrite(_RTT_OVERRUN_DIGITAL_PIN_, LOW);\n    #endif\n\n    /*\n    * Initialize Analog Reference Voltage\n    * Default - Due\n    * Default, Internal 1.1, Internal 2.56, External -  Mega 2560, Mega ADK\n    * Default, Internal 0.6, Internal 1.2, Internal 2.4 -  BLE Sense\n    * Default, Internal, External - Other Arduino targets\n    */\n    #if (defined(_ROTH_MEGA2560_))\n    #if (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 1))\n    analogReference(INTERNAL1V1);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 2))\n    analogReference(INTERNAL2V56);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 3))\n    analogReference(EXTERNAL);\n    #endif\n    #elif defined(ARDUINO_ARM_CORTEX_M0_PLUS)\n    #if (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 1))\n    analogReference(AR_INTERNAL1V0);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 2))\n    analogReference(AR_INTERNAL1V65);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 3))\n    analogReference(AR_INTERNAL2V23);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 4))\n    analogReference(AR_EXTERNAL);\n    #endif\n    #elif defined(ARDUINO_ARDUINO_NANO33BLE)\n    #if (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 1))\n    analogReference(AR_VDD);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 2))\n    analogReference(AR_INTERNAL);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 3))\n    analogReference(AR_INTERNAL1V2);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 4))\n    analogReference(AR_INTERNAL2V4);\n    #endif\n    #elif defined(ARDUINO_ARCH_RENESAS_UNO)\n    #if (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 1))\n    analogReference(AR_DEFAULT);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 2))\n    analogReference(AR_INTERNAL);\n    #endif\n    \n    #else\n    #if (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 1))\n    analogReference(INTERNAL);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 2))\n    analogReference(EXTERNAL);\n    #endif\n    #endif\n\n    /*\n    * Initialize SPI bus\n    */\n    //_RTT_SPI_SSPIN_ definition is applicable for all boards excluding Due\n    #if (defined(_RTT_SPI_SSPIN_)) || (defined(MW_ARDUINO_OV2640CSPIN))\n    MW_SPIwriteReadSetup();\n    #endif\n\n    //Initialize Modbus\n    int modStatus;\n    #if defined(_RTT_MODBUS_MASTER_)\n    modStatus = ModbusRTUClient.begin(_RTT_RS485_BAUD_, _RTT_RS485_CONFIG_);\n    ModbusRTUClient.setTimeout(_RTT_MODBUS_MASTERTIMEOUT_/1000);\n    #endif\n\n    #if defined(_RTT_MODBUS_SLAVE_)\n    modStatus = ModbusRTUServer.begin(_RTT_MODBUS_SLAVEID_, _RTT_RS485_BAUD_, _RTT_RS485_CONFIG_);\n    #if defined(_RTT_MODBUS_CONFIGCOIL_)\n    ModbusRTUServer.configureCoils(_RTT_MODBUS_COILADDR_,_RTT_MODBUS_COILNUM_);\n    #endif\n    #if defined(_RTT_MODBUS_CONFIGINPUT_)\n    ModbusRTUServer.configureDiscreteInputs(_RTT_MODBUS_INPUPTADDR_,_RTT_MODBUS_INPUTNUM_);\n    #endif\n    #if defined(_RTT_MODBUS_CONFIGHOLDINGREG_)\n    ModbusRTUServer.configureHoldingRegisters(_RTT_MODBUS_HOLDINGREGADDR_,_RTT_MODBUS_HOLDINGREGNUM_);\n    #endif\n    #if defined(_RTT_MODBUS_CONFIGINPUTREG_)\n    ModbusRTUServer.configureInputRegisters(_RTT_MODBUS_INPUTREGADDR_,_RTT_MODBUS_INPUTREGNUM_);\n    #endif\n    #endif\n    /*\n    * Initialize wifi\n    */\n    #if (defined(_RTT_WIFI_UDP_) && (_RTT_WIFI_UDP_ != 0)) || (defined(_RTT_WIFI_TCP_) && (_RTT_WIFI_TCP_ != 0))|| defined(_RTT_THINGSPEAK_WIFI_) || defined(_RTT_WEBSOCKET_PORT_) || defined(_RTT_MQTT_WIFI_) || defined(_RTT_HTTP_CLIENT_) || defined(OTA_SETUP) || defined(OTA_UPLOAD)\n    /* Begin WiFi*/\n    while(configureSuccess!=WL_CONNECTED)\n    {\n        #if (defined(_RTT_DISABLE_Wifi_DHCP_) && (_RTT_DISABLE_Wifi_DHCP_ !=0))\n            #if defined(ESP_PLATFORM)\n                #if (_RTT_DISABLE_Wifi_DHCP_ == 1)\n                WiFi.config(wifiLocalIpAddress,wifigateway, subnet, dns1, dns2);\n                #else\n                WiFi.config(wifiLocalIpAddress, wifiGatewayAddress, wifiSubnetMask, wifiDNSAddress);\n                #endif\n            #elif (_RTT_DISABLE_Wifi_DHCP_ == 1)\n            WiFi.config(wifiLocalIpAddress);\n            #else\n            WiFi.config(wifiLocalIpAddress, wifiDNSAddress, wifiGatewayAddress, wifiSubnetMask);\n            #endif\n        #endif\n\n        #ifdef _RTT_WIFI_WEP\n        configureSuccess=WiFi.begin(ssid,keyIndex,key);\n        #endif //_RTT_WIFI_WEP\n\n        #ifdef _RTT_WIFI_WPA\n        configureSuccess=WiFi.begin(ssid,wpapass);\n        #endif //_RTT_WIFI_WPA\n\n        #ifdef _RTT_WIFI_WPA2_ENTERPRISE\n        #if defined(ESP_PLATFORM) \n        WiFi.disconnect(true);  //disconnect form wifi to set new wifi connection\n        WiFi.mode(WIFI_STA); //init wifi mode\n        configureSuccess = WiFi.begin(ssid, WPA2_AUTH_PEAP, wpa2username, wpa2username, wpa2password); //connect to wifi\n        \n        #elif defined(ARDUINO_UNOR4_WIFI)\n        WiFi.disconnect();  //disconnect form wifi to set new wifi connection\n        int extmodewifistatus = WiFi.begin(ssid,wpa2password); //connect to wifi\n        while (WiFi.status() != WL_CONNECTED) {\n            delay(500);\n        }\n        extmodewifistatus = WL_CONNECTED;\n\n        #elif defined(ARDUINO_WIFI_LIB_NINA)\n        configureSuccess=WiFi.beginEnterprise(ssid,wpa2username,wpa2password);\n        #endif\n        #endif //_RTT_WIFI_WPA2_ENTERPRISE\n\n        #ifdef _RTT_WIFI_NONE\n        configureSuccess=WiFi.begin(ssid);\n        #endif //_RTT_WIFI_NONE\n\n        #if (defined(ESP_PLATFORM)) || defined(ARDUINO_UNOR4_WIFI)\n        while (WiFi.status() != WL_CONNECTED) {\n            delay(500);\n        }\n        configureSuccess=WL_CONNECTED;\n        #else\n        //Wait for 10 seconds for Wifi connection to happen\n        unsigned long startMillis  = millis();\n        while(millis()- startMillis < 1000)\n        {\n        };\n        #endif // ESP_PLATFORM\n    }\n\n    #if (!defined(OTA_UPLOAD)) // Don't need serial open for OTA upload\n    /* Wait for Serial0 to be up*/\n    for(trialcount=0;trialcount<5;trialcount++)\n    {\n        if(Serial)\n        {\n            break;\n        }else\n        {\n            unsigned long startMillis  = millis();\n            while(millis()- startMillis < 1000)\n            {\n            };\n        }\n    }\n    \n    #if (!(defined(_RTT_WIFI_EXTMODE_) && (_RTT_WIFI_EXTMODE_ == 1)))\n    if (configureSuccess==WL_CONNECTED)\n    {\n        // If the Configuration is successful, relay back the assigned IP address.\n        #if (defined(ESP_PLATFORM)) || defined(ARDUINO_UNOR4_WIFI)\n        Serial_begin(0, _RTT_BAUDRATE_SERIAL0_, _RTT_CONFIG_SERIAL0_);\n        #endif\n        IPAddress ip = WiFi.localIP();\n        //Adding a precautionary check using a Serial command so as to print the IP address so that it is available at least 6 times\n        //and the chances of it not being assigned to Target are minimised.\n        int ipSendcounter = 0; // Initialize counter\n        while ((Serial.read()!= 0xaa)  && ipSendcounter < ( _RTT_WIFI_TIMEOUT * 2)){\n         ipSendcounter++; // Increment counter at the end of each loop iteration\n            delay(500);\n        }\n    \n        Serial.print(\"<<< IP address :\");\n        Serial.print(ip);\n        Serial.println(\" >>>\");\n    \n    }\n    else\n    {\n        // If the Configuration failed,relay back the error message.\n        Serial.println(\"<<< IP address :Failed to configure. >>>\");\n        Serial.print(_RTT_WIFI_TIMEOUT);\n    }\n    #endif //(!(defined(_RTT_WIFI_EXTMODE_) && (_RTT_WIFI_EXTMODE_ == 1)))\n    #endif //(!defined(OTA_UPLOAD))\n\n    #endif /*Initialize wifi*/\n\n    // Enable OTA handler\n    #if defined(OTA_SETUP) || defined(OTA_UPLOAD)\n    MW_OTA_Setup();\n    #endif\n\n    #ifdef NANO_MOTOR_CARRIER\n    MW_EnableNanoCarrierBatteryCharging();\n    #endif\n    #ifdef _MW_DASHBOARD_BLOCK_PRESENT_\n    MW_initScreen();\n    #endif\n\n    #if defined(ARDUINO_ARCH_SAMD) && defined(MW_SAMD_EVSYS_ENABLE)\n    PM->APBCMASK.reg |= PM_APBCMASK_EVSYS;                                              // Switch on the event system peripheral\n    #if defined(MW_SAMD_EVSYS_CH0)\n    EVSYS->USER.reg = EVSYS_USER_CHANNEL(1) |                                           // Attach the event user (receiver) to channel 0 (n + 1)\n        EVSYS_USER_USER(EVSYS_CH0_USER_EVENT);                            // Set the event user (receiver) as EVSYS_CH1_USER_EVENT\n    EVSYS->CHANNEL.reg = EVSYS_CHANNEL_EDGSEL_NO_EVT_OUTPUT |                           // No event edge detection\n        EVSYS_CHANNEL_PATH_ASYNCHRONOUS |                              // Set event path as asynchronous\n        EVSYS_CHANNEL_EVGEN(EVSYS_CH0_GEN_EVENT) |                     // Set event generator (sender) as EVSYS_CH1_GEN_EVENT\n        EVSYS_CHANNEL_CHANNEL(0);                                      // Attach the generator (sender) to channel 0\n    EVSYS_CH0_USER->EVCTRL.reg |= EVSYS_CH0_USER_START_CMD;\n    EVSYS_CH0_GEN->EVCTRL.reg |= EVSYS_CH0_GEN_START_CMD;\n    #endif\n    #if defined(MW_SAMD_EVSYS_CH1)\n    EVSYS->USER.reg = EVSYS_USER_CHANNEL(2) |                                           // Attach the event user (receiver) to channel 1 (n + 1)\n        EVSYS_USER_USER(EVSYS_CH1_USER_EVENT);                            // Set the event user (receiver) as EVSYS_CH2_USER_EVENT\n    EVSYS->CHANNEL.reg = EVSYS_CHANNEL_EDGSEL_NO_EVT_OUTPUT |                           // No event edge detection\n        EVSYS_CHANNEL_PATH_ASYNCHRONOUS |                              // Set event path as asynchronous\n        EVSYS_CHANNEL_EVGEN(EVSYS_CH1_GEN_EVENT) |                     // Set event generator (sender) as EVSYS_CH2_GEN_EVENT\n        EVSYS_CHANNEL_CHANNEL(1);                                      // Attach the generator (sender) to channel 1\n    EVSYS_CH1_USER->EVCTRL.reg |= EVSYS_CH1_USER_START_CMD;\n    EVSYS_CH1_GEN->EVCTRL.reg |= EVSYS_CH1_GEN_START_CMD;\n    #endif\n    #if defined(MW_SAMD_EVSYS_CH2)\n    EVSYS->USER.reg = EVSYS_USER_CHANNEL(3) |                                           // Attach the event user (receiver) to channel 2 (n + 1)\n        EVSYS_USER_USER(EVSYS_CH2_USER_EVENT);                            // Set the event user (receiver) as EVSYS_CH3_USER_EVENT\n    EVSYS->CHANNEL.reg = EVSYS_CHANNEL_EDGSEL_NO_EVT_OUTPUT |                           // No event edge detection\n        EVSYS_CHANNEL_PATH_ASYNCHRONOUS |                              // Set event path as asynchronous\n        EVSYS_CHANNEL_EVGEN(EVSYS_CH2_GEN_EVENT) |                     // Set event generator (sender) as EVSYS_CH3_GEN_EVENT\n        EVSYS_CHANNEL_CHANNEL(2);                                      // Attach the generator (sender) to channel 2\n    EVSYS_CH2_USER->EVCTRL.reg |= EVSYS_CH2_USER_START_CMD;\n    EVSYS_CH2_GEN->EVCTRL.reg |= EVSYS_CH2_GEN_START_CMD;\n    #endif\n    #if defined(MW_SAMD_EVSYS_CH3)\n    EVSYS->USER.reg = EVSYS_USER_CHANNEL(4) |                                           // Attach the event user (receiver) to channel 3 (n + 1)\n        EVSYS_USER_USER(EVSYS_CH3_USER_EVENT);                            // Set the event user (receiver) as EVSYS_CH4_USER_EVENT\n    EVSYS->CHANNEL.reg = EVSYS_CHANNEL_EDGSEL_NO_EVT_OUTPUT |                           // No event edge detection\n        EVSYS_CHANNEL_PATH_ASYNCHRONOUS |                              // Set event path as asynchronous\n        EVSYS_CHANNEL_EVGEN(EVSYS_CH3_GEN_EVENT) |                     // Set event generator (sender) as EVSYS_CH4_GEN_EVENT\n        EVSYS_CHANNEL_CHANNEL(3);                                      // Attach the generator (sender) to channel 3\n    EVSYS_CH3_USER->EVCTRL.reg |= EVSYS_CH3_USER_START_CMD;\n    EVSYS_CH3_GEN->EVCTRL.reg |= EVSYS_CH3_GEN_START_CMD;\n    #endif\n    #endif\n}\n/* Function: MW_Arduino_Terminate ================================================\n* For Arduino MKR/Leonardo and its variants, the Virtual COM port is handled\n* by the controller. In case the code running on the target exits main,\n* the COM port cannot be accessed until a hard reset is performed.\n* To over come this issue, a while loop is added to make sure that\n* upon getting a stop command from external mode, the code running on\n* the target stops but the code will not exit the main.\n* This will ensure that the COM port is accessible even after the\n* external mode has been stopped. */\nvoid MW_Arduino_Terminate(void){\n    \n    #if(defined(ARDUINO_UNOR4_MINIMA))\n    while(1){};\n    #endif\n\n    #if defined(ARDUINO_VIRTUAL_COM_PORT) || (defined(ARDUINO_ARDUINO_NANO33BLE) && (!defined(USE_MBEDRTOS))) || defined(__IMXRT1062__) || (defined(ARDUINO_NANO_RP2040_CONNECT) && (!defined(USE_MBEDRTOS))) || defined(ARDUINO_RASPBERRY_PI_PICO_W) || defined(ARDUINO_RASPBERRY_PI_PICO)\n    disable_rt_OneStep();\n    while(1){};     /* To continue virtual COM port functionality */\n    #endif    \n}\n\n#ifdef NANO_MOTOR_CARRIER\nvoid MW_EnableNanoCarrierBatteryCharging(void) {\n    Wire.begin();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG00);\n    Wire.write(0x06); // min sys voltage 3.88V + max input current 2.0 A\n    Wire.endTransmission();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG01);\n    Wire.write(0x1B); // Charge Battery + Minimum System Voltage 3.5V\n    Wire.endTransmission();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG02);\n    Wire.write(0x00); // Charge current  512 mA\n    Wire.endTransmission();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG04);\n    Wire.write(0x9E); // Charge Voltage Limit 4.128V\n    Wire.endTransmission();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG05);\n    Wire.write(0x8A); // Enable Battery Charge termination + disable watchdog\n    Wire.endTransmission();\n}\n#endif\n\n\n// Overrun detection function for ESP32\n#if defined(ESP_PLATFORM) && defined(_RTT_OVERRUN_DIGITAL_PIN_)\nvoid onOverrunDetect(int id)\n{\n    digitalWrite(_RTT_OVERRUN_DIGITAL_PIN_, HIGH);\n}\n#endif\n// LocalWords:  AVR Bareboard ADK SPI RTT SSPIN Modbus MKR"},{"name":"MW_PWM.cpp","type":"source","group":"legacy","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/../../../Documents/MATLAB/SupportPackages/R2025b/toolbox/target/supportpackages/arduinobase/src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2015-2024 The MathWorks, Inc. */\n\n#include \"MW_PWM.h\"\n#include \"MW_PWMDriver.h\"\n\n#if (defined(ESP_PLATFORM))\n//#include \"soc/soc_caps.h\" This file is present in new core of esp32. Uncomment and remove SOC_GPIO_PIN_COUNT defination once esp32 core is updated\n#define SOC_GPIO_PIN_COUNT              40\n#endif\n\n#if defined(ARDUINO_ARCH_RENESAS_UNO)\n#include \"pwm.h\"\n\n// Define the number of PWM pins\n#define NUM_PWM_PINS 6\n\n// Create an array of PwmOut objects\nstatic PwmOut* pwmObjects[NUM_PWM_PINS];\nstatic uint8_T pwmPinIndex[NUM_PWM_PINS];\nstatic uint8_T pwmPinCounter = 0;\n\n\n// Create a PwmOut object for a specified pin and add it to the array\nvoid createPwmObject(int pin) {\n    pwmObjects[pwmPinCounter] = new PwmOut(pin);\n    pwmPinIndex[pwmPinCounter] = (uint8_T)pin;\n    pwmPinCounter++;\n    if (pwmPinCounter>= NUM_PWM_PINS) {\n        // A safeguard to avoid accidental out-of-bound access\n        pwmPinCounter = NUM_PWM_PINS-1;\n    }\n}\n\n\nint getIndexForPWMPin(int pin) {\n    int i=0;\n    int idx = 0;\n    for (i=0;i<NUM_PWM_PINS;i++) {\n        if (pin==pwmPinIndex[i]) {\n            idx = i;\n            break;\n        }\n    }\n    return idx;\n}\n\n#endif\n\n#if !(( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) ))\n#include \"Arduino.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n    #endif\n\n    #define PWM_MODULES_MAX 70  /* For Mega and Due. Other boards have less number of Modules */\n    static uint8_T PinMapTable[MW_NUM_PINS]={0};\n    #if (defined(ARDUINO_ARDUINO_NANO33BLE))\n    uint32_t nano33BLE_dutycycle[21];\n    uint16_t nano33BLE_period[21];\n    #endif\n\n    typedef uint8_T PeripheralHandleMapType;\n    extern PeripheralHandleMapType PWMPinHandleMap[];     /* The array is defined in ArduinoPinHandleMap.cpp */\n\n    /* For PWM SVd provides no function to get the handle */\n    MW_Handle_Type MW_PWM_GetHandle(uint32_T Pin);\n    void setPWMHandle(uint32_T Pin, MW_Handle_Type handle);\n\n    #if (defined(ESP_PLATFORM))\n    #define ESP32_PWM_RESOLUTION            8\n    #if (defined(_RTT_NUMSERVOS_) && (_RTT_NUMSERVOS_ != 0))\n    #define LAST_CHAN (8)\n    #else\n    #define LAST_CHAN (16)\n    #endif\n    static int8_t pin_to_channel[SOC_GPIO_PIN_COUNT] = { 0 };\n    static int channelCounter = LAST_CHAN;\n    #endif\n\n    /* PWM Initialisation selected by the pinNumber (PWM Channel) */\n    MW_Handle_Type MW_PWM_Open(uint32_T pin, real_T prescaler, real_T period)\n    {\n        #if ( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n        /* This will be run in Rapid Accelerator Mode */\n        return NULL;\n        #else\n        #if (defined(ESP_PLATFORM))\n        if (pin < SOC_GPIO_PIN_COUNT) {\n            if (pin_to_channel[pin] == 0) {\n                if (!channelCounter) {\n                    log_e(\"No more analogWrite channels available! You can have maximum %u\", LAST_CHAN);\n                    return 0;\n                }\n                pinMode(pin,OUTPUT);\n                pin_to_channel[pin] = channelCounter ;\n                ledcAttachPin(pin, channelCounter-1);\n                if(prescaler == 0)                    // Default frequency\n                {\n                    ledcSetup(channelCounter-1, ARDUINO_DEFAULT_PWM_FREQUENCY, ESP32_PWM_RESOLUTION);\n                }\n                else\n                {\n                    ledcSetup(channelCounter-1, prescaler, ESP32_PWM_RESOLUTION);\n                }\n                if(period>0)\n                {\n                    channelCounter = channelCounter-2;    // Use only one channel from channel pair\n                }\n                else\n                {\n                    channelCounter = channelCounter-1;\n                }\n\n            }\n            ledcWrite(pin_to_channel[pin] - 1, 0);\n        }else{\n            return 0;\n        }\n        setPWMHandle(pin, (MW_Handle_Type)(pin+1));\n        return (MW_Handle_Type)(pin+1);\n\n        #elif defined(__IMXRT1062__)\n        #include \"core_pins.h\"\n        if(prescaler > 0)                    // Specify Frequency\n        {\n            PinMapTable[pin]=1;\n            analogWriteFrequency(pin,prescaler);\n        }\n        setPWMHandle(pin, (MW_Handle_Type)(pin+1));\n        return (MW_Handle_Type)(pin+1);\n        \n        #else\n        pinMode(pin,OUTPUT);\n\n        #if (defined(ARDUINO_ARDUINO_NANO33BLE))\n        nano33BLE_dutycycle[pin] = 0;\n        nano33BLE_period[pin] = 1000000/500;\n\n        #elif (defined(ARDUINO_NANO_RP2040_CONNECT) || defined(ARDUINO_RASPBERRY_PI_PICO_W) || defined(ARDUINO_RASPBERRY_PI_PICO))\n        // RP2040 uses a hardware PWM, hence we need to use the prescaler,period values based on the default frequency configset parameter\n        if(prescaler == 0)                    // Default frequency\n        {\n            MW_setAnalogFrequency(pin, ARDUINO_RP2040_DEFAULT_PWM_PRESCALER, ARDUINO_RP2040_DEFAULT_PWM_PERIOD);\n        }\n        #endif\n        /* handle is stored as Pin+1 because, to reset the handle of a pin, 0 is passed as handle. Otherwise it will create confusion for Pin number 0. */\n        setPWMHandle(pin, (MW_Handle_Type)(pin+1));\n\n        if(period>0) /*Initialization needed for specify frequnecy*/\n        {\n            PinMapTable[pin]=1;\n            #if defined(ARDUINO_ARCH_RENESAS_UNO)\n            createPwmObject(pin);\n            pwmObjects[pwmPinCounter-1]->begin(prescaler, 0, false, TIMER_SOURCE_DIV_1);\n            #else\n            MW_setAnalogFrequency(pin, prescaler,period);\n            #endif\n        }\n        return (MW_Handle_Type)(pin+1);\n        #endif\n        #endif\n    }\n\n    /* Start PWM */\n    void MW_PWM_Start(MW_Handle_Type PWMPinHandle)\n    {\n        (void)PWMPinHandle;\n    }\n\n    /* Set the duty cycle or pulse width for the PWM signal */\n    void MW_PWM_SetDutyCycle(MW_Handle_Type PWMPinHandle, real_T dutyCycle)\n    {\n        #if ( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n        /* This will be run in Rapid Accelerator Mode */\n        (void)PWMPinHandle;\n        (void)dutyCycle;\n        return;\n        #else\n        #if (defined(ESP_PLATFORM))\n        uint8_T pin;\n        if(*((uint8_T*)(&PWMPinHandle)))\n        {\n            /* The handle of a Pin is stored as (Pin+1) */\n            pin =  *((uint8_T*)(&PWMPinHandle)) - 1;\n            if(dutyCycle < 0)       /* Changed frequency */\n            {\n                dutyCycle = dutyCycle * -1;\n            }\n            ledcWrite(pin_to_channel[pin] - 1, dutyCycle);\n        }\n        #elif defined(__IMXRT1062__)\n        uint8_T pin;\n        if(*((uint8_T*)(&PWMPinHandle)))\n        {\n            /* The handle of a Pin is stored as (Pin+1) */\n            pin =  *((uint8_T*)(&PWMPinHandle)) - 1;\n            if(PinMapTable[pin]==1)       /* Changed frequency */\n            {\n                dutyCycle = dutyCycle * -1;\n            }\n\n            analogWrite(pin, dutyCycle);\n        }\n\n        #elif defined(ARDUINO_ARCH_RENESAS_UNO)\n        uint8_T pin;\n        if(*((uint8_T*)(&PWMPinHandle))) \n        {\n            /* The handle of a Pin is stored as (Pin+1) */\n            pin =  *((uint8_T*)(&PWMPinHandle)) - 1;\n            if(PinMapTable[pin]==1)       /* Specify frequency */\n            {\n                dutyCycle = dutyCycle * -1; \n                int locPinIndex = getIndexForPWMPin(pin);\n                pwmObjects[locPinIndex]->pulse_perc((float)(dutyCycle * 100) / 255);\n            }\n            else\n            {\n            analogWrite(pin, dutyCycle);  /* Default frequency*/\n            }\n        }\n\n        #else\n        uint8_T pin;\n        /* If the PWM handle is 0 then do nothing. */\n        if(*((uint8_T*)(&PWMPinHandle)))\n        {\n            /* The handle of a Pin is stored as (Pin+1) */\n            pin =  *((uint8_T*)(&PWMPinHandle)) - 1;\n            if( PinMapTable[pin]==1)       /* make sure MW_analogWrite gets executed at Specify Frequency*/\n            {\n                dutyCycle = dutyCycle * -1;\n                MW_analogWrite(pin, dutyCycle);\n            }\n            else                    /* Default frequency*/\n            {\n                #if defined(ARDUINO_ARDUINO_NANO33BLE)\n                nano33BLE_period[pin] = 1000000/500; //Default frequency of 500Hz\n                nano33BLE_dutycycle[pin] = (dutyCycle* nano33BLE_period[pin]/255);\n                #elif (defined(ARDUINO_NANO_RP2040_CONNECT) || defined(ARDUINO_RASPBERRY_PI_PICO_W) || defined(ARDUINO_RASPBERRY_PI_PICO))\n                MW_analogWrite(pin, ((dutyCycle/255) * ARDUINO_RP2040_DEFAULT_PWM_PERIOD));\n                #else\n                analogWrite(pin, dutyCycle);\n                #endif\n            }\n        }\n        #endif\n        #endif\n    }\n\n    /* Set the PWM signal frequency */\n    void MW_PWM_SetFrequency(MW_Handle_Type PWMPinHandle, real_T frequency)\n    {\n        (void)PWMPinHandle;\n        (void)frequency;\n    }\n\n    /* Disable notifications on the channel */\n    void MW_PWM_DisableNotification(MW_Handle_Type PWMPinHandle)\n    {\n        (void)PWMPinHandle;\n    }\n\n    /* Enable notifications on the channel */\n    void MW_PWM_EnableNotification(MW_Handle_Type PWMPinHandle, MW_PWM_EdgeNotification_Type Notification)\n    {\n        (void)PWMPinHandle;\n        (void)Notification;\n    }\n\n    /* Set PWM output to idle state */\n    void MW_PWM_SetOutputToIdle(MW_Handle_Type PWMPinHandle)\n    {\n        (void)PWMPinHandle;\n    }\n\n    /* Get the PWM output status */\n    boolean_T MW_PWM_GetOutputState(MW_Handle_Type PWMPinHandle)\n    {\n        (void)PWMPinHandle;\n        return 0;\n    }\n\n    /* Stop PWM */\n    void MW_PWM_Stop(MW_Handle_Type PWMPinHandle)\n    {\n        (void)PWMPinHandle;\n    }\n\n    /* Close PWM */\n    void MW_PWM_Close(MW_Handle_Type PWMPinHandle)\n    {\n        #if ( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n        return;\n        #else\n        /* If the PWM handle is 0 then do nothing. */\n        if(*((uint8_T*)(&PWMPinHandle)))\n        {\n            uint8_T pin = 0;\n            /* The handle of a Pin is stored as (Pin+1) */\n            pin =  *((uint8_T*)(&PWMPinHandle)) - 1;\n            setPWMHandle(pin, (MW_Handle_Type)0);\n        }\n        (void)PWMPinHandle;\n        #endif\n    }\n\n    MW_Handle_Type MW_PWM_GetHandle(uint32_T Pin)\n    {\n        #if ( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n        return NULL;\n        #else\n        uint16_T ByteNo=0, handleValue=0;\n\n        uint8_T BitPositionNo=0;\n\n        ByteNo = Pin/8;\n        BitPositionNo = Pin%8;\n\n        handleValue = PWMPinHandleMap[ByteNo] & (PeripheralHandleMapType)(1<<BitPositionNo);\n\n        if(handleValue)\n        {\n            /*\n            Returns the value of the module if the pin is opened earlier\n            */\n            handleValue = Pin+1;\n            /*\n            This allows to differentiate between pin zero and a Null condition\n\n            Another option - return true, and then remove the decrement in the SVD of all functions in Arduino\n            */\n        }\n        else\n        {\n            handleValue = 0;\n        }\n        return (MW_Handle_Type)handleValue;\n        #endif\n    }\n\n    void setPWMHandle(uint32_T module, MW_Handle_Type handle)\n    {\n        #if ( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n        return;\n        #else\n        /*\n        Assumes pin number from count zero\n        */\n        uint16_T ByteNo=0;\n        uint8_T BitPositionNo=0;\n        PeripheralHandleMapType tempVar=0;\n        /*\n        Integer division rounds off to value providing the abs byte no\n        */\n        ByteNo = module/8;\n        BitPositionNo = module%8;\n\n        tempVar = (1<<BitPositionNo);\n        /*\n        The assumption is module number is the handle,\n        but when handle is Null, reset the handle\n        */\n        if(!handle)\n        {\n            /*reset the handle*/\n            tempVar = ~tempVar;\n            PWMPinHandleMap[ByteNo] = PWMPinHandleMap[ByteNo] & tempVar;\n        }\n        else\n        {\n            /*set the handle*/\n            PWMPinHandleMap[ByteNo] = PWMPinHandleMap[ByteNo] | tempVar;\n        }\n        #endif\n    }\n\n    #ifdef __cplusplus\n}\n#endif\n#else\nMW_Handle_Type MW_PWM_Open(uint32_T pin, real_T frequency, real_T dutyCycle){return 0;}\nvoid MW_PWM_Start(MW_Handle_Type PWMPinHandle){}\nvoid MW_PWM_SetDutyCycle(MW_Handle_Type PWMPinHandle, real_T dutyCycle){}\nvoid MW_PWM_SetFrequency(MW_Handle_Type PWMPinHandle, real_T frequency){}\nvoid MW_PWM_DisableNotification(MW_Handle_Type PWMPinHandle){}\nvoid MW_PWM_EnableNotification(MW_Handle_Type PWMPinHandle, MW_PWM_EdgeNotification_Type Notification){}\nvoid MW_PWM_SetOutputToIdle(MW_Handle_Type PWMPinHandle){}\nboolean_T MW_PWM_GetOutputState(MW_Handle_Type PWMPinHandle){return 0;}\nvoid MW_PWM_Stop(MW_Handle_Type PWMPinHandle){}\nvoid MW_PWM_Close(MW_Handle_Type PWMPinHandle){}\nMW_Handle_Type MW_PWM_GetHandle(uint32_T Pin){return 0;}\n#endif\n"},{"name":"MW_PWMDriver.c","type":"source","group":"legacy","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/../../../Documents/MATLAB/SupportPackages/R2025b/toolbox/target/supportpackages/arduinobase/src","tag":"","groupDisplay":"Other files","code":"/*\n * Code to configure Timer and set duty cycle\n * This file is modified version of wiring_analog.c file\n * It separates analogWrite function into two parts:\n * 1. MW_setAnalogFrequency: This function initializes PWM peripheral\n * 2. MW_analogWrite: This function sets the duty cycle\n * /* Copyright 2019-2024 The MathWorks, Inc. */\n\n#include \"MW_PWMDriver.h\"\n\n#if !( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n\n#if defined(ARDUINO_ARCH_SAMD)                                                          /* SAMD Targets */\n#include \"Arduino.h\"\n#include \"wiring_private.h\"\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstatic int _writeResolution = 8;\n\n// Wait for synchronization of registers between the clock domains\nstatic __inline__ void syncDAC() __attribute__((always_inline, unused));\nstatic void syncDAC() {\n  while (DAC->STATUS.bit.SYNCBUSY == 1)\n    ;\n}\n\n// Wait for synchronization of registers between the clock domains\nstatic __inline__ void syncTC_8(Tc* TCx) __attribute__((always_inline, unused));\nstatic void syncTC_8(Tc* TCx) {\n  while (TCx->COUNT8.STATUS.bit.SYNCBUSY);\n}\n\n// Wait for synchronization of registers between the clock domains\nstatic __inline__ void syncTCC(Tcc* TCCx) __attribute__((always_inline, unused));\nstatic void syncTCC(Tcc* TCCx) {\n  while (TCCx->SYNCBUSY.reg & TCC_SYNCBUSY_MASK);\n}\n\nstatic inline uint32_t mapResolution(uint32_t value, uint32_t from, uint32_t to)\n{\n  if (from == to) {\n    return value;\n  }\n  if (from > to) {\n    return value >> (from-to);\n  }\n  return value << (to-from);\n}\n\nvoid MW_analogWrite(uint32_t pin, uint32_t value)\n{\n  PinDescription pinDesc = g_APinDescription[pin];\n  uint32_t attr = pinDesc.ulPinAttribute;\n\n  if ((attr & PIN_ATTR_ANALOG) == PIN_ATTR_ANALOG)\n  {\n    // DAC handling code\n\n    if ((pinDesc.ulADCChannelNumber != ADC_Channel0) && (pinDesc.ulADCChannelNumber != DAC_Channel0)) { // Only 1 DAC on AIN0 / PA02\n      return;\n    }\n\n    value = mapResolution(value, _writeResolution, 10);\n\n    syncDAC();\n    DAC->DATA.reg = value & 0x3FF;  // DAC on 10 bits.\n    syncDAC();\n    DAC->CTRLA.bit.ENABLE = 0x01;     // Enable DAC\n    syncDAC();\n    return;\n  }\n\n  if ((attr & PIN_ATTR_PWM) == PIN_ATTR_PWM)\n  {\n    //value = mapResolution(value, _writeResolution, 16);\n\n    uint32_t tcNum = GetTCNumber(pinDesc.ulPWMChannel);\n    uint8_t tcChannel = GetTCChannelNumber(pinDesc.ulPWMChannel);\n\n    if (attr & PIN_ATTR_TIMER) {\n      #if !(ARDUINO_SAMD_VARIANT_COMPLIANCE >= 10603)\n      // Compatibility for cores based on SAMD core <=1.6.2\n      if (pinDesc.ulPinType == PIO_TIMER_ALT) {\n        pinPeripheral(pin, PIO_TIMER_ALT);\n      } else\n      #endif\n      {\n        pinPeripheral(pin, PIO_TIMER);\n      }\n    } else {\n      // We suppose that attr has PIN_ATTR_TIMER_ALT bit set...\n      pinPeripheral(pin, PIO_TIMER_ALT);\n    }\n\n    \n    if (tcNum >= TCC_INST_NUM) {\n        Tc* TCx = (Tc*) GetTC(pinDesc.ulPWMChannel);\n        TCx->COUNT8.CC[tcChannel].reg = (uint32_t) value;\n        syncTC_8(TCx);\n    } else {\n        Tcc* TCCx = (Tcc*) GetTC(pinDesc.ulPWMChannel);\n        //Disabling the double buffer lock for now.\n        //If this is enabled, in double slope mode,\n        //Counter wraparound occurs which results in \n        //unexpected duty cycles. This needs to be fixed/\n        //Not behaving as per datasheet\n        //TCCx->CTRLBSET.bit.LUPD = 1;\n        //syncTCC(TCCx);\n        TCCx->CCB[tcChannel].reg = (uint32_t) value;\n        syncTCC(TCCx);\n        //TCCx->CTRLBCLR.bit.LUPD = 1;\n        //syncTCC(TCCx);\n    }\n    return;\n  }\n\n  // -- Defaults to digital write\n  pinMode(pin, OUTPUT);\n  value = mapResolution(value, _writeResolution, 8);\n  if (value < 128) {\n    digitalWrite(pin, LOW);\n  } else {\n    digitalWrite(pin, HIGH);\n  }\n}\n\nvoid MW_setAnalogFrequency(uint16_t pin,uint16_t prescaler,uint16_t period)\n{\n  uint32_t value = 0;                 \n  PinDescription pinDesc = g_APinDescription[pin];\n  uint32_t attr = pinDesc.ulPinAttribute;\n\n  if ((attr & PIN_ATTR_PWM) == PIN_ATTR_PWM)\n  {\n    //value = mapResolution(value, _writeResolution, 16);\n    uint32_t tcNum = GetTCNumber(pinDesc.ulPWMChannel);\n    uint8_t tcChannel = GetTCChannelNumber(pinDesc.ulPWMChannel);\n    static bool tcEnabled[TCC_INST_NUM+TC_INST_NUM];\n\n    if (attr & PIN_ATTR_TIMER) {\n      #if !(ARDUINO_SAMD_VARIANT_COMPLIANCE >= 10603)\n      // Compatibility for cores based on SAMD core <=1.6.2\n      if (pinDesc.ulPinType == PIO_TIMER_ALT) {\n        pinPeripheral(pin, PIO_TIMER_ALT);\n      } else\n      #endif\n      {\n        pinPeripheral(pin, PIO_TIMER);\n      }\n    } else {\n      // We suppose that attr has PIN_ATTR_TIMER_ALT bit set...\n      pinPeripheral(pin, PIO_TIMER_ALT);\n    }\n\n    if (!tcEnabled[tcNum]) {\n      tcEnabled[tcNum] = true;\n\n      uint16_t GCLK_CLKCTRL_IDs[] = {\n        GCLK_CLKCTRL_ID(GCM_TCC0_TCC1), // TCC0\n        GCLK_CLKCTRL_ID(GCM_TCC0_TCC1), // TCC1\n        GCLK_CLKCTRL_ID(GCM_TCC2_TC3),  // TCC2\n        GCLK_CLKCTRL_ID(GCM_TCC2_TC3),  // TC3\n        GCLK_CLKCTRL_ID(GCM_TC4_TC5),   // TC4\n        GCLK_CLKCTRL_ID(GCM_TC4_TC5),   // TC5\n        GCLK_CLKCTRL_ID(GCM_TC6_TC7),   // TC6\n        GCLK_CLKCTRL_ID(GCM_TC6_TC7),   // TC7\n      };\n      GCLK->CLKCTRL.reg = (uint16_t) (GCLK_CLKCTRL_CLKEN | GCLK_CLKCTRL_GEN_GCLK0 | GCLK_CLKCTRL_IDs[tcNum]);\n      while (GCLK->STATUS.bit.SYNCBUSY == 1);\n\n      // Set PORT\n      if (tcNum >= TCC_INST_NUM) {\n        // -- Configure TC\n        Tc* TCx = (Tc*) GetTC(pinDesc.ulPWMChannel);\n        // Disable TCx\n        TCx->COUNT8.CTRLA.bit.ENABLE = 0;\n        syncTC_8(TCx);\n        // Set Timer counter Mode to 16 bits, normal PWM\n        TCx->COUNT8.CTRLA.reg |= TC_CTRLA_MODE_COUNT8 | TC_CTRLA_WAVEGEN_NPWM | (prescaler<<8);\n        syncTC_8(TCx);\n        // Set the initial value\n        TCx->COUNT8.CC[tcChannel].reg = (uint32_t) value;\n        syncTC_8(TCx);\n        //freq is fTC/(N*(TOP+1))\n        TCx->COUNT8.PER.reg = period - 1;\n        syncTC_8(TCx);\n        // Enable TCx\n        TCx->COUNT8.CTRLA.bit.ENABLE = 1;\n        syncTC_8(TCx);\n      } else {\n        // -- Configure TCC\n        Tcc* TCCx = (Tcc*) GetTC(pinDesc.ulPWMChannel);\n        // Disable TCCx\n        TCCx->CTRLA.bit.ENABLE = 0;\n        syncTCC(TCCx);\n        // Prescaler\n        TCCx->CTRLA.reg |= (prescaler<<8);\n        syncTCC(TCCx);\n        // Set TCCx as dual slope PWM\n        TCCx->WAVE.reg |= TCC_WAVE_WAVEGEN_DSTOP;\n        //Invert the polarity because by default, ouput is high when counter > period\n        TCCx->WAVE.reg |= TCC_WAVE_POL_Msk; \n        syncTCC(TCCx);\n        // Set the initial value\n        TCCx->CC[tcChannel].reg = (uint32_t) value;\n        syncTCC(TCCx);\n        //No 'period-1' required in dual slope because freq = fTCC/(2N*PER) . Refer RM page 716 section 31.6.2.5.6\n        TCCx->PER.reg = period;\n        syncTCC(TCCx);\n        // Enable TCCx\n        TCCx->CTRLA.bit.ENABLE = 1;\n        syncTCC(TCCx);\n      }\n    }\n    return;\n  }\n    // -- Defaults to digital write\n  pinMode(pin, OUTPUT);\n  value = mapResolution(value, _writeResolution, 8);\n  if (value < 128) {\n    digitalWrite(pin, LOW);\n  } else {\n    digitalWrite(pin, HIGH);\n  }\n}\n\n/*Configure Output Polarity*/\nvoid MW_ConfigureOutputPolarity(uint8_T pin,boolean_T invertedPolarity){\n    PinDescription pinDesc = g_APinDescription[pin];\n    uint32_t attr = pinDesc.ulPinAttribute;\n    if ((attr & PIN_ATTR_PWM) == PIN_ATTR_PWM)\n    {\n        uint32_t tcNum = GetTCNumber(pinDesc.ulPWMChannel);\n        uint8_t tcChannel = GetTCChannelNumber(pinDesc.ulPWMChannel);\n        if (tcNum < TCC_INST_NUM) {\n            // -- Configure TCC\n            Tcc* TCCx = (Tcc*) GetTC(pinDesc.ulPWMChannel);\n            // Disable TCCx\n            TCCx->CTRLA.bit.ENABLE = 0;\n            syncTCC(TCCx);\n            // Invert the corresponding POL bit of WAVE register\n            TCCx->WAVE.reg ^= ((1<<(TCC_WAVE_POL0_Pos + tcChannel)) & TCC_WAVE_POL_Msk); \n            syncTCC(TCCx);\n            // Enable TCCx\n            TCCx->CTRLA.bit.ENABLE = 1;\n            syncTCC(TCCx);\n        }\n    }\n}\n\n/*Enable PWM Match Interrupt*/\nvoid MW_EnablePWMMatchInterrupt(uint8_T pin){\n    PinDescription pinDesc = g_APinDescription[pin];\n    uint32_t attr = pinDesc.ulPinAttribute;\n    if ((attr & PIN_ATTR_PWM) == PIN_ATTR_PWM)\n    {\n        uint32_t tcNum = GetTCNumber(pinDesc.ulPWMChannel);\n        uint8_t tcChannel = GetTCChannelNumber(pinDesc.ulPWMChannel);\n        if (tcNum < TCC_INST_NUM) {\n            // -- Configure TCC\n            Tcc* TCCx = (Tcc*) GetTC(pinDesc.ulPWMChannel);\n            // Disable TCCx\n            TCCx->CTRLA.bit.ENABLE = 0;\n            syncTCC(TCCx);\n            //Set the corresponsding MC bit in interrupt set register\n            TCCx->INTENSET.reg |= ((1<<(TCC_INTENSET_MC0_Pos + tcChannel)) & TCC_INTENSET_MC_Msk);\n            syncTCC(TCCx);\n            // Enable TCCx\n            TCCx->CTRLA.bit.ENABLE = 1;\n            syncTCC(TCCx);\n        }\n    }\n}\n\n/*Enable PWM Overflow Interrupt*/\nvoid MW_EnablePWMOverflowInterrupt(uint8_T pin){\n    PinDescription pinDesc = g_APinDescription[pin];\n    uint32_t attr = pinDesc.ulPinAttribute;\n    if ((attr & PIN_ATTR_PWM) == PIN_ATTR_PWM)\n    {\n        uint32_t tcNum = GetTCNumber(pinDesc.ulPWMChannel);\n        if (tcNum < TCC_INST_NUM) {\n            // -- Configure TCC\n            Tcc* TCCx = (Tcc*) GetTC(pinDesc.ulPWMChannel);\n            // Disable TCCx\n            TCCx->CTRLA.bit.ENABLE = 0;\n            syncTCC(TCCx);\n            //Enable Overflow Interrupt\n            TCC0->INTENSET.bit.OVF = 1;\n            syncTCC(TCCx);\n            // Enable TCCx\n            TCCx->CTRLA.bit.ENABLE = 1;\n            syncTCC(TCCx);\n        }\n    }\n}\n\n/*Set wave generation mode*/\nvoid MW_SetWavegenMode(uint8_T pin,uint8_T wavegenMode){\n    PinDescription pinDesc = g_APinDescription[pin];\n    uint32_t attr = pinDesc.ulPinAttribute;\n    if ((attr & PIN_ATTR_PWM) == PIN_ATTR_PWM)\n    {\n        uint32_t tcNum = GetTCNumber(pinDesc.ulPWMChannel);\n        if (tcNum < TCC_INST_NUM) {\n            // -- Configure TCC\n            Tcc* TCCx = (Tcc*) GetTC(pinDesc.ulPWMChannel);\n            // Disable TCCx\n            TCCx->CTRLA.bit.ENABLE = 0;\n            syncTCC(TCCx);\n            // Set TCCx wave mode\n            TCCx->WAVE.bit.WAVEGEN = wavegenMode;\n            syncTCC(TCCx);\n            // Enable TCCx\n            TCCx->CTRLA.bit.ENABLE = 1;\n            syncTCC(TCCx);\n        }\n    }\n}\n   \n#ifdef __cplusplus\n}\n#endif\n#elif defined(ARDUINO_ARDUINO_NANO33BLE)\n#include \"Arduino.h\"\n#include \"pins_arduino.h\"\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstatic int _writeResolution = 8;\n\nextern uint32_t nano33BLE_dutycycle[21];\nextern uint16_t nano33BLE_period[21];\n\nstatic inline uint32_t mapResolution(uint32_t value, uint32_t from, uint32_t to)\n{\n  if (from == to) {\n    return value;\n  }\n  if (from > to) {\n    return value >> (from-to);\n  }\n  return value << (to-from);\n}\n\nvoid MW_analogWrite(uint32_t pin, uint32_t value)\n{\n  nano33BLE_dutycycle[pin] = value;\n}\n\nvoid MW_setAnalogFrequency(uint16_t pin,uint16_t prescaler,uint16_t period)\n{\n    nano33BLE_period[pin] = period;\n}\n   \n#ifdef __cplusplus\n}\n#endif\n\n#elif (defined(ARDUINO_NANO_RP2040_CONNECT) || defined(ARDUINO_RASPBERRY_PI_PICO_W) || defined(ARDUINO_RASPBERRY_PI_PICO)) // RP2040 targets\n#include \"hardware/pwm.h\"\n#include \"hardware/gpio.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#if defined(ARDUINO_NANO_RP2040_CONNECT)\n// Inclusion of required files to get digitalPinToPinName is causing compilation errors saying cstddef is not defined. \n// It is most likely to do with our main being a c file.\n// Force defining it here as a workaround\nuint8_t digitalPinToPinName[] = {1,0,25,15,16,17,18,19,20,21,5,7,4,6,26,27,28,29,12,13};// D0 to D19\n#elif (defined(ARDUINO_RASPBERRY_PI_PICO) || defined(ARDUINO_RASPBERRY_PI_PICO_W))\nuint8_t digitalPinToPinName[]  = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,26,27,28};  // D0 to D28   \n#endif\n\nvoid MW_analogWrite(uint32_t pin, uint32_t value)\n{\n  pwm_set_gpio_level(digitalPinToPinName[pin], value);\n}\n\nvoid MW_setAnalogFrequency(uint16_t pin, uint16_t clkDiv, uint16_t countWrap)\n{\n    uint8_t slice_num = pwm_gpio_to_slice_num(digitalPinToPinName[pin]);\n\n    // Get some sensible defaults for the slice configuration. By default, the\n    // counter is allowed to wrap over its maximum range (0 to 2**16-1)\n    pwm_config cfg = pwm_get_default_config();\n    \n    // Set divider, reduces counter clock to sysclock/this value\n    pwm_config_set_clkdiv(&cfg, clkDiv);\n    pwm_config_set_wrap(&cfg, countWrap);\n    \n    // Load the configuration into our PWM slice, and set it running.\n    #if defined(ARDUINO_NANO_RP2040_CONNECT)\n    pwm_init(slice_num, pwm_gpio_to_channel(digitalPinToPinName[pin]), &cfg, true);\n    #elif (defined(ARDUINO_RASPBERRY_PI_PICO) || defined(ARDUINO_RASPBERRY_PI_PICO_W))\n    pwm_init(slice_num, &cfg, true);\n    #endif\n    gpio_set_function(digitalPinToPinName[pin], GPIO_FUNC_PWM);\n    // Set zero dutycycle at setup call\n    pwm_set_gpio_level(digitalPinToPinName[pin], 0*(countWrap+1));\n\n}\n   \n#ifdef __cplusplus\n}\n#endif\n#elif defined(ARDUINO_ARCH_RENESAS_UNO)\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid MW_analogWrite(uint32_t pin, uint32_t value)\n{\n  analogWrite(pin,value);\n}\n\nvoid MW_setAnalogFrequency(uint16_t pin,uint16_t prescaler,uint16_t period)\n{\n   //analogWriteFrequency(pin,1/period);\n}\n   \n#ifdef __cplusplus\n}\n#endif\n\n\n#elif defined(ARDUINO_ARCH_AVR)                                                         /* AVR Targets */\n#include \"wiring_private.h\"\n#include \"pins_arduino.h\"\nvoid MW_analogWrite(uint32_t pin, uint32_t value)\n{\n    analogWrite(pin, value);\n}\n\nvoid MW_setAnalogFrequency(uint16_t pin,uint16_t prescaler,uint16_t period)\n{\n    switch(digitalPinToTimer(pin))\n    {\n        // XXX fix needed for atmega8\n        #if defined(TCCR0) && defined(COM00) && !defined(__AVR_ATmega8__)\n        case TIMER0A:\n            // connect pwm to pin on timer 0\n            sbi(TCCR0, COM00);\n            break;\n        #endif\n\n        #if defined(TCCR0A) && defined(COM0A1)\n        case TIMER0A:\n            // connect pwm to pin on timer 0, channel A\n            sbi(TCCR0A, COM0A1);\n            break;\n        #endif\n\n        #if defined(TCCR0A) && defined(COM0B1)\n        case TIMER0B:\n            // connect pwm to pin on timer 0, channel B\n            sbi(TCCR0A, COM0B1);\n            break;\n        #endif\n\n        #if defined(TCCR1A) && defined(TCCR1B) && defined(ICR1) && defined(COM1A1)\n        case TIMER1A:\n            TCCR1A = (TCCR1A & 0xFCU) | 2U;                               //WGM11 for PWM, Phase Correct. Mode 10\n            TCCR1B = (TCCR1B & 0xE0U) | 0x10U | prescaler;                //WGM13 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR1   = period;                                              //Period\n            sbi(TCCR1A, COM1A1);\n            break;\n        #endif\n\n        #if defined(TCCR1A) && defined(TCCR1B) && defined(ICR1) && defined(COM1B1)\n        case TIMER1B:\n            TCCR1A = (TCCR1A & 0xFCU) | 2U;                               //WGM11 for PWM, Phase Correct. Mode 10\n            TCCR1B = (TCCR1B & 0xE0U) | 0x10U | prescaler;                //WGM13 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR1   = period;                                              //Period\n            sbi(TCCR1A, COM1B1);\n            break;\n        #endif\n\n        #if defined(TCCR1A) && defined(TCCR1B) && defined(ICR1) && defined(COM1C1)\n        case TIMER1C:\n            // connect pwm to pin on timer 1, channel B\n            TCCR1A = (TCCR1A & 0xFCU) | 2U;                               //WGM11 for PWM, Phase Correct. Mode 10\n            TCCR1B = (TCCR1B & 0xE0U) | 0x10U | prescaler;                //WGM13 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR1   = period;                                              //Period\n            sbi(TCCR1A, COM1C1);\n            break;\n        #endif\n\n        #if defined(TCCR2) && defined(COM21)\n        case TIMER2:\n            // connect pwm to pin on timer 2\n            sbi(TCCR2, COM21);\n            break;\n        #endif\n\n        #if defined(TCCR2A) && defined(TCCR2B) && defined(COM2A1)\n        case TIMER2A:\n            // connect pwm to pin on timer 2, channel A\n            sbi(TCCR2A, COM2A1);\n            TCCR2B=TCCR2B & 0b11111000 | prescaler;                 //Prescaler\n            break;\n        #endif\n\n        #if defined(TCCR2A) && defined(TCCR2B) && defined(COM2B1)\n        case TIMER2B:\n            // connect pwm to pin on timer 2, channel B\n            sbi(TCCR2A, COM2B1);\n            TCCR2B=TCCR2B & 0b11111000 | prescaler;                 //Prescaler\n            break;\n        #endif\n\n        #if defined(TCCR3A) && defined(TCCR3B) && defined(ICR3) && defined(COM3A1)\n        case TIMER3A:\n            // connect pwm to pin on timer 3, channel A\n            TCCR3A = (TCCR3A & 0xFCU) | 2U;                               //WGM31 for PWM, Phase Correct. Mode 10\n            TCCR3B = (TCCR3B & 0xE0U) | 0x10U | prescaler;                //WGM33 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR3   = period;                                              //Period\n            sbi(TCCR3A, COM3A1);\n            break;\n        #endif\n\n        #if defined(TCCR3A) && defined(TCCR3B) && defined(ICR3) && defined(COM3B1)\n        case TIMER3B:\n            // connect pwm to pin on timer 3, channel B\n            TCCR3A = (TCCR3A & 0xFCU) | 2U;                               //WGM31 for PWM, Phase Correct. Mode 10\n            TCCR3B = (TCCR3B & 0xE0U) | 0x10U | prescaler;                //WGM33 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR3   = period;                                              //Period\n            sbi(TCCR3A, COM3B1);\n            break;\n        #endif\n\n        #if defined(TCCR3A) && defined(TCCR3B) && defined(ICR3) && defined(COM3C1)\n        case TIMER3C:\n            // connect pwm to pin on timer 3, channel C\n            TCCR3A = (TCCR3A & 0xFCU) | 2U;                               //WGM31 for PWM, Phase Correct. Mode 10\n            TCCR3B = (TCCR3B & 0xE0U) | 0x10U | prescaler;                //WGM33 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR3   = period;                                              //Period\n            sbi(TCCR3A, COM3C1);\n            break;\n        #endif\n\n        #if defined(TCCR4A) && defined(TCCR4B) && defined(TCCR4D)  && defined(COM4A1) && defined(COM4A0)/* beginning of timer4 block for 32U4 and similar */\n        case TIMER4A:\n            TCCR4B = (TCCR4B & 0xf0) | prescaler;\n            OCR4C = period;\n            sbi(TCCR4A, COM4A1);\n            cbi(TCCR4A, COM4A0);\n            break;\n        #else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */\n        #if defined(TCCR4A) && defined(TCCR4B) && defined(ICR4) && defined(COM4A1)\n        case TIMER4A:\n            //connect pwm to pin on timer 4, channel A\n            TCCR4A = (TCCR4A & 0xFCU) | 2U;                               //WGM41 for PWM, Phase Correct. Mode 10\n            TCCR4B = (TCCR4B & 0xE0U) | 0x10U | prescaler;                //WGM43 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR4   = period;                                              //Period\n            sbi(TCCR4A, COM4A1);\n            break;\n        #endif\n        #endif\n\n        #if defined(TCCR4A) && defined(TCCR4B) && defined(TCCR4D)  && defined(COM4B1) /* beginning of timer4 block for 32U4 and similar */\n        case TIMER4B:\n            TCCR4B = (TCCR4B & 0xf0) | prescaler;\n            OCR4C = period;\n            sbi(TCCR4A, COM4B1);\n            break;\n        #else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */\n        #if defined(TCCR4A) && defined(TCCR4B) && defined(ICR4) && defined(COM4B1)    \n        case TIMER4B:\n            // connect pwm to pin on timer 4, channel B\n            TCCR4A = (TCCR4A & 0xFCU) | 2U;                               //WGM41 for PWM, Phase Correct. Mode 10\n            TCCR4B = (TCCR4B & 0xE0U) | 0x10U | prescaler;                //WGM43 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR4   = period;                                              //Period\n            sbi(TCCR4A, COM4B1);\n            break;\n        #endif\n        #endif\n\n        #if defined(TCCR4A) && defined(TCCR4B) && defined(TCCR4D)  && defined(COM4C1) /* beginning of timer4 block for 32U4 and similar */\n        case TIMER4C:\n            TCCR4B = (TCCR4B & 0xf0) | prescaler;\n            OCR4C = period;\n            sbi(TCCR4A, COM4C1);\n            break;\n        #else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */\n        #if defined(TCCR4A) && defined(TCCR4B) && defined(ICR4) && defined(COM4C1)    \n        case TIMER4C:\n            // connect pwm to pin on timer 4, channel C\n            TCCR4A = (TCCR4A & 0xFCU) | 2U;                               //WGM41 for PWM, Phase Correct. Mode 10\n            TCCR4B = (TCCR4B & 0xE0U) | 0x10U | prescaler;                //WGM43 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR4   = period;                                              //Period\n            sbi(TCCR4A, COM4C1);\n            break;\n        #endif\n        #endif\n\n        #if defined(TCCR4A) && defined(TCCR4B) && defined(TCCR4D)  && defined(COM4D1) && defined(COM4D0)\t/* beginning of timer4 block for 32U4 and similar */\n        case TIMER4D:\n            TCCR4B = (TCCR4B & 0xf0) | prescaler;\n            OCR4C = period;\n            // connect pwm to pin on timer 4, channel D\n            sbi(TCCR4C, COM4D1);\n            cbi(TCCR4C, COM4D0);\n        #else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */\n        #if defined(TCCR4C) && defined(COM4D1)\n        case TIMER4D:\t\t\t\t\n            // connect pwm to pin on timer 4, channel D\n            sbi(TCCR4C, COM4D1);\n            #if defined(COM4D0)\t\t// only used on 32U4\n            cbi(TCCR4C, COM4D0);\n            #endif\n            break;\n        #endif\n        #endif\n\n        #if defined(TCCR5A) && defined(TCCR5B) && defined(ICR5) && defined(COM5A1)\n        case TIMER5A:\n            // connect pwm to pin on timer 5, channel A\n            TCCR5A = (TCCR5A & 0xFCU) | 2U;                               //WGM51 for PWM, Phase Correct. Mode 10\n            TCCR5B = (TCCR5B & 0xE0U) | 0x10U | prescaler;                //WGM53 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR5   = period;                                              //Period\n            sbi(TCCR5A, COM5A1);\n            break;\n        #endif\n\n        #if defined(TCCR5A) && defined(TCCR5B) && defined(ICR5) && defined(COM5B1)\n        case TIMER5B:\n            // connect pwm to pin on timer 5, channel B\n            TCCR5A = (TCCR5A & 0xFCU) | 2U;                               //WGM51 for PWM, Phase Correct. Mode 10\n            TCCR5B = (TCCR5B & 0xE0U) | 0x10U | prescaler;                //WGM53 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR5   = period;                                              //Period\n            sbi(TCCR5A, COM5B1);\n            break;\n        #endif\n\n        #if defined(TCCR5A) && defined(TCCR5B) && defined(ICR5) && defined(COM5C1)\n        case TIMER5C:\n            // connect pwm to pin on timer 5, channel C\n            TCCR5A = (TCCR5A & 0xFCU) | 2U;                               //WGM51 for PWM, Phase Correct. Mode 10\n            TCCR5B = (TCCR5B & 0xE0U) | 0x10U | prescaler;                //WGM53 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR5   = period;                                              //Period\n            sbi(TCCR5A, COM5C1);\n            break;\n        #endif\n    }\n    digitalWrite(pin, LOW);\n}\n\n/*Enable PWM Match Interrupt*/\n/* This function covers these MCUs:\n* atmega32u4 -> TIMSK0,1,3,4\n* atmega2560 -> TIMSK0,1,2,3,4,5\n* atmega328p -> TIMSK0,1,2\n* Source: Register summary in datasheet\nIf support is added for a board which uses some other MCU, then this function needs to be updated\n*/\nvoid MW_EnablePWMMatchInterrupt(uint8_T pin){\n    switch(digitalPinToTimer(pin))\n    {\n        #if defined(TIMSK0) && defined(OCIE0A)\n        case TIMER0A: TIMSK0 |= (1 << OCIE0A); break;\n        #endif\n\n        #if defined(TIMSK0) && defined(OCIE0B)\n        case TIMER0B: TIMSK0 |= (1 << OCIE0B); break;\n        #endif\n\n        #if defined(TIMSK1) && defined(OCIE1A)\n        case TIMER1A: TIMSK1 |= (1 << OCIE1A); break;\n        #endif\n\n        #if defined(TIMSK1) && defined(OCIE1B)\n        case TIMER1B: TIMSK1 |= (1 << OCIE1B); break;\n        #endif\n\n        #if defined(TIMSK1) && defined(OCIE1C)\n        case TIMER1C: TIMSK1 |= (1 << OCIE1C); break;\n        #endif\n\n        #if defined(TIMSK2) && defined(OCIE2A)\n        case TIMER2A: TIMSK2 |= (1 << OCIE2A); break;\n        #endif\n\n        #if defined(TIMSK2) && defined(OCIE2B)\n        case TIMER2B: TIMSK2 |= (1 << OCIE2B); break;\n        #endif\n\t\t\n        #if defined(TIMSK3) && defined(OCIE3A)\n        case TIMER3A: TIMSK3 |= (1 << OCIE3A); break;\n        #endif\n\n        #if defined(TIMSK3) && defined(OCIE3B)\n        case TIMER3B: TIMSK3 |= (1 << OCIE3B); break;\n        #endif\n\n        #if defined(TIMSK3) && defined(OCIE3C)\n        case TIMER3C: TIMSK3 |= (1 << OCIE3C); break;\n        #endif\n\t\t\n        #if defined(TIMSK4) && defined(OCIE4A)\n        case TIMER4A: TIMSK4 |= (1 << OCIE4A); break;\n        #endif\n\n        #if defined(TIMSK4) && defined(OCIE4B)\n        case TIMER4B: TIMSK4 |= (1 << OCIE4B); break;\n        #endif\n\n        #if defined(TIMSK4) && defined(OCIE4C)\n        case TIMER4C: TIMSK4 |= (1 << OCIE4C); break;\n        #endif\n\n        #if defined(TIMSK4) && defined(OCIE4D)\n        case TIMER4D: TIMSK4 |= (1 << OCIE4D); break;\n        #endif\n\t\t\n        #if defined(TIMSK5) && defined(OCIE5A)\n        case TIMER5A: TIMSK5 |= (1 << OCIE5A); break;\n        #endif\n\n        #if defined(TIMSK5) && defined(OCIE5B)\n        case TIMER5B: TIMSK5 |= (1 << OCIE5B); break;\n        #endif\n\n        #if defined(TIMSK5) && defined(OCIE5C)\n        case TIMER5C: TIMSK5 |= (1 << OCIE5C); break;\n        #endif\n    }\n}\n\n/*Enable PWM Overflow Interrupt*/\nvoid MW_EnablePWMOverflowInterrupt(uint8_T pin){\n    switch(digitalPinToTimer(pin))\n    {\n        #if defined(TIMSK0) && defined(TOIE0)\n        case TIMER0A: TIMSK0 |= (1 << TOIE0); break;\n        #endif\n\n        #if defined(TIMSK0) && defined(TOIE0)\n        case TIMER0B: TIMSK0 |= (1 << TOIE0); break;\n        #endif\n\n        #if defined(TIMSK1) && defined(TOIE1)\n        case TIMER1A: TIMSK1 |= (1 << TOIE1); break;\n        #endif\n\n        #if defined(TIMSK1) && defined(TOIE1)\n        case TIMER1B: TIMSK1 |= (1 << TOIE1); break;\n        #endif\n\n        #if defined(TIMSK1) && defined(TOIE1)\n        case TIMER1C: TIMSK1 |= (1 << TOIE1); break;\n        #endif\n\n        #if defined(TIMSK2) && defined(TOIE2)\n        case TIMER2A: TIMSK2 |= (1 << TOIE2); break;\n        #endif\n\n        #if defined(TIMSK2) && defined(TOIE2)\n        case TIMER2B: TIMSK2 |= (1 << TOIE2); break;\n        #endif\n\t\t\n        #if defined(TIMSK3) && defined(TOIE3)\n        case TIMER3A: TIMSK3 |= (1 << TOIE3); break;\n        #endif\n\n        #if defined(TIMSK3) && defined(TOIE3)\n        case TIMER3B: TIMSK3 |= (1 << TOIE3); break;\n        #endif\n\n        #if defined(TIMSK3) && defined(TOIE3)\n        case TIMER3C: TIMSK3 |= (1 << TOIE3); break;\n        #endif\n\t\t\n        #if defined(TIMSK4) && defined(TOIE4)\n        case TIMER4A: TIMSK4 |= (1 << TOIE4); break;\n        #endif\n\n        #if defined(TIMSK4) && defined(TOIE4)\n        case TIMER4B: TIMSK4 |= (1 << TOIE4); break;\n        #endif\n\n        #if defined(TIMSK4) && defined(TOIE4)\n        case TIMER4C: TIMSK4 |= (1 << TOIE4); break;\n        #endif\n\n        #if defined(TIMSK4) && defined(TOIE4)\n        case TIMER4D: TIMSK4 |= (1 << TOIE4); break;\n        #endif\n\t\t\n        #if defined(TIMSK5) && defined(TOIE5)\n        case TIMER5A: TIMSK5 |= (1 << TOIE5); break;\n        #endif\n\n        #if defined(TIMSK5) && defined(TOIE5)\n        case TIMER5B: TIMSK5 |= (1 << TOIE5); break;\n        #endif\n\n        #if defined(TIMSK5) && defined(TOIE5)\n        case TIMER5C: TIMSK5 |= (1 << TOIE5); break;\n        #endif\n    }\n}\n\n#elif defined(ARDUINO_ARCH_SAM)                                                         /* SAM Targets */\n#include \"Arduino.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n    \nstatic int _writeResolution = 8;\nstatic uint8_t PWMEnabled = 0;\nstatic uint8_t TCChanEnabled[] = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n\nstatic inline uint32_t mapResolution(uint32_t value, uint32_t from, uint32_t to) {\n\tif (from == to)\n\t\treturn value;\n\tif (from > to)\n\t\treturn value >> (from-to);\n\telse\n\t\treturn value << (to-from);\n}\n\nstatic void TC_SetCMR_ChannelA(Tc *tc, uint32_t chan, uint32_t v)\n{\n\ttc->TC_CHANNEL[chan].TC_CMR = (tc->TC_CHANNEL[chan].TC_CMR & 0xFFF0FFFF) | v;\n}\n\nstatic void TC_SetCMR_ChannelB(Tc *tc, uint32_t chan, uint32_t v)\n{\n\ttc->TC_CHANNEL[chan].TC_CMR = (tc->TC_CHANNEL[chan].TC_CMR & 0xF0FFFFFF) | v;\n}\n\nvoid MW_analogWrite(uint32_t ulPin, uint32_t ulValue)\n{\n\tuint32_t attr = g_APinDescription[ulPin].ulPinAttribute;\n\n\tif ((attr & PIN_ATTR_ANALOG) == PIN_ATTR_ANALOG) {\n\t\tEAnalogChannel channel = g_APinDescription[ulPin].ulADCChannelNumber;\n\t\tif (channel == DA0 || channel == DA1) {\n\t\t\tuint32_t chDACC = ((channel == DA0) ? 0 : 1);\n\t\t\tif (dacc_get_channel_status(DACC_INTERFACE) == 0) {\n\t\t\t\t/* Enable clock for DACC_INTERFACE */\n\t\t\t\tpmc_enable_periph_clk(DACC_INTERFACE_ID);\n\n\t\t\t\t/* Reset DACC registers */\n\t\t\t\tdacc_reset(DACC_INTERFACE);\n\n\t\t\t\t/* Half word transfer mode */\n\t\t\t\tdacc_set_transfer_mode(DACC_INTERFACE, 0);\n\n\t\t\t\t/* Power save:\n\t\t\t\t * sleep mode  - 0 (disabled)\n\t\t\t\t * fast wakeup - 0 (disabled)\n\t\t\t\t */\n\t\t\t\tdacc_set_power_save(DACC_INTERFACE, 0, 0);\n\t\t\t\t/* Timing:\n\t\t\t\t * refresh        - 0x08 (1024*8 dacc clocks)\n\t\t\t\t * max speed mode -    0 (disabled)\n\t\t\t\t * startup time   - 0x10 (1024 dacc clocks)\n\t\t\t\t */\n\t\t\t\tdacc_set_timing(DACC_INTERFACE, 0x08, 0, 0x10);\n\n\t\t\t\t/* Set up analog current */\n\t\t\t\tdacc_set_analog_control(DACC_INTERFACE, DACC_ACR_IBCTLCH0(0x02) |\n\t\t\t\t\t\t\t\t\t\t\tDACC_ACR_IBCTLCH1(0x02) |\n\t\t\t\t\t\t\t\t\t\t\tDACC_ACR_IBCTLDACCORE(0x01));\n\t\t\t}\n\n\t\t\t/* Disable TAG and select output channel chDACC */\n\t\t\tdacc_set_channel_selection(DACC_INTERFACE, chDACC);\n\n\t\t\tif ((dacc_get_channel_status(DACC_INTERFACE) & (1 << chDACC)) == 0) {\n\t\t\t\tdacc_enable_channel(DACC_INTERFACE, chDACC);\n\t\t\t}\n\n\t\t\t// Write user value\n\t\t\tulValue = mapResolution(ulValue, _writeResolution, DACC_RESOLUTION);\n\t\t\tdacc_write_conversion_data(DACC_INTERFACE, ulValue);\n\t\t\twhile ((dacc_get_interrupt_status(DACC_INTERFACE) & DACC_ISR_EOC) == 0);\n\t\t\treturn;\n\t\t}\n\t}\n    \n    if ((attr & PIN_ATTR_PWM) == PIN_ATTR_PWM) {\n        uint32_t chan = g_APinDescription[ulPin].ulPWMChannel;\n\t\t//ulValue = mapResolution(ulValue, _writeResolution, PWM_RESOLUTION);\n\t\tPWMC_SetDutyCycle(PWM_INTERFACE, chan, ulValue);\n\t\treturn;\n\t}\n\n\tif ((attr & PIN_ATTR_TIMER) == PIN_ATTR_TIMER) {\n\t\t// Setup Timer for this pin\n\t\tETCChannel channel = g_APinDescription[ulPin].ulTCChannel;\n\t\tstatic const uint32_t channelToChNo[] = { 0, 0, 1, 1, 2, 2, 0, 0, 1, 1, 2, 2, 0, 0, 1, 1, 2, 2 };\n\t\tstatic const uint32_t channelToAB[]   = { 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0 };\n\t\tstatic Tc *channelToTC[] = {\n\t\t\tTC0, TC0, TC0, TC0, TC0, TC0,\n\t\t\tTC1, TC1, TC1, TC1, TC1, TC1,\n\t\t\tTC2, TC2, TC2, TC2, TC2, TC2 };\n\t\tstatic const uint32_t channelToId[] = { 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8 };\n\t\tuint32_t chNo = channelToChNo[channel];\n\t\tuint32_t chA  = channelToAB[channel];\n\t\tTc *chTC = channelToTC[channel];\n\t\tuint32_t interfaceID = channelToId[channel];\n\n\t\tif (ulValue == 0) {\n\t\t\tif (chA)\n\t\t\t\tTC_SetCMR_ChannelA(chTC, chNo, TC_CMR_ACPA_CLEAR | TC_CMR_ACPC_CLEAR);\n\t\t\telse\n\t\t\t\tTC_SetCMR_ChannelB(chTC, chNo, TC_CMR_BCPB_CLEAR | TC_CMR_BCPC_CLEAR);\n\t\t} else {\n\t\t\tif (chA) {\n\t\t\t\tTC_SetRA(chTC, chNo, ulValue);\n\t\t\t\tTC_SetCMR_ChannelA(chTC, chNo, TC_CMR_ACPA_CLEAR | TC_CMR_ACPC_SET);\n\t\t\t} else {\n\t\t\t\tTC_SetRB(chTC, chNo, ulValue);\n\t\t\t\tTC_SetCMR_ChannelB(chTC, chNo, TC_CMR_BCPB_CLEAR | TC_CMR_BCPC_SET);\n\t\t\t}\n\t\t}\n\t\tif ((g_pinStatus[ulPin] & 0xF) != PIN_STATUS_PWM) {\n\t\t\tPIO_Configure(g_APinDescription[ulPin].pPort,\n\t\t\t\t\tg_APinDescription[ulPin].ulPinType,\n\t\t\t\t\tg_APinDescription[ulPin].ulPin,\n\t\t\t\t\tg_APinDescription[ulPin].ulPinConfiguration);\n\t\t\tg_pinStatus[ulPin] = (g_pinStatus[ulPin] & 0xF0) | PIN_STATUS_PWM;\n\t\t}\n\t\treturn;\n\t}\n\n\t// Defaults to digital write\n\tpinMode(ulPin, OUTPUT);\n\tulValue = mapResolution(ulValue, _writeResolution, 8);\n\tif (ulValue < 128)\n\t\tdigitalWrite(ulPin, LOW);\n\telse\n\t\tdigitalWrite(ulPin, HIGH);\n}\nvoid MW_setAnalogFrequency(uint16_t ulPin,uint16_t prescaler,uint16_t period)\n{\n    uint32_t attr = g_APinDescription[ulPin].ulPinAttribute;\n    if ((attr & PIN_ATTR_PWM) == PIN_ATTR_PWM) {\n\t\tif (!PWMEnabled) {\n\t\t\t// PWM Startup code\n\t\t    pmc_enable_periph_clk(PWM_INTERFACE_ID);\n\t\t    PWMC_ConfigureClocks(PWM_FREQUENCY * PWM_MAX_DUTY_CYCLE, 0, VARIANT_MCK);\n\t\t\tPWMEnabled = 1;\n\t\t}\n\n\t\tuint32_t chan = g_APinDescription[ulPin].ulPWMChannel;\n\t\tif ((g_pinStatus[ulPin] & 0xF) != PIN_STATUS_PWM) {\n\t\t\t// Setup PWM for this pin\n\t\t\tPIO_Configure(g_APinDescription[ulPin].pPort,\n\t\t\t\t\tg_APinDescription[ulPin].ulPinType,\n\t\t\t\t\tg_APinDescription[ulPin].ulPin,\n\t\t\t\t\tg_APinDescription[ulPin].ulPinConfiguration);\n\t\t\tPWMC_ConfigureChannel(PWM_INTERFACE, chan, prescaler, 0, 0);\n\t\t\tPWMC_SetPeriod(PWM_INTERFACE, chan, period);\n\t\t\tPWMC_SetDutyCycle(PWM_INTERFACE, chan, 0);\n\t\t\tPWMC_EnableChannel(PWM_INTERFACE, chan);\n\t\t\tg_pinStatus[ulPin] = (g_pinStatus[ulPin] & 0xF0) | PIN_STATUS_PWM;\n\t\t}\n\t\treturn;\n\t}\n\n\tif ((attr & PIN_ATTR_TIMER) == PIN_ATTR_TIMER) {\n\t\t// We use MCLK/2 as clock.\n\t\tconst uint32_t TC = period;\n\n\t\t// Setup Timer for this pin\n\t\tETCChannel channel = g_APinDescription[ulPin].ulTCChannel;\n\t\tstatic const uint32_t channelToChNo[] = { 0, 0, 1, 1, 2, 2, 0, 0, 1, 1, 2, 2, 0, 0, 1, 1, 2, 2 };\n\t\tstatic const uint32_t channelToAB[]   = { 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0 };\n\t\tstatic Tc *channelToTC[] = {\n\t\t\tTC0, TC0, TC0, TC0, TC0, TC0,\n\t\t\tTC1, TC1, TC1, TC1, TC1, TC1,\n\t\t\tTC2, TC2, TC2, TC2, TC2, TC2 };\n\t\tstatic const uint32_t channelToId[] = { 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8 };\n\t\tuint32_t chNo = channelToChNo[channel];\n\t\tuint32_t chA  = channelToAB[channel];\n\t\tTc *chTC = channelToTC[channel];\n\t\tuint32_t interfaceID = channelToId[channel];\n\n\t\tif (!TCChanEnabled[interfaceID]) {\n\t\t\tpmc_enable_periph_clk(TC_INTERFACE_ID + interfaceID);\n\t\t\tTC_Configure(chTC, chNo,\n\t\t\t\tprescaler |\n\t\t\t\tTC_CMR_WAVE |         // Waveform mode\n\t\t\t\tTC_CMR_WAVSEL_UP_RC | // Counter running up and reset when equals to RC\n\t\t\t\tTC_CMR_EEVT_XC0 |     // Set external events from XC0 (this setup TIOB as output)\n\t\t\t\tTC_CMR_ACPA_CLEAR | TC_CMR_ACPC_CLEAR |\n\t\t\t\tTC_CMR_BCPB_CLEAR | TC_CMR_BCPC_CLEAR);\n\t\t\tTC_SetRC(chTC, chNo, TC);\n\t\t}\n\t\t\n\t\tif ((g_pinStatus[ulPin] & 0xF) != PIN_STATUS_PWM) {\n\t\t\tPIO_Configure(g_APinDescription[ulPin].pPort,\n\t\t\t\t\tg_APinDescription[ulPin].ulPinType,\n\t\t\t\t\tg_APinDescription[ulPin].ulPin,\n\t\t\t\t\tg_APinDescription[ulPin].ulPinConfiguration);\n\t\t\tg_pinStatus[ulPin] = (g_pinStatus[ulPin] & 0xF0) | PIN_STATUS_PWM;\n\t\t}\n\t\tif (!TCChanEnabled[interfaceID]) {\n\t\t\tTC_Start(chTC, chNo);\n\t\t\tTCChanEnabled[interfaceID] = 1;\n\t\t}\n\t\treturn;\n\t}\n}\n\n#ifdef __cplusplus\n}\n#endif\n#endif                                                                                  /* Architecture selection endif*/                                                                             \n\n#endif /*Rapid Accel condition check*/\n/* [EOF] */"},{"name":"MW_arduino_digitalio.cpp","type":"source","group":"legacy","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/../../../Documents/MATLAB/SupportPackages/R2025b/toolbox/target/supportpackages/arduinobase/src","tag":"","groupDisplay":"Other files","code":"#ifndef MATLAB_MEX_FILE\n#include <Arduino.h>\n#include \"MW_arduino_digitalio.h\"\n#endif\n#include \"rtwtypes.h\"\n\n// Digital I/O initialization\nextern \"C\" void digitalIOSetup(uint8_T pin, uint8_T mode) \n{ \n    #ifndef MATLAB_MEX_FILE\n    // mode = 0: Input\n    // mode = 1: Output\n    // mode = 2: Input pullup\n    if (mode==0) {\n        pinMode(pin, INPUT);\n    }\n    else if (mode==1) {\n        pinMode(pin, OUTPUT);\n    }\n    else {\n        // mode = 2 is for input pullup\n        pinMode(pin, INPUT_PULLUP);\n    }\n    #endif\n}\n\n// Write a logic value to pin\nextern \"C\" void writeDigitalPin(uint8_T pin, boolean_T val)\n{\n    #ifndef MATLAB_MEX_FILE\n    if (val) {\n        digitalWrite(pin, HIGH);\n    } \n    else {\n        digitalWrite(pin, LOW);\n    }\n    #endif\n}\n\n// Read logical state of a digital pin\nextern \"C\" boolean_T readDigitalPin(uint8_T pin)\n{\n    #ifndef MATLAB_MEX_FILE\n    boolean_T ret;\n     \n    ret = (digitalRead(pin) == HIGH) ? 1:0;\n    return ret;\n    #else\n    return (boolean_T)0;\n    #endif\n}\n"},{"name":"MW_target_hardware_resources.h","type":"header","group":"other","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef PORTABLE_WORDSIZES\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#ifndef __MW_TARGET_HARDWARE_RESOURCES_H__\n#define __MW_TARGET_HARDWARE_RESOURCES_H__\n\n#define MW_MULTI_TASKING_MODE 1\n#include \"MW_ArduinoHWInit.h\"\n#include \"arduinoAVRScheduler.h\"\n\n#define MW_USECODERTARGET 1\n#define MW_TARGETHARDWARE Arduino Mega 2560\n#define MW_CONNECTIONINFO_XCPONSERIAL_BAUDRATE codertarget.arduinobase.registry.getBaudRate\n#define MW_CONNECTIONINFO_XCPONSERIAL_COMPORT codertarget.arduinobase.internal.getExternalModeMexArgs('Serial')\n#define MW_CONNECTIONINFO_XCPONSERIAL_VERBOSE 0\n#define MW_CONNECTIONINFO_XCPONTCPIP_IPADDRESS codertarget.arduinobase.internal.getExternalModeMexArgs('Ethernet')\n#define MW_CONNECTIONINFO_XCPONTCPIP_PORT 17725\n#define MW_CONNECTIONINFO_XCPONTCPIP_VERBOSE 0\n#define MW_CONNECTIONINFO_XCPONWIFI_IPADDRESS codertarget.arduinobase.internal.getExternalModeMexArgs('Wifi')\n#define MW_CONNECTIONINFO_XCPONWIFI_PORT 17725\n#define MW_CONNECTIONINFO_XCPONWIFI_VERBOSE 0\n#define MW_EXTMODE_CONFIGURATION XCP on Serial\n#define MW_EXTMODE_COMPORTBAUD 921600\n#define MW_EXTMODE_TARGETPOLLINGTIMEMODE 0\n#define MW_EXTMODE_TARGETPOLLINGTIME 2\n#define MW_EXTMODE_USEREALTIMESTAMPLOGGING 0\n#define MW_EXTMODE_RUNNING on\n#define MW_RTOS Baremetal\n#define MW_SCHEDULER_INTERRUPT_SOURCE 0\n#define MW_RUNTIME_BUILDACTION 1\n#define MW_RUNTIME_DISABLEPARALLELBUILD 0\n#define MW_RUNTIME_FORCEBUILDSTATICLIBRARY 0\n#define MW_RUNTIME_VERBOSEOUTPUT 0\n#define MW_OVERRUNDETECTION_ENABLE_OVERRUN_DETECTION 0\n#define MW_OVERRUNDETECTION_DIGITAL_OUTPUT_TO_SET_ON_OVERRUN 13\n#define MW_ANALOGINREFVOLTAGE_ANALOG_INPUT_REFERENCE_VOLTAGE 0.000000\n#define MW_SERIAL_SERIAL0_BAUD_RATE 8\n#define MW_SERIAL_SERIAL1_BAUD_RATE 8\n#define MW_SERIAL_SERIAL2_BAUD_RATE 8\n#define MW_SERIAL_SERIAL3_BAUD_RATE 8\n#define MW_SERIAL_SERIAL0_BAUD_SPECIFY 921600\n#define MW_SERIAL_SERIAL0_CONFIG 3\n#define MW_SERIAL_SERIAL1_BAUD_SPECIFY 921600\n#define MW_SERIAL_SERIAL1_CONFIG 3\n#define MW_SERIAL_SERIAL2_BAUD_SPECIFY 921600\n#define MW_SERIAL_SERIAL2_CONFIG 3\n#define MW_SERIAL_SERIAL3_BAUD_SPECIFY 921600\n#define MW_SERIAL_SERIAL3_CONFIG 3\n#define MW_SPI_SPI0_CLOCK_OUT_FREQUENCY 1\n#define MW_SPI_SPI0_MODE 0\n#define MW_SPI_SPI0_BITORDER 0\n#define MW_SPI_SDSLAVESELECT 4.000000\n#define MW_SPI_CANCHIPSELECT 9.000000\n#define MW_ETHERNET_DISABLE_DHCP_ETHERNET 0\n#define MW_ETHERNET_LOCAL_IP_ADDRESS 192.168.0.20\n#define MW_ETHERNET_LOCAL_MAC_ADDRESS DE:AD:BE:EF:FE:ED\n#define MW_WIFI_WIFI_IP_ADDRESS 192.168.1.20\n#define MW_WIFI_WIFI_SSID yourNetwork\n#define MW_WIFI_SET_WIFI_ENCRYPTION 0\n#define MW_WIFI_WIFI_WEP_KEY D0D0DEADF00DABBADEAFBEADED\n#define MW_WIFI_WIFI_WEP_KEY_INDEX 0\n#define MW_WIFI_WIFI_WPA_PASSWORD secretPassword\n#define MW_WIFI_IP_ADDRESS_ASSIGNMENT 0\n#define MW_WIFI_WIFI_HARDWARE 0\n#define MW_WIFI_WIFI_ESP8266_HW_SERIAL_PORT 0\n#define MW_THINGSPEAK_ENABLE_CUSTOMSERVER 48\n#define MW_THINGSPEAK_IP_ADDRESS 184.106.153.149\n#define MW_THINGSPEAK_PORT 80\n#define MW_DATAVERSION 2016.02\n#define MW_BUILD_ACTION Build, load and run\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_PORT_SOURCE 1\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_COMPORT_SPECIFY 1\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_COMPORT_SELECT -1\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_BAUD 0\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_BAUD_SPECIFY \n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_SERIAL_PORT 0\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_PORT_SOURCE1 1\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_PORT_SOURCE2 0\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_COMPORT_SELECT -1\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_COMPORT_SPECIFY 1\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_BAUD 0\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_BAUD_SPECIFY \n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_SERIAL_PORT 0\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_PORT_SOURCE1 1\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_PORT_SOURCE2 0\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_COMPORT_SELECT -1\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_COMPORT_SPECIFY 1\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_BAUD -1\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_BAUD_SPECIFY \n#define MW_HOSTBOARDCONNECTION_PIL_SERIAL_PORT 0\n#define MW_HOSTBOARDCONNECTION_PIL_PORT_SOURCE1 1\n#define MW_HOSTBOARDCONNECTION_PIL_PORT_SOURCE2 0\n#define MW_HOSTBOARDCONNECTION_PIL_COMPORT_SELECT -1\n#define MW_HOSTBOARDCONNECTION_PIL_COMPORT_SPECIFY 1\n#define MW_HOSTBOARDCONNECTION_PIL_BAUD 0\n#define MW_HOSTBOARDCONNECTION_PIL_BAUD_SPECIFY \n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERSIZE 500\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERNUM 3\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_MAXCONTIGSAMPLES 10\n#define MW_EXTMODEPROTOCOLINFO_XCPONTCPIP_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONTCPIP_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONTCPIP_LOGGINGBUFFERSIZE 500\n#define MW_EXTMODEPROTOCOLINFO_XCPONTCPIP_LOGGINGBUFFERNUM 3\n#define MW_EXTMODEPROTOCOLINFO_XCPONTCPIP_MAXCONTIGSAMPLES 10\n#define MW_EXTMODEPROTOCOLINFO_XCPONWIFI_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONWIFI_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONWIFI_LOGGINGBUFFERSIZE 500\n#define MW_EXTMODEPROTOCOLINFO_XCPONWIFI_LOGGINGBUFFERNUM 3\n#define MW_EXTMODEPROTOCOLINFO_XCPONWIFI_MAXCONTIGSAMPLES 10\n#define MW_CONNECTEDIO_CONNECTEDIOMODE 0\n#define MW_CONNECTEDIO_ACTIONONOVERRUN 0\n#define MW_I2C_I2C0BUSSPEEDHZ 100000\n#define MW_CAN_CANBUSSPEED 10\n#define MW_CAN_CANOSCILLATORFREQUENCY 1\n#define MW_CAN_INTERRUPTPIN 2.000000\n#define MW_CAN_ALLOWALLFILTER 0\n#define MW_CAN_BUFFER0IDTYPE 0\n#define MW_CAN_ACCEPTANCEMASK0_NOR 0\n#define MW_CAN_ACCEPTANCEFILTER0_NOR 255\n#define MW_CAN_ACCEPTANCEFILTER1_NOR 255\n#define MW_CAN_ACCEPTANCEMASK0_EXT 0\n#define MW_CAN_ACCEPTANCEFILTER0_EXT 255\n#define MW_CAN_ACCEPTANCEFILTER1_EXT 255\n#define MW_CAN_BUFFER1IDTYPE 0\n#define MW_CAN_ACCEPTANCEMASK1_NOR 0\n#define MW_CAN_ACCEPTANCEFILTER2_NOR 255\n#define MW_CAN_ACCEPTANCEFILTER3_NOR 255\n#define MW_CAN_ACCEPTANCEFILTER4_NOR 255\n#define MW_CAN_ACCEPTANCEFILTER5_NOR 255\n#define MW_CAN_ACCEPTANCEMASK1_EXT 0\n#define MW_CAN_ACCEPTANCEFILTER2_EXT 255\n#define MW_CAN_ACCEPTANCEFILTER3_EXT 255\n#define MW_CAN_ACCEPTANCEFILTER4_EXT 255\n#define MW_CAN_ACCEPTANCEFILTER5_EXT 255\n#define MW_MODBUS_MODBUS_COMMS 0\n#define MW_MODBUS_MODBUS_MODE 0\n#define MW_MODBUS_MODBUS_SLAVEID 1\n#define MW_MODBUS_MODBUS_CONFIGCOIL 49\n#define MW_MODBUS_MODBUS_COILADDR 0\n#define MW_MODBUS_MODBUS_COILNUM 1\n#define MW_MODBUS_MODBUS_CONFIGINPUT 49\n#define MW_MODBUS_MODBUS_INPUTADDR 0\n#define MW_MODBUS_MODBUS_INPUTNUM 1\n#define MW_MODBUS_MODBUS_CONFIGHOLDINGREG 49\n#define MW_MODBUS_MODBUS_HOLDINGREGADDR 0\n#define MW_MODBUS_MODBUS_HOLDINGREGNUM 1\n#define MW_MODBUS_MODBUS_CONFIGINPUTREG 49\n#define MW_MODBUS_MODBUS_INPUTREGADDR 0\n#define MW_MODBUS_MODBUS_INPUTREGNUM 1\n#define MW_MODBUS_MODBUS_MASTERTIMEOUT 100\n#define MW_RS485_RS485_SERIAL 1\n#define MW_RS485_RS485_BAUD 9600\n#define MW_RS485_RS485_CONFIG 3\n#define MW_RS485_RS485_DEPIN 8\n#define MW_RS485_RS485_REPIN 9\n#define MW_DISPLAY_ENABLECODEGEN 0\n#define MW_DISPLAY_APPLAUNCHBUTTON \n#define MW_IOBLOCKSMODE deployed\n\n#endif /* __MW_TARGET_HARDWARE_RESOURCES_H__ */\n\n#endif\n\n#endif\n"},{"name":"NewPing.cpp","type":"source","group":"other","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"// ---------------------------------------------------------------------------\n// Created by Tim Eckel - teckel@leethost.com\n// Copyright 2012 License: GNU GPL v3 http://www.gnu.org/licenses/gpl-3.0.html\n//\n// See \"NewPing.h\" for purpose, syntax, version history, links, and more.\n// ---------------------------------------------------------------------------\n\n#include \"NewPing.h\"\n\n//uint8_t trigger_pin;\n//uint8_t echo_pin;\n\n// ---------------------------------------------------------------------------\n// NewPing constructor\n// ---------------------------------------------------------------------------\n\nNewPing::NewPing(uint8_t trigger_pin, uint8_t echo_pin, int max_cm_distance) {\n//NewPing::NewPing(int max_cm_distance) {\n\t\n\t_triggerBit = digitalPinToBitMask(trigger_pin); // Get the port register bitmask for the trigger pin.\n\t_echoBit = digitalPinToBitMask(echo_pin);       // Get the port register bitmask for the echo pin.\n\n\t_triggerOutput = portOutputRegister(digitalPinToPort(trigger_pin)); // Get the output port register for the trigger pin.\n\t_echoInput = portInputRegister(digitalPinToPort(echo_pin));         // Get the input port register for the echo pin.\n\n\t_triggerMode = (uint8_t *) portModeRegister(digitalPinToPort(trigger_pin)); // Get the port mode register for the trigger pin.\n\n\t_maxEchoTime = min(max_cm_distance, MAX_SENSOR_DISTANCE) * US_ROUNDTRIP_CM + (US_ROUNDTRIP_CM / 2); // Calculate the maximum distance in uS.\n\n#if DISABLE_ONE_PIN == true\n\t*_triggerMode |= _triggerBit; // Set trigger pin to output.\n#endif\n}\n\n\n// ---------------------------------------------------------------------------\n// Standard ping methods\n// ---------------------------------------------------------------------------\n\nunsigned int NewPing::ping() {\n\tif (!ping_trigger()) return NO_ECHO;                // Trigger a ping, if it returns false, return NO_ECHO to the calling function.\n\twhile (*_echoInput & _echoBit)                      // Wait for the ping echo.\n\t\tif (micros() > _max_time) return NO_ECHO;       // Stop the loop and return NO_ECHO (false) if we're beyond the set maximum distance.\n\treturn (micros() - (_max_time - _maxEchoTime) - 5); // Calculate ping time, 5uS of overhead.\n}\n\n\nunsigned int NewPing::ping_in() {\n\tunsigned int echoTime = NewPing::ping();          // Calls the ping method and returns with the ping echo distance in uS.\n\treturn NewPingConvert(echoTime, US_ROUNDTRIP_IN); // Convert uS to inches.\n}\n\n\nunsigned int NewPing::ping_cm() {\n\tunsigned int echoTime = NewPing::ping();          // Calls the ping method and returns with the ping echo distance in uS.\n\treturn NewPingConvert(echoTime, US_ROUNDTRIP_CM); // Convert uS to centimeters.\n}\n\n\nunsigned int NewPing::ping_median(uint8_t it) {\n\tunsigned int uS[it], last;\n\tuint8_t j, i = 0;\n\tuS[0] = NO_ECHO;\n\twhile (i < it) {\n\t\tlast = ping();           // Send ping.\n\t\tif (last == NO_ECHO) {   // Ping out of range.\n\t\t\tit--;                // Skip, don't include as part of median.\n\t\t\tlast = _maxEchoTime; // Adjust \"last\" variable so delay is correct length.\n\t\t} else {                       // Ping in range, include as part of median.\n\t\t\tif (i > 0) {               // Don't start sort till second ping.\n\t\t\t\tfor (j = i; j > 0 && uS[j - 1] < last; j--) // Insertion sort loop.\n\t\t\t\t\tuS[j] = uS[j - 1]; // Shift ping array to correct position for sort insertion.\n\t\t\t} else j = 0;              // First ping is starting point for sort.\n\t\t\tuS[j] = last;              // Add last ping to array in sorted position.\n\t\t\ti++;                       // Move to next ping.\n\t\t}\n\t\tif (i < it) delay(PING_MEDIAN_DELAY - (last >> 10)); // Millisecond delay between pings.\n\t}\n\treturn (uS[it >> 1]); // Return the ping distance median.\n}\n\n\n// ---------------------------------------------------------------------------\n// Standard ping method support functions (not called directly)\n// ---------------------------------------------------------------------------\n\nboolean NewPing::ping_trigger() {\n#if DISABLE_ONE_PIN != true\n\t*_triggerMode |= _triggerBit;    // Set trigger pin to output.\n#endif\n\t*_triggerOutput &= ~_triggerBit; // Set the trigger pin low, should already be low, but this will make sure it is.\n\tdelayMicroseconds(4);            // Wait for pin to go low, testing shows it needs 4uS to work every time.\n\t*_triggerOutput |= _triggerBit;  // Set trigger pin high, this tells the sensor to send out a ping.\n\tdelayMicroseconds(10);           // Wait long enough for the sensor to realize the trigger pin is high. Sensor specs say to wait 10uS.\n\t*_triggerOutput &= ~_triggerBit; // Set trigger pin back to low.\n#if DISABLE_ONE_PIN != true\n\t*_triggerMode &= ~_triggerBit;   // Set trigger pin to input (when using one Arduino pin this is technically setting the echo pin to input as both are tied to the same Arduino pin).\n#endif\n\n\t_max_time =  micros() + MAX_SENSOR_DELAY;                  // Set a timeout for the ping to trigger.\n\twhile (*_echoInput & _echoBit && micros() <= _max_time) {} // Wait for echo pin to clear.\n\twhile (!(*_echoInput & _echoBit))                          // Wait for ping to start.\n\t\tif (micros() > _max_time) return false;                // Something went wrong, abort.\n\n\t_max_time = micros() + _maxEchoTime; // Ping started, set the timeout.\n\treturn true;                         // Ping started successfully.\n}\n\n\n// ---------------------------------------------------------------------------\n// Timer interrupt ping methods (won't work with ATmega8 and ATmega128)\n// ---------------------------------------------------------------------------\n\nvoid NewPing::ping_timer(void (*userFunc)(void)) {\n\tif (!ping_trigger()) return;         // Trigger a ping, if it returns false, return without starting the echo timer.\n\ttimer_us(ECHO_TIMER_FREQ, userFunc); // Set ping echo timer check every ECHO_TIMER_FREQ uS.\n}\n\n \nboolean NewPing::check_timer() {\n\tif (micros() > _max_time) { // Outside the timeout limit.\n\t\ttimer_stop();           // Disable timer interrupt\n\t\treturn false;           // Cancel ping timer.\n\t}\n\n\tif (!(*_echoInput & _echoBit)) { // Ping echo received.\n\t\ttimer_stop();                // Disable timer interrupt\n\t\tping_result = (micros() - (_max_time - _maxEchoTime) - 13); // Calculate ping time, 13uS of overhead.\n\t\treturn true;                 // Return ping echo true.\n\t}\n\n\treturn false; // Return false because there's no ping echo yet.\n}\n\n\n// ---------------------------------------------------------------------------\n// Timer2/Timer4 interrupt methods (can be used for non-ultrasonic needs)\n// ---------------------------------------------------------------------------\n\n// Variables used for timer functions\nvoid (*intFunc)();\nvoid (*intFunc2)();\nunsigned long _ms_cnt_reset;\nvolatile unsigned long _ms_cnt;\n\n\nvoid NewPing::timer_us(unsigned int frequency, void (*userFunc)(void)) {\n\ttimer_setup();      // Configure the timer interrupt.\n\tintFunc = userFunc; // User's function to call when there's a timer event.\n\n#if defined (__AVR_ATmega32U4__) // Use Timer4 for ATmega32U4 (Teensy/Leonardo).\n\tOCR4C = min((frequency>>2) - 1, 255); // Every count is 4uS, so divide by 4 (bitwise shift right 2) subtract one, then make sure we don't go over 255 limit.\n\tTIMSK4 = (1<<TOIE4);                  // Enable Timer4 interrupt.\n#else\n\tOCR2A = min((frequency>>2) - 1, 255); // Every count is 4uS, so divide by 4 (bitwise shift right 2) subtract one, then make sure we don't go over 255 limit.\n\tTIMSK2 |= (1<<OCIE2A);                // Enable Timer2 interrupt.\n#endif\n}\n\n\nvoid NewPing::timer_ms(unsigned long frequency, void (*userFunc)(void)) {\n\ttimer_setup();                       // Configure the timer interrupt.\n\tintFunc = NewPing::timer_ms_cntdwn;  // Timer events are sent here once every ms till user's frequency is reached.\n\tintFunc2 = userFunc;                 // User's function to call when user's frequency is reached.\n\t_ms_cnt = _ms_cnt_reset = frequency; // Current ms counter and reset value.\n\n#if defined (__AVR_ATmega32U4__) // Use Timer4 for ATmega32U4 (Teensy/Leonardo).\n\tOCR4C = 249;         // Every count is 4uS, so 1ms = 250 counts - 1.\n\tTIMSK4 = (1<<TOIE4); // Enable Timer4 interrupt.\n#else\n\tOCR2A = 249;           // Every count is 4uS, so 1ms = 250 counts - 1.\n\tTIMSK2 |= (1<<OCIE2A); // Enable Timer2 interrupt.\n#endif\n}\n\n\nvoid NewPing::timer_stop() { // Disable timer interrupt.\n#if defined (__AVR_ATmega32U4__) // Use Timer4 for ATmega32U4 (Teensy/Leonardo).\n\tTIMSK4 = 0;\n#else\n\tTIMSK2 &= ~(1<<OCIE2A);\n#endif\n}\n\n\n// ---------------------------------------------------------------------------\n// Timer2/Timer4 interrupt method support functions (not called directly)\n// ---------------------------------------------------------------------------\n\nvoid NewPing::timer_setup() {\n#if defined (__AVR_ATmega32U4__) // Use Timer4 for ATmega32U4 (Teensy/Leonardo).\n\ttimer_stop(); // Disable Timer4 interrupt.\n\tTCCR4A = TCCR4C = TCCR4D = TCCR4E = 0;\n\tTCCR4B = (1<<CS42) | (1<<CS41) | (1<<CS40) | (1<<PSR4); // Set Timer4 prescaler to 64 (4uS/count, 4uS-1020uS range).\n\tTIFR4 = (1<<TOV4);\n\tTCNT4 = 0;    // Reset Timer4 counter.\n#else\n\ttimer_stop();           // Disable Timer2 interrupt.\n\tASSR &= ~(1<<AS2);      // Set clock, not pin.\n\tTCCR2A = (1<<WGM21);    // Set Timer2 to CTC mode.\n\tTCCR2B = (1<<CS22);     // Set Timer2 prescaler to 64 (4uS/count, 4uS-1020uS range).\n\tTCNT2 = 0;              // Reset Timer2 counter.\n#endif\n}\n\n\nvoid NewPing::timer_ms_cntdwn() {\n\tif (!_ms_cnt--) {            // Count down till we reach zero.\n\t\tintFunc2();              // Scheduled time reached, run the main timer event function.\n\t\t_ms_cnt = _ms_cnt_reset; // Reset the ms timer.\n\t}\n}\n\n\n#if defined (__AVR_ATmega32U4__) // Use Timer4 for ATmega32U4 (Teensy/Leonardo).\nISR(TIMER4_OVF_vect) {\n#else\nISR(TIMER2_COMPA_vect) {\n#endif\n\tif(intFunc) intFunc(); // If wrapped function is set, call it.\n}\n\n\n// ---------------------------------------------------------------------------\n// Conversion methods (rounds result to nearest inch or cm).\n// ---------------------------------------------------------------------------\n\nunsigned int NewPing::convert_in(unsigned int echoTime) {\n\treturn NewPingConvert(echoTime, US_ROUNDTRIP_IN); // Convert uS to inches.\n}\n\n\nunsigned int NewPing::convert_cm(unsigned int echoTime) {\n\treturn NewPingConvert(echoTime, US_ROUNDTRIP_CM); // Convert uS to centimeters.\n}\n"},{"name":"PWMFSelect.cpp","type":"source","group":"other","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"#include <Arduino.h>\n#include \"PWMFSelect.h\"\n\n// Digital I/O initialization\nextern \"C\" void PWM_Select(uint8_T PWM_Divisor, uint8_T PWM_Timer)\n{\n\n// If you reading this - yes, there is a better way to code this\n// and if you know how, email me joshua.hurst.rpi@gmail.com\n    \n\n    /*\n     * Timer\tPins\n     * 0    \t4,13\n     * 1\t\t11,12\n     * 2\t\t9,10\n     * 3\t\t2,3,5\n     * 4 \t\t6,7,8\n     * 5 \t\t44,45,46\n     */\n    \n    // DSelect: the frequency divisor selection\n    /*\n     * DSelect Setting \tDivisor \tFrequency\n     * 1\t\t0x01 \t \t1           31372.55\n     * 2\t\t0x02 \t \t8           3921.16\n     * 3\t\t0x03  \t\t64          490.20   <--DEFAULT\n     * 4\t\t0x04  \t\t256 \t \t122.55\n     * 5\t\t0x05 \t \t1024 \t \t30.64\n     */\n    \n    /*\n     * OR\n     * Arduino Pin\t Register    Timer   \tPrescale Register\n     * 2\t         OCR3B\t\t 3\t\t\tTCCR3B\n     * 3\t         OCR3C       3\t\t\tTCCR3B\n     * 4\t         OCR0B       0\t\t\tTCCR0B //Caution: will directly affects major timing functions { i.e delay and millis}\n     * 5\t         OCR3A       3\t\t\tTCCR3B\n     * 6\t         OCR4A       4\t\t\tTCCR4B\n     * 7\t         OCR4B       4\t\t\tTCCR4B\n     * 8\t         OCR4C       4\t\t\tTCCR4B\n     * 9\t         OCR2B       2\t\t\tTCCR2B\n     * 10\t         OCR2A       2\t\t\tTCCR2B\n     * 11\t         OCR1A       1\t\t\tTCCR1B\n     * 12\t         OCR1B       1\t\t\tTCCR1B\n     * 13\t         OCR0A       0\t\t\tTCCR0B //Caution: will directly affects major timing functions { i.e delay and millis}\n     * 44\t         OCR5C       5\t\t\tTCCR5B\n     * 45\t         OCR5B       5\t\t\tTCCR5B\n     * 46\t         OCR5A       5\t\t\tTCCR5B\n     */\n    \n    \n    \n    \n    switch(PWM_Divisor) {\n        case 1:\n            \n            switch(PWM_Timer) {\n                case 1:\n                    TCCR1B=TCCR1B & 0b11111000 | 0x01;\n                    break;\n                case 2:\n                    TCCR2B=TCCR2B & 0b11111000 | 0x01;\n                    break;\n                case 3:\n                    TCCR3B=TCCR3B & 0b11111000 | 0x01;\n                    break;\n                case 4:\n                    TCCR4B=TCCR4B & 0b11111000 | 0x01;\n                    break;\n                case 5:\n                    TCCR5B=TCCR5B & 0b11111000 | 0x01;\n                    break;\n\t\t\t\tcase 6: \n\t\t\t\t\tTCCR0B=TCCR0B & 0b11111000 | 0x01;\n                    break;\n                default:\n                    break;\n            }\n            break;\n            \n            \n        case 2:\n            \n            switch(PWM_Timer) {\n                case 1:\n                    TCCR1B=TCCR1B & 0b11111000 | 0x02;\n                    break;\n                case 2:\n                    TCCR2B=TCCR2B & 0b11111000 | 0x02;\n                    break;\n                case 3:\n                    TCCR3B=TCCR3B & 0b11111000 | 0x02;\n                    break;\n                case 4:\n                    TCCR4B=TCCR4B & 0b11111000 | 0x02;\n                    break;\n                case 5:\n                    TCCR5B=TCCR5B & 0b11111000 | 0x02;\n                    break;\n\t\t\t\tcase 6: \n\t\t\t\t\tTCCR0B=TCCR0B & 0b11111000 | 0x02;\n                    break;\n                default:\n                    break;\n            }\n            break;\n            \n            \n        case 3:\n            \n            switch(PWM_Timer) {\n                case 1:\n                    TCCR1B=TCCR1B & 0b11111000 | 0x03;\n                    break;\n                case 2:\n                    TCCR2B=TCCR2B & 0b11111000 | 0x03;\n                    break;\n                case 3:\n                    TCCR3B=TCCR3B & 0b11111000 | 0x03;\n                    break;\n                case 4:\n                    TCCR4B=TCCR4B & 0b11111000 | 0x03;\n                    break;\n                case 5:\n                    TCCR5B=TCCR5B & 0b11111000 | 0x03;\n                    break;\n\t\t\t\tcase 6: \n\t\t\t\t\tTCCR0B=TCCR0B & 0b11111000 | 0x03;\n                    break;\n                default:\n                    break;\n            }\n            break;\n            \n            \n        case 4:\n            \n            switch(PWM_Timer) {\n                case 1:\n                    TCCR1B=TCCR1B & 0b11111000 | 0x04;\n                    break;\n                case 2:\n                    TCCR2B=TCCR2B & 0b11111000 | 0x04;\n                    break;\n                case 3:\n                    TCCR3B=TCCR3B & 0b11111000 | 0x04;\n                    break;\n                case 4:\n                    TCCR4B=TCCR4B & 0b11111000 | 0x04;\n                    break;\n                case 5:\n                    TCCR5B=TCCR5B & 0b11111000 | 0x04;\n                    break;\n\t\t\t\tcase 6: \n\t\t\t\t\tTCCR0B=TCCR0B & 0b11111000 | 0x04;\n                    break;\n                default:\n                    break;\n            }\n            break;\n            \n            \n        case 5:\n            \n            switch(PWM_Timer) {\n                case 1:\n                    TCCR1B=TCCR1B & 0b11111000 | 0x05;\n                    break;\n                case 2:\n                    TCCR2B=TCCR2B & 0b11111000 | 0x05;\n                    break;\n                case 3:\n                    TCCR3B=TCCR3B & 0b11111000 | 0x05;\n                    break;\n                case 4:\n                    TCCR4B=TCCR4B & 0b11111000 | 0x05;\n                    break;\n                case 5:\n                    TCCR5B=TCCR5B & 0b11111000 | 0x05;\n                    break;\n\t\t\t\tcase 6: \n\t\t\t\t\tTCCR0B=TCCR0B & 0b11111000 | 0x05;\n                    break;\n                default:\n                    break;\n            }\n            break;\n\t\t\t\n        \n            \n        default:\n            \n            switch(PWM_Timer) {\n                case 1:\n                    TCCR1B=TCCR1B & 0b11111000 | 0x03;\n                    break;\n                case 2:\n                    TCCR2B=TCCR2B & 0b11111000 | 0x03;\n                    break;\n                case 3:\n                    TCCR3B=TCCR3B & 0b11111000 | 0x03;\n                    break;\n                case 4:\n                    TCCR4B=TCCR4B & 0b11111000 | 0x03;\n                    break;\n                case 5:\n                    TCCR5B=TCCR5B & 0b11111000 | 0x03;\n                    break;\n\t\t\t\tcase 6: \n\t\t\t\t\tTCCR0B=TCCR0B & 0b11111000 | 0x03;\n                    break;\n                default:\n                    break;\n            }\n            break;\n            \n    }\n}\n"},{"name":"PWMFSelect_uno_nano.cpp","type":"source","group":"other","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"#include <Arduino.h>\n#include \"PWMFSelect.h\"\n\n// Digital I/O initialization\nextern \"C\" void PWM_Select(uint8_T PWM_Divisor, uint8_T PWM_Timer)\n{\n\n// If you reading this - yes, there is a better way to code this\n// and if you know how, email me joshua.hurst.rpi@gmail.com\n    \n\n    /*\n     * Timer\tPins\n     * 0    \t5, 6\n     * 1\t\t9, 10\n     * 2\t\t3, 11\n\n    \n    // DSelect: the frequency divisor selection\n    /*\n     * DSelect Setting \tDivisor \tFrequency\n     * 1\t\t0x01 \t \t1           31372.55\n     * 2\t\t0x02 \t \t8           3921.16\n     * 3\t\t0x03  \t\t64          490.20   <--DEFAULT\n     * 4\t\t0x04  \t\t256 \t \t122.55\n     * 5\t\t0x05 \t \t1024 \t \t30.64\n     */\n       \n    switch(PWM_Divisor) {\n        case 1:\n            \n            switch(PWM_Timer) {\n                case 1:\n                    TCCR0B=TCCR0B & 0b11111000 | 0x01;\n                    break;\n                case 2:\n                    TCCR1B=TCCR1B & 0b11111000 | 0x01;\n                    break;\n                case 3:\n                    TCCR2B=TCCR2B & 0b11111000 | 0x01;\n                    break;              \n                default:\n                    break;\n            }\n            break;\n            \n            \n        case 2:\n            \n            switch(PWM_Timer) {\n                case 1:\n                    TCCR0B=TCCR0B & 0b11111000 | 0x02;\n                    break;\n                case 2:\n                    TCCR1B=TCCR1B & 0b11111000 | 0x02;\n                    break;\n                case 3:\n                    TCCR2B=TCCR2B & 0b11111000 | 0x02;\n                    break;\n                default:\n                    break;\n            }\n            break;\n            \n            \n        case 3:\n            \n            switch(PWM_Timer) {\n                case 1:\n                    TCCR0B=TCCR0B & 0b11111000 | 0x03;\n                    break;\n                case 2:\n                    TCCR1B=TCCR1B & 0b11111000 | 0x03;\n                    break;\n                case 3:\n                    TCCR2B=TCCR2B & 0b11111000 | 0x03;\n                    break;\n                default:\n                    break;\n            }\n            break;\n            \n            \n        case 4:\n            \n            switch(PWM_Timer) {\n                case 1:\n                    TCCR0B=TCCR0B & 0b11111000 | 0x04;\n                    break;\n                case 2:\n                    TCCR1B=TCCR1B & 0b11111000 | 0x04;\n                    break;\n                case 3:\n                    TCCR2B=TCCR2B & 0b11111000 | 0x04;\n                    break;\n                default:\n                    break;\n            }\n            break;\n            \n            \n        case 5:\n            \n            switch(PWM_Timer) {\n                 case 1:\n                    TCCR0B=TCCR0B & 0b11111000 | 0x05;\n                    break;\n                case 2:\n                    TCCR1B=TCCR1B & 0b11111000 | 0x05;\n                    break;\n                case 3:\n                    TCCR2B=TCCR2B & 0b11111000 | 0x05;\n                    break;\n                default:\n                    break;\n            }\n            break;\n            \n            \n        default:\n            \n            switch(PWM_Timer) {\n                case 1:\n                    TCCR0B=TCCR0B & 0b11111000 | 0x03;\n                    break;\n                case 2:\n                    TCCR1B=TCCR1B & 0b11111000 | 0x03;\n                    break;\n                case 3:\n                    TCCR2B=TCCR2B & 0b11111000 | 0x03;\n                    break;\n                default:\n                    break;\n            }\n            break;\n            \n    }\n}\n"},{"name":"QMC5883.cpp","type":"source","group":"other","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"/*!\n * @file QMC5883.cpp\n * @brief Compatible with QMC5883 and QMC5883\n * @n 3-Axis Digital Compass IC\n *\n * @copyright\t[DFRobot](http://www.dfrobot.com), 2017\n * @copyright\tGNU Lesser General Public License\n *\n * @author [dexian.huang](952838602@qq.com)\n * @version  V1.0\n * @date  2017-7-3\n */\n\n#if ARDUINO >= 100\n#include \"Arduino.h\"\n#else\n#include \"WProgram.h\"\n#endif\n\n#include <Wire.h>\n#include \"QMC5883.h\"\n\n\n\nbool QMC5883::begin()\n{\n  bool ret = false;\n  if(ICType == IC_NONE){\n    for(uint8_t i = 0; i < 5; i++){\n      Wire.begin();\n      Wire.beginTransmission(HMC5883L_ADDRESS);\n      if(Wire.endTransmission() == 0){\n        ICType = IC_HMC5883L;\n        this->ICAddr = HMC5883L_ADDRESS;\n        Serial.println(\"ICType = IC_HMC5883L\");\n        break;\n      }\n    }\n  }\n  if(ICType == IC_NONE){\n    for(uint8_t i = 0; i < 5; i++){\n      Wire.begin();\n      Wire.beginTransmission(QMC5883_ADDRESS);\n      if(Wire.endTransmission() == 0){\n        ICType = IC_QMC5883;\n        this->ICAddr = QMC5883_ADDRESS;\n        break;\n      }\n    }\n  }\n  if(ICType == IC_NONE){\n    for(uint8_t i = 0; i < 5; i++){\n      Wire.begin();\n      Wire.beginTransmission(VCM5883L_ADDRESS);\n      if(Wire.endTransmission() == 0){\n        ICType = IC_VCM5883L;\n        this->ICAddr = VCM5883L_ADDRESS;\n        break;\n      }\n    }\n  }\n  switch(ICType){\n    case IC_NONE:\n      ret = false;\n      break;\n    case IC_HMC5883L:\n      if ((fastRegister8(HMC5883L_REG_IDENT_A) != 0x48)|| (fastRegister8(HMC5883L_REG_IDENT_B) != 0x34) || (fastRegister8(HMC5883L_REG_IDENT_C) != 0x33)){\n      return false;\n      }\n      setRange(HMC5883L_RANGE_1_3GA);\n      setMeasurementMode(HMC5883L_CONTINOUS);\n      setDataRate(HMC5883L_DATARATE_15HZ);\n      setSamples(HMC5883L_SAMPLES_1);\n      mgPerDigit = 0.92f;\n      ret = true;\n      Serial.println(\"IC_HMC5883L\");\n      break;\n    case IC_QMC5883:\n      writeRegister8(QMC5883_REG_IDENT_B,0X01);\n      writeRegister8(QMC5883_REG_IDENT_C,0X40);\n      writeRegister8(QMC5883_REG_IDENT_D,0X01);\n      writeRegister8(QMC5883_REG_CONFIG_1,0X1D);\n      if ((fastRegister8(QMC5883_REG_IDENT_B) != 0x01)\n      || (fastRegister8(QMC5883_REG_IDENT_C) != 0x40)\n      || (fastRegister8(QMC5883_REG_IDENT_D) != 0x01)){\n        return false;\n      }\n      setRange(QMC5883_RANGE_8GA);\n      setMeasurementMode(QMC5883_CONTINOUS);\n      setDataRate(QMC5883_DATARATE_50HZ);\n      setSamples(QMC5883_SAMPLES_8);\n      mgPerDigit = 4.35f;\n      ret = true;\n      Serial.println(\"IC_QMC5883\");\n      break;\n    case IC_VCM5883L:\n      writeRegister8(VCM5883L_CTR_REG1,0X00);\n      writeRegister8(VCM5883L_CTR_REG2,0X4D);\n      ret = true;\n      Serial.println(\"IC_VCM5883L\");\n      break;\n    default:\n      ret = false;\n      break;\n  }\n  return ret;\n}\n\nVector QMC5883::readRaw(void)\n{\n  if(ICType == IC_HMC5883L){\n    v.XAxis = readRegister16(HMC5883L_REG_OUT_X_M);\n    v.YAxis = readRegister16(HMC5883L_REG_OUT_Y_M);\n    v.ZAxis = readRegister16(HMC5883L_REG_OUT_Z_M);\n  }else if(ICType == IC_QMC5883){\n    v.XAxis = readRegister16(QMC5883_REG_OUT_X_L);\n    v.YAxis = readRegister16(QMC5883_REG_OUT_Y_L);\n    v.ZAxis = readRegister16(QMC5883_REG_OUT_Z_L);\n  }else if(ICType == IC_VCM5883L){\n    v.XAxis = -readRegister16(VCM5883L_REG_OUT_X_L);\n    v.YAxis = -readRegister16(VCM5883L_REG_OUT_Y_L);\n    v.ZAxis = -readRegister16(VCM5883L_REG_OUT_Z_L);\n  }\n  v.AngleXY = (atan2((double)v.YAxis,(double)v.XAxis) * (180 / 3.14159265) + 180);\n  v.AngleXZ = (atan2((double)v.ZAxis,(double)v.XAxis) * (180 / 3.14159265) + 180);\n  v.AngleYZ = (atan2((double)v.ZAxis,(double)v.YAxis) * (180 / 3.14159265) + 180);\n  return v;\n}\nvoid QMC5883::calibrate()\n{\n  if(v.XAxis < minX ) minX = v.XAxis;\n  if(v.XAxis > maxX ) maxX = v.XAxis;\n  if(v.YAxis < minY ) minY = v.YAxis;\n  if(v.YAxis > maxY ) maxY = v.YAxis;\n  if(v.ZAxis < minZ ) minZ = v.ZAxis;\n  if(v.ZAxis > maxZ ) maxZ = v.ZAxis;\n}\nvoid QMC5883::initMinMax()\n{\n  minX = v.XAxis;\n  maxX = v.XAxis;\n  minY = v.YAxis;\n  maxY = v.YAxis;\n  minZ = v.ZAxis;\n  maxZ = v.ZAxis;\n}\n\nvoid QMC5883::setRange(QMC5883_range_t range)\n{\n  if(ICType == IC_HMC5883L){\n    switch(range){\n    case HMC5883L_RANGE_0_88GA:\n      Gauss_LSB_XY = 1370.0;\n      break;\n\n    case HMC5883L_RANGE_1_3GA:\n      Gauss_LSB_XY = 1090.0;\n      break;\n\n    case HMC5883L_RANGE_1_9GA:\n      Gauss_LSB_XY = 820.0;\n      break;\n\n    case HMC5883L_RANGE_2_5GA:\n      Gauss_LSB_XY = 660.0;\n      break;\n\n    case HMC5883L_RANGE_4GA:\n      Gauss_LSB_XY = 440.0;\n      break;\n\n    case HMC5883L_RANGE_4_7GA:\n      Gauss_LSB_XY = 390.0;\n      break;\n\n    case HMC5883L_RANGE_5_6GA:\n      Gauss_LSB_XY = 330.0;\n      break;\n\n    case HMC5883L_RANGE_8_1GA:\n      Gauss_LSB_XY = 230.0;\n      break;\n    default:\n      break;\n    }\n\n    writeRegister8(HMC5883L_REG_CONFIG_B, range << 5);\n  }else if(ICType == IC_QMC5883){\n    switch(range)\n    {\n    case QMC5883_RANGE_2GA:\n      mgPerDigit = 1.22f;\n      break;\n    case QMC5883_RANGE_8GA:\n      mgPerDigit = 4.35f;\n      break;\n    default:\n      break;\n    }\n    writeRegister8(QMC5883_REG_CONFIG_2, range << 4);\n  }else if(ICType == IC_VCM5883L){\n    //default 8G\n  }\n}\n\nQMC5883_range_t QMC5883::getRange(void)\n{\n  QMC5883_range_t ret;\n  switch(ICType){\n    case IC_HMC5883L:\n      ret = (QMC5883_range_t)((readRegister8(HMC5883L_REG_CONFIG_B) >> 5));\n      break;\n    case IC_QMC5883:\n      ret = (QMC5883_range_t)((readRegister8(QMC5883_REG_CONFIG_2) >> 4));\n      break;\n    case IC_VCM5883L:\n      ret = QMC5883_RANGE_8GA;\n      break;\n    default:\n      ret = QMC5883_RANGE_8GA;\n      break;\n  }\n  return ret;\n}\n\nvoid QMC5883::setMeasurementMode(QMC5883_mode_t mode)\n{\n  uint8_t value;\n  switch(ICType){\n    case IC_HMC5883L:\n      value = readRegister8(HMC5883L_REG_MODE);\n      value &= 0b11111100;\n      value |= mode;\n      writeRegister8(HMC5883L_REG_MODE, value);\n      break;\n    case IC_QMC5883:\n      value = readRegister8(QMC5883_REG_CONFIG_1);\n      value &= 0xfc;\n      value |= mode;\n      writeRegister8(QMC5883_REG_CONFIG_1, value);\n      break;\n    case IC_VCM5883L:\n      value = readRegister8(VCM5883L_CTR_REG2);\n      value &= 0xFE;\n      value |= mode;\n      writeRegister8(VCM5883L_CTR_REG2, value);\n      break;\n    default:\n      break;\n  }\n}\n\nQMC5883_mode_t QMC5883::getMeasurementMode(void)\n{\n  uint8_t value=0;\n  switch(ICType){\n    case IC_HMC5883L:\n      value = readRegister8(HMC5883L_REG_MODE);\n      value &= 0b00000011;  \n      break;\n    case IC_QMC5883:\n      value = readRegister8(QMC5883_REG_CONFIG_1);\n      value &= 0b00000011;  \n      break;\n    case IC_VCM5883L:\n      value = readRegister8(VCM5883L_CTR_REG2);\n      value &= 0b00000001;  \n      break;\n    default:\n      break;\n  }\n  return (QMC5883_mode_t)value;\n}\n\nvoid QMC5883::setDataRate(QMC5883_dataRate_t dataRate)\n{\n  uint8_t value;\n  switch(ICType){\n    case IC_HMC5883L:\n      value = readRegister8(HMC5883L_REG_CONFIG_A);\n      value &= 0b11100011;\n      value |= (dataRate << 2);\n      writeRegister8(HMC5883L_REG_CONFIG_A, value);\n      break;\n    case IC_QMC5883:\n      value = readRegister8(QMC5883_REG_CONFIG_1);\n      value &= 0xf3;\n      value |= (dataRate << 2);\n      writeRegister8(QMC5883_REG_CONFIG_1, value);\n      break;\n    case IC_VCM5883L:\n      value = readRegister8(VCM5883L_CTR_REG2);\n      value &= 0xf3;\n      value |= (dataRate << 2);\n      writeRegister8(VCM5883L_CTR_REG2, value);\n      break;\n    default:\n      break;\n  }\n}\n\nQMC5883_dataRate_t QMC5883::getDataRate(void)\n{\n  uint8_t value=0;\n  switch(ICType){\n    case IC_HMC5883L:\n      value = readRegister8(HMC5883L_REG_CONFIG_A);\n      value &= 0b00011100;\n      value >>= 2;\n      break;\n    case IC_QMC5883:\n      value = readRegister8(QMC5883_REG_CONFIG_1);\n      value &= 0b00001100;\n      value >>= 2;\n      break;\n    case IC_VCM5883L:\n      value = readRegister8(VCM5883L_CTR_REG2);\n      value &= 0b00001100;\n      value >>= 2;\n      break;\n    default:\n      break;\n  }\n  return (QMC5883_dataRate_t)value;\n}\n\nvoid QMC5883::setSamples(QMC5883_samples_t samples)\n{\n  uint8_t value;\n  switch(ICType){\n    case IC_HMC5883L:\n      value = readRegister8(HMC5883L_REG_CONFIG_A);\n      value &= 0b10011111;\n      value |= (samples << 5);\n      writeRegister8(HMC5883L_REG_CONFIG_A, value);\n      break;\n    case IC_QMC5883:\n      value = readRegister8(QMC5883_REG_CONFIG_1);\n      value &= 0x3f;\n      value |= (samples << 6);\n      writeRegister8(QMC5883_REG_CONFIG_1, value);\n      break;\n    case IC_VCM5883L:\n      value = readRegister8(QMC5883_REG_CONFIG_1);\n      value &= 0x3f;\n      value |= (samples << 6);\n      writeRegister8(QMC5883_REG_CONFIG_1, value);\n      break;\n    default:\n      break;\n  }\n}\n\nQMC5883_samples_t QMC5883::getSamples(void)\n{\n  uint8_t value=0;\n  switch(ICType){\n    case IC_HMC5883L:\n      value = readRegister8(HMC5883L_REG_CONFIG_A);\n      value &= 0b01100000;\n      value >>= 5;\n      break;\n    case IC_QMC5883:\n      value = readRegister8(QMC5883_REG_CONFIG_1);\n      value &= 0x3f;\n      value >>= 6;\n      break;\n    case IC_VCM5883L:\n      value = readRegister8(QMC5883_REG_CONFIG_1);\n      value &= 0x3f;\n      value >>= 6;\n      break;\n    default:\n      break;\n  }\n  return (QMC5883_samples_t)value;\n}\n\nvoid QMC5883::setDeclinationAngle(float declinationAngle){\n  this->ICdeclinationAngle = declinationAngle;\n}\n\nvoid QMC5883::getHeadingDegrees(){\n  //double XuT,YuT,ZuT;\n  //readRaw();\n  //XuT = v.XAxis / Gauss_LSB_XY * 100;\n  //YuT = v.YAxis / Gauss_LSB_XY * 100;\n  //ZuT = v.ZAxis / Gauss_LSB_XY * 100;\n  float heading = atan2(v.YAxis ,v.XAxis);\n  heading += this->ICdeclinationAngle;\n  if(heading < 0)\n    heading += 2*PI;\n  if(heading > 2*PI)\n    heading -= 2*PI;\n  v.HeadingDegress = heading * 180/PI;\n}\n// Write byte to register\nvoid QMC5883::writeRegister8(uint8_t reg, uint8_t value)\n{\n  Wire.beginTransmission(this->ICAddr);\n  #if ARDUINO >= 100\n    Wire.write(reg);\n    Wire.write(value);\n  #else\n    Wire.send(reg);\n    Wire.send(value);\n  #endif\n    Wire.endTransmission();\n}\n// Read byte to register\nuint8_t QMC5883::fastRegister8(uint8_t reg)\n{\n  uint8_t value=0;\n  Wire.beginTransmission(this->ICAddr);\n  #if ARDUINO >= 100\n    Wire.write(reg);\n  #else\n    Wire.send(reg);\n  #endif\n  Wire.endTransmission();\n  Wire.requestFrom((uint8_t)this->ICAddr, (uint8_t)1);\n  #if ARDUINO >= 100\n    value = Wire.read();\n  #else\n    value = Wire.receive();\n  #endif\n  Wire.endTransmission();\n  return value;\n}\n\n// Read byte from register\nuint8_t QMC5883::readRegister8(uint8_t reg)\n{\n  uint8_t value=0;\n  Wire.beginTransmission(this->ICAddr);\n  #if ARDUINO >= 100\n    Wire.write(reg);\n  #else\n    Wire.send(reg);\n  #endif\n  Wire.endTransmission();\n  Wire.requestFrom((uint8_t)this->ICAddr, (uint8_t)1);\n  while(!Wire.available()) {};\n  #if ARDUINO >= 100\n    value = Wire.read();\n  #else\n    value = Wire.receive();\n  #endif\n  return value;\n}\n// Read word from register\nint16_t QMC5883::readRegister16(uint8_t reg)\n{\n  int16_t value=0;\n  uint8_t vha,vla;\n  Wire.beginTransmission(this->ICAddr);\n  #if ARDUINO >= 100\n    Wire.write(reg);\n  #else\n    Wire.send(reg);\n  #endif\n  Wire.endTransmission();\n  Wire.requestFrom((uint8_t)this->ICAddr, (uint8_t)2);\n  while(!Wire.available()) {};\n  if(ICType == IC_HMC5883L){\n    #if ARDUINO >= 100\n      vha = Wire.read();\n      vla = Wire.read();\n    #else\n      vha = Wire.receive();\n      vla = Wire.receive();\n    #endif\n  }else{\n    #if ARDUINO >= 100\n      vla = Wire.read();\n      vha = Wire.read();\n    #else\n      vla = Wire.receive();\n      vha = Wire.receive();\n    #endif\n  }\n  value = vha << 8 | vla;\n  return value;\n}\n\nint QMC5883::getICType(void)\n{\n  return ICType;\n}\n"},{"name":"QMC5883wrapper.cpp","type":"source","group":"other","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"\n#include \"Wire.h\"\n#include \"twi.h\"\n#include \"I2Cdev.h\"\n#include \"QMC5883.h\"\n\nQMC5883 compass;\n\nextern \"C\" void QMC5883_Init(void)\n{\n    Wire.begin();\n    compass.begin();\n\t\n\t//compass.setRange(QMC5883_RANGE_2GA);\n    //compass.setMeasurementMode(QMC5883_CONTINOUS); \n    //compass.setDataRate(QMC5883_DATARATE_50HZ);\n    //compass.setSamples(QMC5883_SAMPLES_8);\n\n}\n\nextern \"C\" void QMC5883_ReadMag(int* pfData)\n{\n\n\tVector mag = compass.readRaw();\n\n    pfData[0]=mag.XAxis;\n\tpfData[1]=mag.YAxis;\n    pfData[2]=mag.ZAxis;\n\t\n}"},{"name":"VL53L0X.cpp","type":"source","group":"other","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"// Most of the functionality of this library is based on the VL53L0X API\n// provided by ST (STSW-IMG005), and some of the explanatory comments are quoted\n// or paraphrased from the API source code, API user manual (UM2039), and the\n// VL53L0X datasheet.\n\n#include <VL53L0X.h>\n#include <Wire.h>\n\n// Defines /////////////////////////////////////////////////////////////////////\n\n// The Arduino two-wire interface uses a 7-bit number for the address,\n// and sets the last bit correctly based on reads and writes\n#define ADDRESS_DEFAULT 0b0101001\n\n// Record the current time to check an upcoming timeout against\n#define startTimeout() (timeout_start_ms = millis())\n\n// Check if timeout is enabled (set to nonzero value) and has expired\n#define checkTimeoutExpired() (io_timeout > 0 && ((uint16_t)millis() - timeout_start_ms) > io_timeout)\n\n// Decode VCSEL (vertical cavity surface emitting laser) pulse period in PCLKs\n// from register value\n// based on VL53L0X_decode_vcsel_period()\n#define decodeVcselPeriod(reg_val)      (((reg_val) + 1) << 1)\n\n// Encode VCSEL pulse period register value from period in PCLKs\n// based on VL53L0X_encode_vcsel_period()\n#define encodeVcselPeriod(period_pclks) (((period_pclks) >> 1) - 1)\n\n// Calculate macro period in *nanoseconds* from VCSEL period in PCLKs\n// based on VL53L0X_calc_macro_period_ps()\n// PLL_period_ps = 1655; macro_period_vclks = 2304\n#define calcMacroPeriod(vcsel_period_pclks) ((((uint32_t)2304 * (vcsel_period_pclks) * 1655) + 500) / 1000)\n\n// Constructors ////////////////////////////////////////////////////////////////\n\nVL53L0X::VL53L0X(void)\n  : address(ADDRESS_DEFAULT)\n  , io_timeout(0) // no timeout\n  , did_timeout(false)\n{\n}\n\n// Public Methods //////////////////////////////////////////////////////////////\n\nvoid VL53L0X::setAddress(uint8_t new_addr)\n{\n  writeReg(I2C_SLAVE_DEVICE_ADDRESS, new_addr & 0x7F);\n  address = new_addr;\n}\n\n// Initialize sensor using sequence based on VL53L0X_DataInit(),\n// VL53L0X_StaticInit(), and VL53L0X_PerformRefCalibration().\n// This function does not perform reference SPAD calibration\n// (VL53L0X_PerformRefSpadManagement()), since the API user manual says that it\n// is performed by ST on the bare modules; it seems like that should work well\n// enough unless a cover glass is added.\n// If io_2v8 (optional) is true or not given, the sensor is configured for 2V8\n// mode.\nbool VL53L0X::init(bool io_2v8)\n{\n  // VL53L0X_DataInit() begin\n\n  // sensor uses 1V8 mode for I/O by default; switch to 2V8 mode if necessary\n  if (io_2v8)\n  {\n    writeReg(VHV_CONFIG_PAD_SCL_SDA__EXTSUP_HV,\n      readReg(VHV_CONFIG_PAD_SCL_SDA__EXTSUP_HV) | 0x01); // set bit 0\n  }\n\n  // \"Set I2C standard mode\"\n  writeReg(0x88, 0x00);\n\n  writeReg(0x80, 0x01);\n  writeReg(0xFF, 0x01);\n  writeReg(0x00, 0x00);\n  stop_variable = readReg(0x91);\n  writeReg(0x00, 0x01);\n  writeReg(0xFF, 0x00);\n  writeReg(0x80, 0x00);\n\n  // disable SIGNAL_RATE_MSRC (bit 1) and SIGNAL_RATE_PRE_RANGE (bit 4) limit checks\n  writeReg(MSRC_CONFIG_CONTROL, readReg(MSRC_CONFIG_CONTROL) | 0x12);\n\n  // set final range signal rate limit to 0.25 MCPS (million counts per second)\n  setSignalRateLimit(0.25);\n\n  writeReg(SYSTEM_SEQUENCE_CONFIG, 0xFF);\n\n  // VL53L0X_DataInit() end\n\n  // VL53L0X_StaticInit() begin\n\n  uint8_t spad_count;\n  bool spad_type_is_aperture;\n  if (!getSpadInfo(&spad_count, &spad_type_is_aperture)) { return false; }\n\n  // The SPAD map (RefGoodSpadMap) is read by VL53L0X_get_info_from_device() in\n  // the API, but the same data seems to be more easily readable from\n  // GLOBAL_CONFIG_SPAD_ENABLES_REF_0 through _6, so read it from there\n  uint8_t ref_spad_map[6];\n  readMulti(GLOBAL_CONFIG_SPAD_ENABLES_REF_0, ref_spad_map, 6);\n\n  // -- VL53L0X_set_reference_spads() begin (assume NVM values are valid)\n\n  writeReg(0xFF, 0x01);\n  writeReg(DYNAMIC_SPAD_REF_EN_START_OFFSET, 0x00);\n  writeReg(DYNAMIC_SPAD_NUM_REQUESTED_REF_SPAD, 0x2C);\n  writeReg(0xFF, 0x00);\n  writeReg(GLOBAL_CONFIG_REF_EN_START_SELECT, 0xB4);\n\n  uint8_t first_spad_to_enable = spad_type_is_aperture ? 12 : 0; // 12 is the first aperture spad\n  uint8_t spads_enabled = 0;\n\n  for (uint8_t i = 0; i < 48; i++)\n  {\n    if (i < first_spad_to_enable || spads_enabled == spad_count)\n    {\n      // This bit is lower than the first one that should be enabled, or\n      // (reference_spad_count) bits have already been enabled, so zero this bit\n      ref_spad_map[i / 8] &= ~(1 << (i % 8));\n    }\n    else if ((ref_spad_map[i / 8] >> (i % 8)) & 0x1)\n    {\n      spads_enabled++;\n    }\n  }\n\n  writeMulti(GLOBAL_CONFIG_SPAD_ENABLES_REF_0, ref_spad_map, 6);\n\n  // -- VL53L0X_set_reference_spads() end\n\n  // -- VL53L0X_load_tuning_settings() begin\n  // DefaultTuningSettings from vl53l0x_tuning.h\n\n  writeReg(0xFF, 0x01);\n  writeReg(0x00, 0x00);\n\n  writeReg(0xFF, 0x00);\n  writeReg(0x09, 0x00);\n  writeReg(0x10, 0x00);\n  writeReg(0x11, 0x00);\n\n  writeReg(0x24, 0x01);\n  writeReg(0x25, 0xFF);\n  writeReg(0x75, 0x00);\n\n  writeReg(0xFF, 0x01);\n  writeReg(0x4E, 0x2C);\n  writeReg(0x48, 0x00);\n  writeReg(0x30, 0x20);\n\n  writeReg(0xFF, 0x00);\n  writeReg(0x30, 0x09);\n  writeReg(0x54, 0x00);\n  writeReg(0x31, 0x04);\n  writeReg(0x32, 0x03);\n  writeReg(0x40, 0x83);\n  writeReg(0x46, 0x25);\n  writeReg(0x60, 0x00);\n  writeReg(0x27, 0x00);\n  writeReg(0x50, 0x06);\n  writeReg(0x51, 0x00);\n  writeReg(0x52, 0x96);\n  writeReg(0x56, 0x08);\n  writeReg(0x57, 0x30);\n  writeReg(0x61, 0x00);\n  writeReg(0x62, 0x00);\n  writeReg(0x64, 0x00);\n  writeReg(0x65, 0x00);\n  writeReg(0x66, 0xA0);\n\n  writeReg(0xFF, 0x01);\n  writeReg(0x22, 0x32);\n  writeReg(0x47, 0x14);\n  writeReg(0x49, 0xFF);\n  writeReg(0x4A, 0x00);\n\n  writeReg(0xFF, 0x00);\n  writeReg(0x7A, 0x0A);\n  writeReg(0x7B, 0x00);\n  writeReg(0x78, 0x21);\n\n  writeReg(0xFF, 0x01);\n  writeReg(0x23, 0x34);\n  writeReg(0x42, 0x00);\n  writeReg(0x44, 0xFF);\n  writeReg(0x45, 0x26);\n  writeReg(0x46, 0x05);\n  writeReg(0x40, 0x40);\n  writeReg(0x0E, 0x06);\n  writeReg(0x20, 0x1A);\n  writeReg(0x43, 0x40);\n\n  writeReg(0xFF, 0x00);\n  writeReg(0x34, 0x03);\n  writeReg(0x35, 0x44);\n\n  writeReg(0xFF, 0x01);\n  writeReg(0x31, 0x04);\n  writeReg(0x4B, 0x09);\n  writeReg(0x4C, 0x05);\n  writeReg(0x4D, 0x04);\n\n  writeReg(0xFF, 0x00);\n  writeReg(0x44, 0x00);\n  writeReg(0x45, 0x20);\n  writeReg(0x47, 0x08);\n  writeReg(0x48, 0x28);\n  writeReg(0x67, 0x00);\n  writeReg(0x70, 0x04);\n  writeReg(0x71, 0x01);\n  writeReg(0x72, 0xFE);\n  writeReg(0x76, 0x00);\n  writeReg(0x77, 0x00);\n\n  writeReg(0xFF, 0x01);\n  writeReg(0x0D, 0x01);\n\n  writeReg(0xFF, 0x00);\n  writeReg(0x80, 0x01);\n  writeReg(0x01, 0xF8);\n\n  writeReg(0xFF, 0x01);\n  writeReg(0x8E, 0x01);\n  writeReg(0x00, 0x01);\n  writeReg(0xFF, 0x00);\n  writeReg(0x80, 0x00);\n\n  // -- VL53L0X_load_tuning_settings() end\n\n  // \"Set interrupt config to new sample ready\"\n  // -- VL53L0X_SetGpioConfig() begin\n\n  writeReg(SYSTEM_INTERRUPT_CONFIG_GPIO, 0x04);\n  writeReg(GPIO_HV_MUX_ACTIVE_HIGH, readReg(GPIO_HV_MUX_ACTIVE_HIGH) & ~0x10); // active low\n  writeReg(SYSTEM_INTERRUPT_CLEAR, 0x01);\n\n  // -- VL53L0X_SetGpioConfig() end\n\n  measurement_timing_budget_us = getMeasurementTimingBudget();\n\n  // \"Disable MSRC and TCC by default\"\n  // MSRC = Minimum Signal Rate Check\n  // TCC = Target CentreCheck\n  // -- VL53L0X_SetSequenceStepEnable() begin\n\n  writeReg(SYSTEM_SEQUENCE_CONFIG, 0xE8);\n\n  // -- VL53L0X_SetSequenceStepEnable() end\n\n  // \"Recalculate timing budget\"\n  setMeasurementTimingBudget(measurement_timing_budget_us);\n\n  // VL53L0X_StaticInit() end\n\n  // VL53L0X_PerformRefCalibration() begin (VL53L0X_perform_ref_calibration())\n\n  // -- VL53L0X_perform_vhv_calibration() begin\n\n  writeReg(SYSTEM_SEQUENCE_CONFIG, 0x01);\n  if (!performSingleRefCalibration(0x40)) { return false; }\n\n  // -- VL53L0X_perform_vhv_calibration() end\n\n  // -- VL53L0X_perform_phase_calibration() begin\n\n  writeReg(SYSTEM_SEQUENCE_CONFIG, 0x02);\n  if (!performSingleRefCalibration(0x00)) { return false; }\n\n  // -- VL53L0X_perform_phase_calibration() end\n\n  // \"restore the previous Sequence Config\"\n  writeReg(SYSTEM_SEQUENCE_CONFIG, 0xE8);\n\n  // VL53L0X_PerformRefCalibration() end\n\n  return true;\n}\n\n// Write an 8-bit register\nvoid VL53L0X::writeReg(uint8_t reg, uint8_t value)\n{\n  Wire.beginTransmission(address);\n  Wire.write(reg);\n  Wire.write(value);\n  last_status = Wire.endTransmission();\n}\n\n// Write a 16-bit register\nvoid VL53L0X::writeReg16Bit(uint8_t reg, uint16_t value)\n{\n  Wire.beginTransmission(address);\n  Wire.write(reg);\n  Wire.write((value >> 8) & 0xFF); // value high byte\n  Wire.write( value       & 0xFF); // value low byte\n  last_status = Wire.endTransmission();\n}\n\n// Write a 32-bit register\nvoid VL53L0X::writeReg32Bit(uint8_t reg, uint32_t value)\n{\n  Wire.beginTransmission(address);\n  Wire.write(reg);\n  Wire.write((value >> 24) & 0xFF); // value highest byte\n  Wire.write((value >> 16) & 0xFF);\n  Wire.write((value >>  8) & 0xFF);\n  Wire.write( value        & 0xFF); // value lowest byte\n  last_status = Wire.endTransmission();\n}\n\n// Read an 8-bit register\nuint8_t VL53L0X::readReg(uint8_t reg)\n{\n  uint8_t value;\n\n  Wire.beginTransmission(address);\n  Wire.write(reg);\n  last_status = Wire.endTransmission();\n\n  Wire.requestFrom(address, (uint8_t)1);\n  value = Wire.read();\n\n  return value;\n}\n\n// Read a 16-bit register\nuint16_t VL53L0X::readReg16Bit(uint8_t reg)\n{\n  uint16_t value;\n\n  Wire.beginTransmission(address);\n  Wire.write(reg);\n  last_status = Wire.endTransmission();\n\n  Wire.requestFrom(address, (uint8_t)2);\n  value  = (uint16_t)Wire.read() << 8; // value high byte\n  value |=           Wire.read();      // value low byte\n\n  return value;\n}\n\n// Read a 32-bit register\nuint32_t VL53L0X::readReg32Bit(uint8_t reg)\n{\n  uint32_t value;\n\n  Wire.beginTransmission(address);\n  Wire.write(reg);\n  last_status = Wire.endTransmission();\n\n  Wire.requestFrom(address, (uint8_t)4);\n  value  = (uint32_t)Wire.read() << 24; // value highest byte\n  value |= (uint32_t)Wire.read() << 16;\n  value |= (uint16_t)Wire.read() <<  8;\n  value |=           Wire.read();       // value lowest byte\n\n  return value;\n}\n\n// Write an arbitrary number of bytes from the given array to the sensor,\n// starting at the given register\nvoid VL53L0X::writeMulti(uint8_t reg, uint8_t const * src, uint8_t count)\n{\n  Wire.beginTransmission(address);\n  Wire.write(reg);\n\n  while (count-- > 0)\n  {\n    Wire.write(*(src++));\n  }\n\n  last_status = Wire.endTransmission();\n}\n\n// Read an arbitrary number of bytes from the sensor, starting at the given\n// register, into the given array\nvoid VL53L0X::readMulti(uint8_t reg, uint8_t * dst, uint8_t count)\n{\n  Wire.beginTransmission(address);\n  Wire.write(reg);\n  last_status = Wire.endTransmission();\n\n  Wire.requestFrom(address, count);\n\n  while (count-- > 0)\n  {\n    *(dst++) = Wire.read();\n  }\n}\n\n// Set the return signal rate limit check value in units of MCPS (mega counts\n// per second). \"This represents the amplitude of the signal reflected from the\n// target and detected by the device\"; setting this limit presumably determines\n// the minimum measurement necessary for the sensor to report a valid reading.\n// Setting a lower limit increases the potential range of the sensor but also\n// seems to increase the likelihood of getting an inaccurate reading because of\n// unwanted reflections from objects other than the intended target.\n// Defaults to 0.25 MCPS as initialized by the ST API and this library.\nbool VL53L0X::setSignalRateLimit(float limit_Mcps)\n{\n  if (limit_Mcps < 0 || limit_Mcps > 511.99) { return false; }\n\n  // Q9.7 fixed point format (9 integer bits, 7 fractional bits)\n  writeReg16Bit(FINAL_RANGE_CONFIG_MIN_COUNT_RATE_RTN_LIMIT, limit_Mcps * (1 << 7));\n  return true;\n}\n\n// Get the return signal rate limit check value in MCPS\nfloat VL53L0X::getSignalRateLimit(void)\n{\n  return (float)readReg16Bit(FINAL_RANGE_CONFIG_MIN_COUNT_RATE_RTN_LIMIT) / (1 << 7);\n}\n\n// Set the measurement timing budget in microseconds, which is the time allowed\n// for one measurement; the ST API and this library take care of splitting the\n// timing budget among the sub-steps in the ranging sequence. A longer timing\n// budget allows for more accurate measurements. Increasing the budget by a\n// factor of N decreases the range measurement standard deviation by a factor of\n// sqrt(N). Defaults to about 33 milliseconds; the minimum is 20 ms.\n// based on VL53L0X_set_measurement_timing_budget_micro_seconds()\nbool VL53L0X::setMeasurementTimingBudget(uint32_t budget_us)\n{\n  SequenceStepEnables enables;\n  SequenceStepTimeouts timeouts;\n\n  uint16_t const StartOverhead      = 1320; // note that this is different than the value in get_\n  uint16_t const EndOverhead        = 960;\n  uint16_t const MsrcOverhead       = 660;\n  uint16_t const TccOverhead        = 590;\n  uint16_t const DssOverhead        = 690;\n  uint16_t const PreRangeOverhead   = 660;\n  uint16_t const FinalRangeOverhead = 550;\n\n  uint32_t const MinTimingBudget = 20000;\n\n  if (budget_us < MinTimingBudget) { return false; }\n\n  uint32_t used_budget_us = StartOverhead + EndOverhead;\n\n  getSequenceStepEnables(&enables);\n  getSequenceStepTimeouts(&enables, &timeouts);\n\n  if (enables.tcc)\n  {\n    used_budget_us += (timeouts.msrc_dss_tcc_us + TccOverhead);\n  }\n\n  if (enables.dss)\n  {\n    used_budget_us += 2 * (timeouts.msrc_dss_tcc_us + DssOverhead);\n  }\n  else if (enables.msrc)\n  {\n    used_budget_us += (timeouts.msrc_dss_tcc_us + MsrcOverhead);\n  }\n\n  if (enables.pre_range)\n  {\n    used_budget_us += (timeouts.pre_range_us + PreRangeOverhead);\n  }\n\n  if (enables.final_range)\n  {\n    used_budget_us += FinalRangeOverhead;\n\n    // \"Note that the final range timeout is determined by the timing\n    // budget and the sum of all other timeouts within the sequence.\n    // If there is no room for the final range timeout, then an error\n    // will be set. Otherwise the remaining time will be applied to\n    // the final range.\"\n\n    if (used_budget_us > budget_us)\n    {\n      // \"Requested timeout too big.\"\n      return false;\n    }\n\n    uint32_t final_range_timeout_us = budget_us - used_budget_us;\n\n    // set_sequence_step_timeout() begin\n    // (SequenceStepId == VL53L0X_SEQUENCESTEP_FINAL_RANGE)\n\n    // \"For the final range timeout, the pre-range timeout\n    //  must be added. To do this both final and pre-range\n    //  timeouts must be expressed in macro periods MClks\n    //  because they have different vcsel periods.\"\n\n    uint16_t final_range_timeout_mclks =\n      timeoutMicrosecondsToMclks(final_range_timeout_us,\n                                 timeouts.final_range_vcsel_period_pclks);\n\n    if (enables.pre_range)\n    {\n      final_range_timeout_mclks += timeouts.pre_range_mclks;\n    }\n\n    writeReg16Bit(FINAL_RANGE_CONFIG_TIMEOUT_MACROP_HI,\n      encodeTimeout(final_range_timeout_mclks));\n\n    // set_sequence_step_timeout() end\n\n    measurement_timing_budget_us = budget_us; // store for internal reuse\n  }\n  return true;\n}\n\n// Get the measurement timing budget in microseconds\n// based on VL53L0X_get_measurement_timing_budget_micro_seconds()\n// in us\nuint32_t VL53L0X::getMeasurementTimingBudget(void)\n{\n  SequenceStepEnables enables;\n  SequenceStepTimeouts timeouts;\n\n  uint16_t const StartOverhead     = 1910; // note that this is different than the value in set_\n  uint16_t const EndOverhead        = 960;\n  uint16_t const MsrcOverhead       = 660;\n  uint16_t const TccOverhead        = 590;\n  uint16_t const DssOverhead        = 690;\n  uint16_t const PreRangeOverhead   = 660;\n  uint16_t const FinalRangeOverhead = 550;\n\n  // \"Start and end overhead times always present\"\n  uint32_t budget_us = StartOverhead + EndOverhead;\n\n  getSequenceStepEnables(&enables);\n  getSequenceStepTimeouts(&enables, &timeouts);\n\n  if (enables.tcc)\n  {\n    budget_us += (timeouts.msrc_dss_tcc_us + TccOverhead);\n  }\n\n  if (enables.dss)\n  {\n    budget_us += 2 * (timeouts.msrc_dss_tcc_us + DssOverhead);\n  }\n  else if (enables.msrc)\n  {\n    budget_us += (timeouts.msrc_dss_tcc_us + MsrcOverhead);\n  }\n\n  if (enables.pre_range)\n  {\n    budget_us += (timeouts.pre_range_us + PreRangeOverhead);\n  }\n\n  if (enables.final_range)\n  {\n    budget_us += (timeouts.final_range_us + FinalRangeOverhead);\n  }\n\n  measurement_timing_budget_us = budget_us; // store for internal reuse\n  return budget_us;\n}\n\n// Set the VCSEL (vertical cavity surface emitting laser) pulse period for the\n// given period type (pre-range or final range) to the given value in PCLKs.\n// Longer periods seem to increase the potential range of the sensor.\n// Valid values are (even numbers only):\n//  pre:  12 to 18 (initialized default: 14)\n//  final: 8 to 14 (initialized default: 10)\n// based on VL53L0X_set_vcsel_pulse_period()\nbool VL53L0X::setVcselPulsePeriod(vcselPeriodType type, uint8_t period_pclks)\n{\n  uint8_t vcsel_period_reg = encodeVcselPeriod(period_pclks);\n\n  SequenceStepEnables enables;\n  SequenceStepTimeouts timeouts;\n\n  getSequenceStepEnables(&enables);\n  getSequenceStepTimeouts(&enables, &timeouts);\n\n  // \"Apply specific settings for the requested clock period\"\n  // \"Re-calculate and apply timeouts, in macro periods\"\n\n  // \"When the VCSEL period for the pre or final range is changed,\n  // the corresponding timeout must be read from the device using\n  // the current VCSEL period, then the new VCSEL period can be\n  // applied. The timeout then must be written back to the device\n  // using the new VCSEL period.\n  //\n  // For the MSRC timeout, the same applies - this timeout being\n  // dependant on the pre-range vcsel period.\"\n\n\n  if (type == VcselPeriodPreRange)\n  {\n    // \"Set phase check limits\"\n    switch (period_pclks)\n    {\n      case 12:\n        writeReg(PRE_RANGE_CONFIG_VALID_PHASE_HIGH, 0x18);\n        break;\n\n      case 14:\n        writeReg(PRE_RANGE_CONFIG_VALID_PHASE_HIGH, 0x30);\n        break;\n\n      case 16:\n        writeReg(PRE_RANGE_CONFIG_VALID_PHASE_HIGH, 0x40);\n        break;\n\n      case 18:\n        writeReg(PRE_RANGE_CONFIG_VALID_PHASE_HIGH, 0x50);\n        break;\n\n      default:\n        // invalid period\n        return false;\n    }\n    writeReg(PRE_RANGE_CONFIG_VALID_PHASE_LOW, 0x08);\n\n    // apply new VCSEL period\n    writeReg(PRE_RANGE_CONFIG_VCSEL_PERIOD, vcsel_period_reg);\n\n    // update timeouts\n\n    // set_sequence_step_timeout() begin\n    // (SequenceStepId == VL53L0X_SEQUENCESTEP_PRE_RANGE)\n\n    uint16_t new_pre_range_timeout_mclks =\n      timeoutMicrosecondsToMclks(timeouts.pre_range_us, period_pclks);\n\n    writeReg16Bit(PRE_RANGE_CONFIG_TIMEOUT_MACROP_HI,\n      encodeTimeout(new_pre_range_timeout_mclks));\n\n    // set_sequence_step_timeout() end\n\n    // set_sequence_step_timeout() begin\n    // (SequenceStepId == VL53L0X_SEQUENCESTEP_MSRC)\n\n    uint16_t new_msrc_timeout_mclks =\n      timeoutMicrosecondsToMclks(timeouts.msrc_dss_tcc_us, period_pclks);\n\n    writeReg(MSRC_CONFIG_TIMEOUT_MACROP,\n      (new_msrc_timeout_mclks > 256) ? 255 : (new_msrc_timeout_mclks - 1));\n\n    // set_sequence_step_timeout() end\n  }\n  else if (type == VcselPeriodFinalRange)\n  {\n    switch (period_pclks)\n    {\n      case 8:\n        writeReg(FINAL_RANGE_CONFIG_VALID_PHASE_HIGH, 0x10);\n        writeReg(FINAL_RANGE_CONFIG_VALID_PHASE_LOW,  0x08);\n        writeReg(GLOBAL_CONFIG_VCSEL_WIDTH, 0x02);\n        writeReg(ALGO_PHASECAL_CONFIG_TIMEOUT, 0x0C);\n        writeReg(0xFF, 0x01);\n        writeReg(ALGO_PHASECAL_LIM, 0x30);\n        writeReg(0xFF, 0x00);\n        break;\n\n      case 10:\n        writeReg(FINAL_RANGE_CONFIG_VALID_PHASE_HIGH, 0x28);\n        writeReg(FINAL_RANGE_CONFIG_VALID_PHASE_LOW,  0x08);\n        writeReg(GLOBAL_CONFIG_VCSEL_WIDTH, 0x03);\n        writeReg(ALGO_PHASECAL_CONFIG_TIMEOUT, 0x09);\n        writeReg(0xFF, 0x01);\n        writeReg(ALGO_PHASECAL_LIM, 0x20);\n        writeReg(0xFF, 0x00);\n        break;\n\n      case 12:\n        writeReg(FINAL_RANGE_CONFIG_VALID_PHASE_HIGH, 0x38);\n        writeReg(FINAL_RANGE_CONFIG_VALID_PHASE_LOW,  0x08);\n        writeReg(GLOBAL_CONFIG_VCSEL_WIDTH, 0x03);\n        writeReg(ALGO_PHASECAL_CONFIG_TIMEOUT, 0x08);\n        writeReg(0xFF, 0x01);\n        writeReg(ALGO_PHASECAL_LIM, 0x20);\n        writeReg(0xFF, 0x00);\n        break;\n\n      case 14:\n        writeReg(FINAL_RANGE_CONFIG_VALID_PHASE_HIGH, 0x48);\n        writeReg(FINAL_RANGE_CONFIG_VALID_PHASE_LOW,  0x08);\n        writeReg(GLOBAL_CONFIG_VCSEL_WIDTH, 0x03);\n        writeReg(ALGO_PHASECAL_CONFIG_TIMEOUT, 0x07);\n        writeReg(0xFF, 0x01);\n        writeReg(ALGO_PHASECAL_LIM, 0x20);\n        writeReg(0xFF, 0x00);\n        break;\n\n      default:\n        // invalid period\n        return false;\n    }\n\n    // apply new VCSEL period\n    writeReg(FINAL_RANGE_CONFIG_VCSEL_PERIOD, vcsel_period_reg);\n\n    // update timeouts\n\n    // set_sequence_step_timeout() begin\n    // (SequenceStepId == VL53L0X_SEQUENCESTEP_FINAL_RANGE)\n\n    // \"For the final range timeout, the pre-range timeout\n    //  must be added. To do this both final and pre-range\n    //  timeouts must be expressed in macro periods MClks\n    //  because they have different vcsel periods.\"\n\n    uint16_t new_final_range_timeout_mclks =\n      timeoutMicrosecondsToMclks(timeouts.final_range_us, period_pclks);\n\n    if (enables.pre_range)\n    {\n      new_final_range_timeout_mclks += timeouts.pre_range_mclks;\n    }\n\n    writeReg16Bit(FINAL_RANGE_CONFIG_TIMEOUT_MACROP_HI,\n      encodeTimeout(new_final_range_timeout_mclks));\n\n    // set_sequence_step_timeout end\n  }\n  else\n  {\n    // invalid type\n    return false;\n  }\n\n  // \"Finally, the timing budget must be re-applied\"\n\n  setMeasurementTimingBudget(measurement_timing_budget_us);\n\n  // \"Perform the phase calibration. This is needed after changing on vcsel period.\"\n  // VL53L0X_perform_phase_calibration() begin\n\n  uint8_t sequence_config = readReg(SYSTEM_SEQUENCE_CONFIG);\n  writeReg(SYSTEM_SEQUENCE_CONFIG, 0x02);\n  performSingleRefCalibration(0x0);\n  writeReg(SYSTEM_SEQUENCE_CONFIG, sequence_config);\n\n  // VL53L0X_perform_phase_calibration() end\n\n  return true;\n}\n\n// Get the VCSEL pulse period in PCLKs for the given period type.\n// based on VL53L0X_get_vcsel_pulse_period()\nuint8_t VL53L0X::getVcselPulsePeriod(vcselPeriodType type)\n{\n  if (type == VcselPeriodPreRange)\n  {\n    return decodeVcselPeriod(readReg(PRE_RANGE_CONFIG_VCSEL_PERIOD));\n  }\n  else if (type == VcselPeriodFinalRange)\n  {\n    return decodeVcselPeriod(readReg(FINAL_RANGE_CONFIG_VCSEL_PERIOD));\n  }\n  else { return 255; }\n}\n\n// Start continuous ranging measurements. If period_ms (optional) is 0 or not\n// given, continuous back-to-back mode is used (the sensor takes measurements as\n// often as possible); otherwise, continuous timed mode is used, with the given\n// inter-measurement period in milliseconds determining how often the sensor\n// takes a measurement.\n// based on VL53L0X_StartMeasurement()\nvoid VL53L0X::startContinuous(uint32_t period_ms)\n{\n  writeReg(0x80, 0x01);\n  writeReg(0xFF, 0x01);\n  writeReg(0x00, 0x00);\n  writeReg(0x91, stop_variable);\n  writeReg(0x00, 0x01);\n  writeReg(0xFF, 0x00);\n  writeReg(0x80, 0x00);\n\n  if (period_ms != 0)\n  {\n    // continuous timed mode\n\n    // VL53L0X_SetInterMeasurementPeriodMilliSeconds() begin\n\n    uint16_t osc_calibrate_val = readReg16Bit(OSC_CALIBRATE_VAL);\n\n    if (osc_calibrate_val != 0)\n    {\n      period_ms *= osc_calibrate_val;\n    }\n\n    writeReg32Bit(SYSTEM_INTERMEASUREMENT_PERIOD, period_ms);\n\n    // VL53L0X_SetInterMeasurementPeriodMilliSeconds() end\n\n    writeReg(SYSRANGE_START, 0x04); // VL53L0X_REG_SYSRANGE_MODE_TIMED\n  }\n  else\n  {\n    // continuous back-to-back mode\n    writeReg(SYSRANGE_START, 0x02); // VL53L0X_REG_SYSRANGE_MODE_BACKTOBACK\n  }\n}\n\n// Stop continuous measurements\n// based on VL53L0X_StopMeasurement()\nvoid VL53L0X::stopContinuous(void)\n{\n  writeReg(SYSRANGE_START, 0x01); // VL53L0X_REG_SYSRANGE_MODE_SINGLESHOT\n\n  writeReg(0xFF, 0x01);\n  writeReg(0x00, 0x00);\n  writeReg(0x91, 0x00);\n  writeReg(0x00, 0x01);\n  writeReg(0xFF, 0x00);\n}\n\n// Returns a range reading in millimeters when continuous mode is active\n// (readRangeSingleMillimeters() also calls this function after starting a\n// single-shot range measurement)\nuint16_t VL53L0X::readRangeContinuousMillimeters(void)\n{\n  startTimeout();\n  while ((readReg(RESULT_INTERRUPT_STATUS) & 0x07) == 0)\n  {\n    if (checkTimeoutExpired())\n    {\n      did_timeout = true;\n      return 65535;\n    }\n  }\n\n  // assumptions: Linearity Corrective Gain is 1000 (default);\n  // fractional ranging is not enabled\n  uint16_t range = readReg16Bit(RESULT_RANGE_STATUS + 10);\n\n  writeReg(SYSTEM_INTERRUPT_CLEAR, 0x01);\n\n  return range;\n}\n\n// Performs a single-shot range measurement and returns the reading in\n// millimeters\n// based on VL53L0X_PerformSingleRangingMeasurement()\nuint16_t VL53L0X::readRangeSingleMillimeters(void)\n{\n  writeReg(0x80, 0x01);\n  writeReg(0xFF, 0x01);\n  writeReg(0x00, 0x00);\n  writeReg(0x91, stop_variable);\n  writeReg(0x00, 0x01);\n  writeReg(0xFF, 0x00);\n  writeReg(0x80, 0x00);\n\n  writeReg(SYSRANGE_START, 0x01);\n\n  // \"Wait until start bit has been cleared\"\n  startTimeout();\n  while (readReg(SYSRANGE_START) & 0x01)\n  {\n    if (checkTimeoutExpired())\n    {\n      did_timeout = true;\n      return 65535;\n    }\n  }\n\n  return readRangeContinuousMillimeters();\n}\n\n// Did a timeout occur in one of the read functions since the last call to\n// timeoutOccurred()?\nbool VL53L0X::timeoutOccurred()\n{\n  bool tmp = did_timeout;\n  did_timeout = false;\n  return tmp;\n}\n\n// Private Methods /////////////////////////////////////////////////////////////\n\n// Get reference SPAD (single photon avalanche diode) count and type\n// based on VL53L0X_get_info_from_device(),\n// but only gets reference SPAD count and type\nbool VL53L0X::getSpadInfo(uint8_t * count, bool * type_is_aperture)\n{\n  uint8_t tmp;\n\n  writeReg(0x80, 0x01);\n  writeReg(0xFF, 0x01);\n  writeReg(0x00, 0x00);\n\n  writeReg(0xFF, 0x06);\n  writeReg(0x83, readReg(0x83) | 0x04);\n  writeReg(0xFF, 0x07);\n  writeReg(0x81, 0x01);\n\n  writeReg(0x80, 0x01);\n\n  writeReg(0x94, 0x6b);\n  writeReg(0x83, 0x00);\n  startTimeout();\n  while (readReg(0x83) == 0x00)\n  {\n    if (checkTimeoutExpired()) { return false; }\n  }\n  writeReg(0x83, 0x01);\n  tmp = readReg(0x92);\n\n  *count = tmp & 0x7f;\n  *type_is_aperture = (tmp >> 7) & 0x01;\n\n  writeReg(0x81, 0x00);\n  writeReg(0xFF, 0x06);\n  writeReg(0x83, readReg(0x83)  & ~0x04);\n  writeReg(0xFF, 0x01);\n  writeReg(0x00, 0x01);\n\n  writeReg(0xFF, 0x00);\n  writeReg(0x80, 0x00);\n\n  return true;\n}\n\n// Get sequence step enables\n// based on VL53L0X_GetSequenceStepEnables()\nvoid VL53L0X::getSequenceStepEnables(SequenceStepEnables * enables)\n{\n  uint8_t sequence_config = readReg(SYSTEM_SEQUENCE_CONFIG);\n\n  enables->tcc          = (sequence_config >> 4) & 0x1;\n  enables->dss          = (sequence_config >> 3) & 0x1;\n  enables->msrc         = (sequence_config >> 2) & 0x1;\n  enables->pre_range    = (sequence_config >> 6) & 0x1;\n  enables->final_range  = (sequence_config >> 7) & 0x1;\n}\n\n// Get sequence step timeouts\n// based on get_sequence_step_timeout(),\n// but gets all timeouts instead of just the requested one, and also stores\n// intermediate values\nvoid VL53L0X::getSequenceStepTimeouts(SequenceStepEnables const * enables, SequenceStepTimeouts * timeouts)\n{\n  timeouts->pre_range_vcsel_period_pclks = getVcselPulsePeriod(VcselPeriodPreRange);\n\n  timeouts->msrc_dss_tcc_mclks = readReg(MSRC_CONFIG_TIMEOUT_MACROP) + 1;\n  timeouts->msrc_dss_tcc_us =\n    timeoutMclksToMicroseconds(timeouts->msrc_dss_tcc_mclks,\n                               timeouts->pre_range_vcsel_period_pclks);\n\n  timeouts->pre_range_mclks =\n    decodeTimeout(readReg16Bit(PRE_RANGE_CONFIG_TIMEOUT_MACROP_HI));\n  timeouts->pre_range_us =\n    timeoutMclksToMicroseconds(timeouts->pre_range_mclks,\n                               timeouts->pre_range_vcsel_period_pclks);\n\n  timeouts->final_range_vcsel_period_pclks = getVcselPulsePeriod(VcselPeriodFinalRange);\n\n  timeouts->final_range_mclks =\n    decodeTimeout(readReg16Bit(FINAL_RANGE_CONFIG_TIMEOUT_MACROP_HI));\n\n  if (enables->pre_range)\n  {\n    timeouts->final_range_mclks -= timeouts->pre_range_mclks;\n  }\n\n  timeouts->final_range_us =\n    timeoutMclksToMicroseconds(timeouts->final_range_mclks,\n                               timeouts->final_range_vcsel_period_pclks);\n}\n\n// Decode sequence step timeout in MCLKs from register value\n// based on VL53L0X_decode_timeout()\n// Note: the original function returned a uint32_t, but the return value is\n// always stored in a uint16_t.\nuint16_t VL53L0X::decodeTimeout(uint16_t reg_val)\n{\n  // format: \"(LSByte * 2^MSByte) + 1\"\n  return (uint16_t)((reg_val & 0x00FF) <<\n         (uint16_t)((reg_val & 0xFF00) >> 8)) + 1;\n}\n\n// Encode sequence step timeout register value from timeout in MCLKs\n// based on VL53L0X_encode_timeout()\n// Note: the original function took a uint16_t, but the argument passed to it\n// is always a uint16_t.\nuint16_t VL53L0X::encodeTimeout(uint16_t timeout_mclks)\n{\n  // format: \"(LSByte * 2^MSByte) + 1\"\n\n  uint32_t ls_byte = 0;\n  uint16_t ms_byte = 0;\n\n  if (timeout_mclks > 0)\n  {\n    ls_byte = timeout_mclks - 1;\n\n    while ((ls_byte & 0xFFFFFF00) > 0)\n    {\n      ls_byte >>= 1;\n      ms_byte++;\n    }\n\n    return (ms_byte << 8) | (ls_byte & 0xFF);\n  }\n  else { return 0; }\n}\n\n// Convert sequence step timeout from MCLKs to microseconds with given VCSEL period in PCLKs\n// based on VL53L0X_calc_timeout_us()\nuint32_t VL53L0X::timeoutMclksToMicroseconds(uint16_t timeout_period_mclks, uint8_t vcsel_period_pclks)\n{\n  uint32_t macro_period_ns = calcMacroPeriod(vcsel_period_pclks);\n\n  return ((timeout_period_mclks * macro_period_ns) + (macro_period_ns / 2)) / 1000;\n}\n\n// Convert sequence step timeout from microseconds to MCLKs with given VCSEL period in PCLKs\n// based on VL53L0X_calc_timeout_mclks()\nuint32_t VL53L0X::timeoutMicrosecondsToMclks(uint32_t timeout_period_us, uint8_t vcsel_period_pclks)\n{\n  uint32_t macro_period_ns = calcMacroPeriod(vcsel_period_pclks);\n\n  return (((timeout_period_us * 1000) + (macro_period_ns / 2)) / macro_period_ns);\n}\n\n\n// based on VL53L0X_perform_single_ref_calibration()\nbool VL53L0X::performSingleRefCalibration(uint8_t vhv_init_byte)\n{\n  writeReg(SYSRANGE_START, 0x01 | vhv_init_byte); // VL53L0X_REG_SYSRANGE_MODE_START_STOP\n\n  startTimeout();\n  while ((readReg(RESULT_INTERRUPT_STATUS) & 0x07) == 0)\n  {\n    if (checkTimeoutExpired()) { return false; }\n  }\n\n  writeReg(SYSTEM_INTERRUPT_CLEAR, 0x01);\n\n  writeReg(SYSRANGE_START, 0x00);\n\n  return true;\n}\n"},{"name":"VL53L0Xwrapper.cpp","type":"source","group":"other","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"\n/* #include \"Wire.h\"\n#include \"twi.h\"\n#include \"I2Cdev.h\"\n#include \"MPU6050.h\" */\n\n#include \"Wire.h\"\n#include \"VL53L0X.h\"\n\nVL53L0X sensor;\n\nextern \"C\" void VL53L0X_Init(void)\n{\n  Wire.begin();\n  sensor.init();\n  //sensor.setTimeout(500);\n\n  // Start continuous back-to-back mode (take readings as\n  // fast as possible).  To use continuous timed mode\n  // instead, provide a desired inter-measurement period in\n  // ms (e.g. sensor.startContinuous(100)).\n  sensor.startContinuous();\n  \n}\nextern \"C\" void VL53L0X_Read(int* pfData)\n{\n\t// set default sensor value to zero if out of range (or any desired value)\n\tint mm=0;\n\tmm=sensor.readRangeContinuousMillimeters();\n\tif(mm>8000){\n\t\tmm=0;\n\t}\n\t\n    pfData[0]=mm;\n}\n\n"},{"name":"Wire.cpp","type":"source","group":"legacy","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/../../../Documents/MATLAB/SupportPackages/R2025b/3P.instrset/arduinoide.instrset/aCLI/data/packages/arduino/hardware/avr/1.8.3/libraries/Wire/src","tag":"","groupDisplay":"Other files","code":"/*\n  TwoWire.cpp - TWI/I2C library for Wiring & Arduino\n  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n \n  Modified 2012 by Todd Krein (todd@krein.org) to implement repeated starts\n  Modified 2017 by Chuck Todd (ctodd@cableone.net) to correct Unconfigured Slave Mode reboot\n  Modified 2020 by Greyson Christoforo (grey@christoforo.net) to implement timeouts\n*/\n\nextern \"C\" {\n  #include <stdlib.h>\n  #include <string.h>\n  #include <inttypes.h>\n  #include \"utility/twi.h\"\n}\n\n#include \"Wire.h\"\n\n// Initialize Class Variables //////////////////////////////////////////////////\n\nuint8_t TwoWire::rxBuffer[BUFFER_LENGTH];\nuint8_t TwoWire::rxBufferIndex = 0;\nuint8_t TwoWire::rxBufferLength = 0;\n\nuint8_t TwoWire::txAddress = 0;\nuint8_t TwoWire::txBuffer[BUFFER_LENGTH];\nuint8_t TwoWire::txBufferIndex = 0;\nuint8_t TwoWire::txBufferLength = 0;\n\nuint8_t TwoWire::transmitting = 0;\nvoid (*TwoWire::user_onRequest)(void);\nvoid (*TwoWire::user_onReceive)(int);\n\n// Constructors ////////////////////////////////////////////////////////////////\n\nTwoWire::TwoWire()\n{\n}\n\n// Public Methods //////////////////////////////////////////////////////////////\n\nvoid TwoWire::begin(void)\n{\n  rxBufferIndex = 0;\n  rxBufferLength = 0;\n\n  txBufferIndex = 0;\n  txBufferLength = 0;\n\n  twi_init();\n  twi_attachSlaveTxEvent(onRequestService); // default callback must exist\n  twi_attachSlaveRxEvent(onReceiveService); // default callback must exist\n}\n\nvoid TwoWire::begin(uint8_t address)\n{\n  begin();\n  twi_setAddress(address);\n}\n\nvoid TwoWire::begin(int address)\n{\n  begin((uint8_t)address);\n}\n\nvoid TwoWire::end(void)\n{\n  twi_disable();\n}\n\nvoid TwoWire::setClock(uint32_t clock)\n{\n  twi_setFrequency(clock);\n}\n\n/***\n * Sets the TWI timeout.\n *\n * This limits the maximum time to wait for the TWI hardware. If more time passes, the bus is assumed\n * to have locked up (e.g. due to noise-induced glitches or faulty slaves) and the transaction is aborted.\n * Optionally, the TWI hardware is also reset, which can be required to allow subsequent transactions to\n * succeed in some cases (in particular when noise has made the TWI hardware think there is a second\n * master that has claimed the bus).\n *\n * When a timeout is triggered, a flag is set that can be queried with `getWireTimeoutFlag()` and is cleared\n * when `clearWireTimeoutFlag()` or `setWireTimeoutUs()` is called.\n *\n * Note that this timeout can also trigger while waiting for clock stretching or waiting for a second master\n * to complete its transaction. So make sure to adapt the timeout to accomodate for those cases if needed.\n * A typical timeout would be 25ms (which is the maximum clock stretching allowed by the SMBus protocol),\n * but (much) shorter values will usually also work.\n *\n * In the future, a timeout will be enabled by default, so if you require the timeout to be disabled, it is\n * recommended you disable it by default using `setWireTimeoutUs(0)`, even though that is currently\n * the default.\n *\n * @param timeout a timeout value in microseconds, if zero then timeout checking is disabled\n * @param reset_with_timeout if true then TWI interface will be automatically reset on timeout\n *                           if false then TWI interface will not be reset on timeout\n\n */\nvoid TwoWire::setWireTimeout(uint32_t timeout, bool reset_with_timeout){\n  twi_setTimeoutInMicros(timeout, reset_with_timeout);\n}\n\n/***\n * Returns the TWI timeout flag.\n *\n * @return true if timeout has occured since the flag was last cleared.\n */\nbool TwoWire::getWireTimeoutFlag(void){\n  return(twi_manageTimeoutFlag(false));\n}\n\n/***\n * Clears the TWI timeout flag.\n */\nvoid TwoWire::clearWireTimeoutFlag(void){\n  twi_manageTimeoutFlag(true);\n}\n\nuint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity, uint32_t iaddress, uint8_t isize, uint8_t sendStop)\n{\n  if (isize > 0) {\n  // send internal address; this mode allows sending a repeated start to access\n  // some devices' internal registers. This function is executed by the hardware\n  // TWI module on other processors (for example Due's TWI_IADR and TWI_MMR registers)\n\n  beginTransmission(address);\n\n  // the maximum size of internal address is 3 bytes\n  if (isize > 3){\n    isize = 3;\n  }\n\n  // write internal register address - most significant byte first\n  while (isize-- > 0)\n    write((uint8_t)(iaddress >> (isize*8)));\n  endTransmission(false);\n  }\n\n  // clamp to buffer length\n  if(quantity > BUFFER_LENGTH){\n    quantity = BUFFER_LENGTH;\n  }\n  // perform blocking read into buffer\n  uint8_t read = twi_readFrom(address, rxBuffer, quantity, sendStop);\n  // set rx buffer iterator vars\n  rxBufferIndex = 0;\n  rxBufferLength = read;\n\n  return read;\n}\n\nuint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity, uint8_t sendStop) {\n\treturn requestFrom((uint8_t)address, (uint8_t)quantity, (uint32_t)0, (uint8_t)0, (uint8_t)sendStop);\n}\n\nuint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity)\n{\n  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)true);\n}\n\nuint8_t TwoWire::requestFrom(int address, int quantity)\n{\n  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)true);\n}\n\nuint8_t TwoWire::requestFrom(int address, int quantity, int sendStop)\n{\n  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)sendStop);\n}\n\nvoid TwoWire::beginTransmission(uint8_t address)\n{\n  // indicate that we are transmitting\n  transmitting = 1;\n  // set address of targeted slave\n  txAddress = address;\n  // reset tx buffer iterator vars\n  txBufferIndex = 0;\n  txBufferLength = 0;\n}\n\nvoid TwoWire::beginTransmission(int address)\n{\n  beginTransmission((uint8_t)address);\n}\n\n//\n//\tOriginally, 'endTransmission' was an f(void) function.\n//\tIt has been modified to take one parameter indicating\n//\twhether or not a STOP should be performed on the bus.\n//\tCalling endTransmission(false) allows a sketch to \n//\tperform a repeated start. \n//\n//\tWARNING: Nothing in the library keeps track of whether\n//\tthe bus tenure has been properly ended with a STOP. It\n//\tis very possible to leave the bus in a hung state if\n//\tno call to endTransmission(true) is made. Some I2C\n//\tdevices will behave oddly if they do not see a STOP.\n//\nuint8_t TwoWire::endTransmission(uint8_t sendStop)\n{\n  // transmit buffer (blocking)\n  uint8_t ret = twi_writeTo(txAddress, txBuffer, txBufferLength, 1, sendStop);\n  // reset tx buffer iterator vars\n  txBufferIndex = 0;\n  txBufferLength = 0;\n  // indicate that we are done transmitting\n  transmitting = 0;\n  return ret;\n}\n\n//\tThis provides backwards compatibility with the original\n//\tdefinition, and expected behaviour, of endTransmission\n//\nuint8_t TwoWire::endTransmission(void)\n{\n  return endTransmission(true);\n}\n\n// must be called in:\n// slave tx event callback\n// or after beginTransmission(address)\nsize_t TwoWire::write(uint8_t data)\n{\n  if(transmitting){\n  // in master transmitter mode\n    // don't bother if buffer is full\n    if(txBufferLength >= BUFFER_LENGTH){\n      setWriteError();\n      return 0;\n    }\n    // put byte in tx buffer\n    txBuffer[txBufferIndex] = data;\n    ++txBufferIndex;\n    // update amount in buffer   \n    txBufferLength = txBufferIndex;\n  }else{\n  // in slave send mode\n    // reply to master\n    twi_transmit(&data, 1);\n  }\n  return 1;\n}\n\n// must be called in:\n// slave tx event callback\n// or after beginTransmission(address)\nsize_t TwoWire::write(const uint8_t *data, size_t quantity)\n{\n  if(transmitting){\n  // in master transmitter mode\n    for(size_t i = 0; i < quantity; ++i){\n      write(data[i]);\n    }\n  }else{\n  // in slave send mode\n    // reply to master\n    twi_transmit(data, quantity);\n  }\n  return quantity;\n}\n\n// must be called in:\n// slave rx event callback\n// or after requestFrom(address, numBytes)\nint TwoWire::available(void)\n{\n  return rxBufferLength - rxBufferIndex;\n}\n\n// must be called in:\n// slave rx event callback\n// or after requestFrom(address, numBytes)\nint TwoWire::read(void)\n{\n  int value = -1;\n  \n  // get each successive byte on each call\n  if(rxBufferIndex < rxBufferLength){\n    value = rxBuffer[rxBufferIndex];\n    ++rxBufferIndex;\n  }\n\n  return value;\n}\n\n// must be called in:\n// slave rx event callback\n// or after requestFrom(address, numBytes)\nint TwoWire::peek(void)\n{\n  int value = -1;\n  \n  if(rxBufferIndex < rxBufferLength){\n    value = rxBuffer[rxBufferIndex];\n  }\n\n  return value;\n}\n\nvoid TwoWire::flush(void)\n{\n  // XXX: to be implemented.\n}\n\n// behind the scenes function that is called when data is received\nvoid TwoWire::onReceiveService(uint8_t* inBytes, int numBytes)\n{\n  // don't bother if user hasn't registered a callback\n  if(!user_onReceive){\n    return;\n  }\n  // don't bother if rx buffer is in use by a master requestFrom() op\n  // i know this drops data, but it allows for slight stupidity\n  // meaning, they may not have read all the master requestFrom() data yet\n  if(rxBufferIndex < rxBufferLength){\n    return;\n  }\n  // copy twi rx buffer into local read buffer\n  // this enables new reads to happen in parallel\n  for(uint8_t i = 0; i < numBytes; ++i){\n    rxBuffer[i] = inBytes[i];    \n  }\n  // set rx iterator vars\n  rxBufferIndex = 0;\n  rxBufferLength = numBytes;\n  // alert user program\n  user_onReceive(numBytes);\n}\n\n// behind the scenes function that is called when data is requested\nvoid TwoWire::onRequestService(void)\n{\n  // don't bother if user hasn't registered a callback\n  if(!user_onRequest){\n    return;\n  }\n  // reset tx buffer iterator vars\n  // !!! this will kill any pending pre-master sendTo() activity\n  txBufferIndex = 0;\n  txBufferLength = 0;\n  // alert user program\n  user_onRequest();\n}\n\n// sets function called on slave write\nvoid TwoWire::onReceive( void (*function)(int) )\n{\n  user_onReceive = function;\n}\n\n// sets function called on slave read\nvoid TwoWire::onRequest( void (*function)(void) )\n{\n  user_onRequest = function;\n}\n\n// Preinstantiate Objects //////////////////////////////////////////////////////\n\nTwoWire Wire = TwoWire();\n\n"},{"name":"arduinoAVRScheduler.cpp","type":"source","group":"legacy","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/../../../Documents/MATLAB/SupportPackages/R2025b/toolbox/target/supportpackages/arduinotarget/scheduler/src","tag":"","groupDisplay":"Other files","code":"/* Arduino AVR Bareboard scheduler\n *\n * Copyright 2013-2015 The MathWorks, Inc.\n */\n\n#include \"Arduino.h\"\n#include \"arduinoAVRScheduler.h\"\n\nextern volatile int IsrOverrun;\nunsigned long oldtime = 0L;\nunsigned long actualtime;\n\n\n#if (defined(MW_SCHEDULERCOUNTER) &&  (MW_SCHEDULERCOUNTER > 1))\n   #if (MW_SCHEDULERCOUNTER >= 65536)\n      volatile uint32_t scheduler_counter = 0;\n    #elif (MW_SCHEDULERCOUNTER >= 256)\n      volatile uint16_t scheduler_counter = 0;\n    #else\n      volatile uint8_t scheduler_counter = 0;\n    #endif\n#endif\n                                  \n/*\n * Call the rt_Onestep function when the timer interrupt hits\n *\n */\n#ifndef _MW_ARDUINO_LOOP_\nISR(INTERRUPT_VECTOR)\n{\n    RESET_TIMER;\n    \n    #if (defined(MW_SCHEDULERCOUNTER) && (MW_SCHEDULERCOUNTER > 1))\n      if ((++scheduler_counter) == MW_SCHEDULERCOUNTER) {\n         scheduler_counter = 0;\n    #endif\n\n    #ifdef _RTT_OVERRUN_DIGITAL_PIN_\n        if (IsrOverrun == 1)\n        {\n          // Overrun detected\n          digitalWrite(_RTT_OVERRUN_DIGITAL_PIN_, HIGH);\n        }\n    #endif\n      rt_OneStep();\n         \n    #if (defined(MW_SCHEDULERCOUNTER) && (MW_SCHEDULERCOUNTER > 1))\n      }\n    #endif\n}\n#endif    \n\nvoid configureArduinoAVRTimer(void)\n{\n#ifndef _MW_ARDUINO_LOOP_\n  // Sets up the timer overflow interrupt.\n  RESET_TIMER;\n\n  // Initially disable the overflow interrupt (before configuration).\n  DISABLE_SCHEDULER_INT();\n\n  // Set the timer to normal mode.\n  TIMER_NORMAL_MODE;\n\n  // Set the prescaler.\n  SETUP_PRESCALER;\n\n  // Enable the overflow interrupt.\n  ENABLE_SCHEDULER_INT();    \n#endif  \n}\n\nboolean disable_rt_OneStep(void)\n{\n    boolean t_return = 0U;\n#ifndef _MW_ARDUINO_LOOP_\n    t_return = GET_SCHEDULER_INT_EN_STATUS();\n  // Disable the overflow interrupt for XCP External Mode\n  DISABLE_SCHEDULER_INT();  \n#endif \n  return t_return;\n}\n\nvoid enable_rt_OneStep(void)\n{\n#ifndef _MW_ARDUINO_LOOP_\n  // Enable the overflow interrupt\n  ENABLE_SCHEDULER_INT();  \n#endif \n}\n\nboolean MW_Arduino_Loop(void)\n{\n    boolean ret = 0;\n\n#ifdef _MW_ARDUINO_LOOP_\n    unsigned long overruntime;\n#if (defined(MW_ARDUINO_MICROS))\n    actualtime = micros();\n#else\n    actualtime = millis();\n#endif\n  \n    if ((unsigned long) (actualtime - oldtime) >= MW_ARDUINO_STEP_SIZE)\n    {\n        oldtime = actualtime;\n        \n#ifdef _RTT_OVERRUN_DIGITAL_PIN_\n        if (IsrOverrun == 1)\n        {\n            // Overrun detected\n            digitalWrite(_RTT_OVERRUN_DIGITAL_PIN_, HIGH);\n        }\n#endif\n        rt_OneStep();\n            #if (defined(_MW_ARDUINO_LOOP_))\n                #if (defined(MW_ARDUINO_MICROS))\n                        overruntime = micros();\n                #else\n                        overruntime = millis();\n                #endif\n                if ((unsigned long) (overruntime - oldtime) >= MW_ARDUINO_STEP_SIZE)   \n                  IsrOverrun = 1;\n                else\n                  IsrOverrun = 0;\n            #endif\n}\n#endif\n\n    ret = 1;\n    return ret;\n}\n\n"},{"name":"digitalio_arduino.cpp","type":"source","group":"other","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"#include <Arduino.h>\n#include \"digitalio_arduino.h\"\n\n// Digital I/O initialization\nextern \"C\" void digitalIOSetup(uint8_T pin, boolean_T mode) \n{   \n    // mode = 0: Input\n    // mode = 1: Output\n    if (mode) {\n        pinMode(pin, OUTPUT);\n    }\n    else {\n        pinMode(pin, INPUT);\n    }\n}\n\n// Write a logic value to pin\nextern \"C\" void writeDigitalPin(uint8_T pin, boolean_T val)\n{\n    digitalWrite(pin, val);\n}\n\n// Write a logic value to pin\nextern \"C\" void writeDigitalAnalogPin(uint8_T pin, boolean_T val)\n{\n    digitalWrite(pin, val);\n}\n\n// Read logical state of a digital pin\nextern \"C\" boolean_T readDigitalPin(uint8_T pin)\n{\n    return ((boolean_T)digitalRead(pin));\n}\n\n\n// [EOF]"},{"name":"encoder_arduino.cpp","type":"source","group":"legacy","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/../../../MATLAB Add-Ons/Collections/Rensselaer Arduino Support Package Library (RASPLib)/RASPlib/src","tag":"","groupDisplay":"Other files","code":"#include <Arduino.h>\n#include \"encoder_arduino.h\"\n\ntypedef struct\n{\n    int pinA;\n    int pinB;\n    long pos;\n    int del;\n\tint Aprev;  //1221\n\tint Bprev;  //1221\n} Encoder;\n//volatile Encoder Enc[4] = {{0,0,0,0}, {0,0,0,0}, {0,0,0,0},{0,0,0,0}};\nvolatile Encoder Enc[5] = {{0,0,0,0,0,0}, {0,0,0,0,0,0}, {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}};  //1221\n\n// Auxiliary function to handle encoder attachment\nstatic int getIntNum(int pin)\n{\n    // Returns the interrupt number for a given interrupt pin\n    // See http://arduino.cc/it/Reference/AttachInterrupt\n    switch(pin) {\n        case 2:\n            return 0;\n        case 3:\n            return 1;\n        case 21:\n            return 2;\n        case 20:\n            return 3;\n        case 19:\n            return 4;\n        case 18:\n            return 5;\n\t\tcase 6:        // direct access to interrupt 6\n            return 6;\n        case 7:\n            return 7;  // direct access to interrupt 7\n        default:\n            return -1;\n    }\n}\n\n// Auxiliary debouncing function\nstatic void debounce(int del)\n{\n    for (int k = 0; k < del; k++) {\n        // can't use delay in the ISR so need to waste some time\n        // perfoming operations, this uses roughly 0.1ms on uno\n        k = k +0.0 +0.0 -0.0 +3.0 -3.0;\n    }\n}\n\n// Interrupt Service Routine: change on pin A for Encoder 0\nstatic void irsPinAEn0(void)\n{\n    // Read pin B right away\n    //int drB = digitalRead(Enc[0].pinB);int drA = digitalRead(Enc[0].pinA);\n    int PINE_REG=PINE;  // read entire register once\n    int drB = bool(PINE_REG&(1<<5));int drA = bool(PINE_REG&(1<<4));  // PE4 2 PE5 3\n\t\n    // Possibly wait before reading pin A, then read it\n    //debounce(Enc[0].del);\n    \n    // this updates the counter\n    if (drA == HIGH)\n    {\n        // low->high on A?\n        if (drB == LOW) {  // check pin B\n            Enc[0].pos++;  // going clockwise: increment\n        }\n        else {\n            Enc[0].pos--;  // going counterclockwise: decrement\n        }\n        \n    }\n    else {\n        // must be high to low on A\n        if (drB == HIGH) { // check pin B\n            Enc[0].pos++;  // going clockwise: increment\n        }\n        else {\n            Enc[0].pos--;  // going counterclockwise: decrement\n        }\n    } // end counter update\n} // end ISR pin A Encoder 0\n\n\n\n// Interrupt Service Routine: change on pin B for Encoder 0\nstatic void isrPinBEn0(void)\n{\n    // read pin A right away\n    //int drA = digitalRead(Enc[0].pinA);int drB = digitalRead(Enc[0].pinB);\n    int PINE_REG=PINE;  // read entire register once\n    int drA = bool(PINE_REG&(1<<4));int drB = bool(PINE_REG&(1<<5)); // PE4 2 PE5 3\n    // possibly wait before reading pin B, then read it\n    //debounce(Enc[0].del);\n\n    // this updates the counter\n    if (drB == HIGH) {   // low->high on B?\n        if (drA == HIGH) { // check pin A\n            Enc[0].pos++;  // going clockwise: increment\n        } else {\n            Enc[0].pos--;  // going counterclockwise: decrement\n        }\n    } else {                       // must be high to low on B\n        if (drA == LOW) {  // check pin A\n            Enc[0].pos++;  // going clockwise: increment\n        } else {\n            Enc[0].pos--;  // going counterclockwise: decrement\n        }\n    } // end counter update\n} // end ISR pin B Encoder 0\n\n// Interrupt Service Routine: change on pin A for Encoder 1\nstatic void irsPinAEn1(void)\n{\n    // read pin B right away\n    // int drB = digitalRead(Enc[1].pinB);int drA = digitalRead(Enc[1].pinA); \n    // possibly wait before reading pin A, then read it\n    //debounce(Enc[1].del);\n    int PIND_REG=PIND;  // read entire register once\n\tint drB = bool(PIND_REG&(1<<3));int drA = bool(PIND_REG&(1<<2));  // PD3 18, PD2 19\n    \n    // this updates the counter\n    if (drA == HIGH) {   // low->high on A?\n        if (drB == LOW) {  // check pin B\n            Enc[1].pos++;  // going clockwise: increment\n        } else {\n            Enc[1].pos--;  // going counterclockwise: decrement\n        }\n    } else { // must be high to low on A\n        if (drB == HIGH) { // check pin B\n            Enc[1].pos++;  // going clockwise: increment\n        } else {\n            Enc[1].pos--;  // going counterclockwise: decrement\n        }\n    } // end counter update\n    \n} // end ISR pin A Encoder 1\n\n\n// Interrupt Service Routine: change on pin B for Encoder 1\nstatic void isrPinBEn1(void)\n{\n    // read pin A right away\n    // int drA = digitalRead(Enc[1].pinA);int drB = digitalRead(Enc[1].pinB);\n    // possibly wait before reading pin B, then read it\n    //debounce(Enc[1].del);\n    int PIND_REG=PIND;  // read entire register once\n    int drA = bool(PIND_REG&(1<<2));int drB = bool(PIND_REG&(1<<3)); // PD3 18, PD2 19\n    \n    // this updates the counter\n    if (drB == HIGH) {   // low->high on B?\n        if (drA == HIGH) { // check pin A\n            Enc[1].pos++;  // going clockwise: increment\n        } else {\n            Enc[1].pos--;  // going counterclockwise: decrement\n        }\n    } else { // must be high to low on B\n        if (drA == LOW) {  // check pin A\n            Enc[1].pos++;  // going clockwise: increment\n        } else {\n            Enc[1].pos--;  // going counterclockwise: decrement\n        }\n    } // end counter update\n    \n} // end ISR pin B Encoder 1\n\n\n// Interrupt Service Routine: change on pin A for Encoder 2\nstatic void irsPinAEn2(void)\n{\n  /* read pin B right away                                   */\n  //int drB = digitalRead(Enc[0].pinB);  \n  int PDE1=PINE;\n  int drB = (PDE1 & 0x80)>>PINE7;//PINE7; (have to read whole port at once, then AND, then bitshift)\n  int drA = (PDE1 & 0x40)>>PINE6;//PINE6; (have to read whole port at once, then AND, then bitshift)\n   \n  /* possibly wait before reading pin A, then read it        */\n  //debounce(Enc[2].del);\n   \n    // this updates the counter\n    if (drA == HIGH) {   // low->high on A?\n        if (drB == LOW) {  // check pin B\n            Enc[2].pos++;  // going clockwise: increment\n        } else {\n            Enc[2].pos--;  // going counterclockwise: decrement\n        }\n    }\n    else { // must be high to low on A\n        if (drB == HIGH) { // check pin B\n            Enc[2].pos++;  // going clockwise: increment\n        } else {\n            Enc[2].pos--;  // going counterclockwise: decrement\n        }\n    } // end counter update\n    \n} // end ISR pin A Encoder 2\n\n\n// Interrupt Service Routine: change on pin B for Encoder 2\nstatic void isrPinBEn2(void)\n{\n  /* read pin A right away                                   */\n  //int drA = digitalRead(Enc[0].pinA);\n  int PDE1=PINE;\n  int drA = (PDE1 & 0x40)>>PINE6;//PINE6; (have to read whole port at once, then AND, then bitshift)\n  int drB = (PDE1 & 0x80)>>PINE7;//PINE7; (have to read whole port at once, then AND, then bitshift) \n  /* possibly wait before reading pin B, then read it        */\n  //debounce(Enc[2].del);\n  //int drB = digitalRead(Enc[0].pinB);\n    \n    // this updates the counter\n    if (drB == HIGH) {   // low->high on B?\n        if (drA == HIGH) { // check pin A\n            Enc[2].pos++;  // going clockwise: increment\n        } else {\n            Enc[2].pos--;  // going counterclockwise: decrement\n        }\n    }\n    else { // must be high to low on B\n        if (drA == LOW) {  // check pin A\n            Enc[2].pos++;  // going clockwise: increment\n        } else {\n            Enc[2].pos--;  // going counterclockwise: decrement\n        }\n    } // end counter update\n    \n} // end ISR pin B Encoder 2\n\n\n// ISR routines for PCINT0\n// Encoder using PCINT vector will be ENC[4]\n/* Interrupt Service Routine: change on pin A & B */\nISR( PCINT0_vect )\n{\n  /* read pin A & B right away                                   */\n    int PINB_REG=PINB;  // read entire register once\n\tint drB = bool(PINB_REG&(1<<5));int drA = bool(PINB_REG&(1<<6));  // PB5, PB6 --> 11, 12\n\n\t\n  // Find out which pin changed:\n  if(drB==Enc[4].Bprev){\n\t  // A must have changed\n\t  Enc[4].Aprev=drA;\n\t  // this updates the counter if A Changed:\n    if (drA == HIGH) {   // low->high on A?\n        if (drB == LOW) {  // check pin B\n            Enc[4].pos++;  // going clockwise: increment\n        } else {\n            Enc[4].pos--;  // going counterclockwise: decrement\n        }\n    }\n    else { // must be high to low on A\n        if (drB == HIGH) { // check pin B\n            Enc[4].pos++;  // going clockwise: increment\n        } else {\n            Enc[4].pos--;  // going counterclockwise: decrement\n        }\n    } // end counter update\n\t\n  } else {\n\t  // B must have changed\n\t  Enc[4].Bprev=drB;\n\t  // this updates the counter if B changed:\n    if (drB == HIGH) {   // low->high on B?\n        if (drA == HIGH) { // check pin A\n            Enc[4].pos++;  // going clockwise: increment\n        } else {\n            Enc[4].pos--;  // going counterclockwise: decrement\n        }\n    }\n    else { // must be high to low on B\n        if (drA == LOW) {  // check pin A\n            Enc[4].pos++;  // going clockwise: increment\n        } else {\n            Enc[4].pos--;  // going counterclockwise: decrement\n        }\n    } // end counter update\n\t  \n  }\n\t\n  /* this updates the counter                                */\n  if (drA == HIGH) {   /* low->high on A? */\n      \n    if (drB == LOW) {  /* check pin B */\n  \tEnc[4].pos++;  /* going clockwise: increment         */\n    } else {\n  \tEnc[4].pos--;  /* going counterclockwise: decrement  */\n    }\n    \n  } else {                       /* must be high to low on A */\n  \n    if (drB == HIGH) { /* check pin B */\n  \tEnc[4].pos++;  /* going clockwise: increment         */\n    } else {\n  \tEnc[4].pos--;  /* going counterclockwise: decrement  */\n    }\n    \n  } /* end counter update                                    */\n\n} /* end ISR pin A Encoder 3               \n\n// ISR routines for PCINT\n// Encoder using PCINT vector will be ENC[3]\n/* Interrupt Service Routine: change on pin A for Encoder 1  */\nISR( PCINT1_vect )\n{\n\n  /* read pin B right away                                   */\n  //int drB = digitalRead(Enc[3].pinB);  int drA = digitalRead(Enc[3].pinA);\n  int drB = bool(PINK&(1<<0));int drA = bool(PINJ&(1<<0));  // PK0 A8, PJ0 D15\n  /* possibly wait before reading pin A, then read it        */\n  //debounce(Enc[3].del);\n\n\n  /* this updates the counter                                */\n  if (drA == HIGH) {   /* low->high on A? */\n      \n    if (drB == LOW) {  /* check pin B */\n  \tEnc[3].pos++;  /* going clockwise: increment         */\n    } else {\n  \tEnc[3].pos--;  /* going counterclockwise: decrement  */\n    }\n    \n  } else {                       /* must be high to low on A */\n  \n    if (drB == HIGH) { /* check pin B */\n  \tEnc[3].pos++;  /* going clockwise: increment         */\n    } else {\n  \tEnc[3].pos--;  /* going counterclockwise: decrement  */\n    }\n    \n  } /* end counter update                                    */\n\n} /* end ISR pin A Encoder 3                                */\n\n\n\n/* Interrupt Service Routine: change on pin B for Encoder 3  */\nISR( PCINT2_vect )\n{ \n\n  /* read pin A right away                                   */\n  //int drA = digitalRead(Enc[3].pinA);  int drB = digitalRead(Enc[3].pinB);\n  int drA = bool(PINJ&(1<<0)); int drB = bool(PINK&(1<<0)); // PK0 A8, PJ0 D15\n  /* possibly wait before reading pin B, then read it        */\n  //debounce(Enc[3].del);\n\n\n  /* this updates the counter                                */\n  if (drB == HIGH) {   /* low->high on B? */\n  \n    if (drA == HIGH) { /* check pin A */\n  \tEnc[3].pos++;  /* going clockwise: increment         */\n    } else {\n  \tEnc[3].pos--;  /* going counterclockwise: decrement  */\n    }\n  \n  } else {                       /* must be high to low on B */\n  \n    if (drA == LOW) {  /* check pin A */\n  \tEnc[3].pos++;  /* going clockwise: increment         */\n    } else {\n  \tEnc[3].pos--;  /* going counterclockwise: decrement  */\n    }\n    \n  } /* end counter update */\n\n} /* end ISR pin B Encoder 3                                */\n\n// Initialization function called by Encoder System object\nextern \"C\" void enc_init(int enc, int pinA, int pinB)\n{\n    // enc is the encoder number and it can be 0,1 or 2\n    // if other encoder blocks are present in the model\n    // up to a maximum of 3, they need to refer to a\n    // different encoder number\n    \n    // store pinA and pinB in global encoder structure Enc\n    // they will be needed later by the interrupt routine\n    // that will not be able to access s-function parameters\n    \n    Enc[enc].pinA=pinA;      // set pin A\n    Enc[enc].pinB=pinB;      // set pin B\n    \n    // set encoder pins as inputs\n    pinMode(Enc[enc].pinA, INPUT);\n    pinMode(Enc[enc].pinB, INPUT);\n    \n    // turn on pullup resistors\n    digitalWrite(Enc[enc].pinA, HIGH);\n    digitalWrite(Enc[enc].pinB, HIGH);\n    \n    // attach interrupts\n    switch(enc) {\n        case 0:\n            attachInterrupt(getIntNum(Enc[0].pinA), irsPinAEn0, CHANGE);\n            attachInterrupt(getIntNum(Enc[0].pinB), isrPinBEn0, CHANGE);\n            break;\n        case 1:\n            attachInterrupt(getIntNum(Enc[1].pinA), irsPinAEn1, CHANGE);\n            attachInterrupt(getIntNum(Enc[1].pinB), isrPinBEn1, CHANGE);\n            break;\n        case 2:\n            attachInterrupt(getIntNum(Enc[2].pinA), irsPinAEn2, CHANGE);\n            attachInterrupt(getIntNum(Enc[2].pinB), isrPinBEn2, CHANGE);\n            break;\n\t\tcase 3:\n\t\t\t// attach interrupts for enc[3]:\n\t\t\t// make analog pin A8 and RX3 (D13) into pin change interrupts:\n\t\t\tPCICR |= (1 << PCIE2);     // enable PCINT 2\n\t\t\tPCICR |= (1 << PCIE1);     // enable PCINT 1 \n\t\t\tPCMSK2 |= (1 << PCINT16);  // Analog 8 as input\n\t\t\tPCMSK1 |= (1 << PCINT9);  // RX3 D15 as input \n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t// attach interrupts for enc[4]:\n\t\t\t// ping 11 and 12 into pin change interrupts:\n\t\t\tPCICR |= (1 << PCIE0);     // enable PCINT0  (pins 11 and 12 --> PCINT5, PCINT6 --> PCINT0 vec)\n\t\t\tPCMSK0 |= (1 << PCINT5);  // Pin 11\n\t\t\tPCMSK0 |= (1 << PCINT6);  // Pin 12\n\t\t\tbreak;\n\t\t\t\n    }\n}\n\n// Output function called by Encoder System object\nextern \"C\" long enc_output(long enc)\n{\n    return (long)Enc[enc].pos;\n}\n// [EOF]\n\n"},{"name":"encoder_arduino_uno_nano.cpp","type":"source","group":"other","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"#include <Arduino.h>\n#include \"encoder_arduino.h\"\n\ntypedef struct\n{\n    int pinA;\n    int pinB;\n    long pos;\n    int del;\n\tint Aprev;  //1221\n\tint Bprev;  //1221\n} Encoder;\n//volatile Encoder Enc[4] = {{0,0,0,0}, {0,0,0,0}, {0,0,0,0},{0,0,0,0}};\nvolatile Encoder Enc[5] = {{0,0,0,0,0,0}, {0,0,0,0,0,0}, {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}};  //1221\n\n// Auxiliary function to handle encoder attachment\nstatic int getIntNum(int pin)\n{\n    // Returns the interrupt number for a given interrupt pin\n    // See http://arduino.cc/it/Reference/AttachInterrupt\n    switch(pin) {\n        case 2:\n            return 0;\n        case 3:\n            return 1;\n        case 21:\n            return 2;\n        case 20:\n            return 3;\n        case 19:\n            return 4;\n        case 18:\n            return 5;\n\t\tcase 6:        // direct access to interrupt 6\n            return 6;\n        case 7:\n            return 7;  // direct access to interrupt 7\n        default:\n            return -1;\n    }\n}\n\n// Auxiliary debouncing function\nstatic void debounce(int del)\n{\n    for (int k = 0; k < del; k++) {\n        // can't use delay in the ISR so need to waste some time\n        // perfoming operations, this uses roughly 0.1ms on uno\n        k = k +0.0 +0.0 -0.0 +3.0 -3.0;\n    }\n}\n\n// Interrupt Service Routine: change on pin A for Encoder 0\nstatic void irsPinAEn0(void)\n{\n    // Read pin B right away\n    //int drB = digitalRead(Enc[0].pinB);int drA = digitalRead(Enc[0].pinA);\n    int PIND_REG=PIND;  // read entire register once\n    int drB = bool(PIND_REG&(1<<2));int drA = bool(PIND_REG&(1<<3));  //PD2, PD3 --> 2, 3\n\t\n    // Possibly wait before reading pin A, then read it\n    //debounce(Enc[0].del);\n    \n    // this updates the counter\n    if (drA == HIGH)\n    {\n        // low->high on A?\n        if (drB == LOW) {  // check pin B\n            Enc[0].pos++;  // going clockwise: increment\n        }\n        else {\n            Enc[0].pos--;  // going counterclockwise: decrement\n        }\n        \n    }\n    else {\n        // must be high to low on A\n        if (drB == HIGH) { // check pin B\n            Enc[0].pos++;  // going clockwise: increment\n        }\n        else {\n            Enc[0].pos--;  // going counterclockwise: decrement\n        }\n    } // end counter update\n} // end ISR pin A Encoder 0\n\n// Interrupt Service Routine: change on pin B for Encoder 0\nstatic void isrPinBEn0(void)\n{\n    // read pin A right away\n    //int drA = digitalRead(Enc[0].pinA);int drB = digitalRead(Enc[0].pinB);\n    int PIND_REG=PIND;  // read entire register once\n    int drA = bool(PIND_REG&(1<<3));int drB = bool(PIND_REG&(1<<2)); // //PD2, PD3 --> 2, 3\n    // possibly wait before reading pin B, then read it\n    //debounce(Enc[0].del);\n\n    // this updates the counter\n    if (drB == HIGH) {   // low->high on B?\n        if (drA == HIGH) { // check pin A\n            Enc[0].pos++;  // going clockwise: increment\n        } else {\n            Enc[0].pos--;  // going counterclockwise: decrement\n        }\n    } else {                       // must be high to low on B\n        if (drA == LOW) {  // check pin A\n            Enc[0].pos++;  // going clockwise: increment\n        } else {\n            Enc[0].pos--;  // going counterclockwise: decrement\n        }\n    } // end counter update\n} // end ISR pin B Encoder 0\n\n// ISR routines for PCINT2\n// Encoder using PCINT vector will be ENC[3]\n/* Interrupt Service Routine: change on pin A & B */\nISR( PCINT2_vect )\n{\n  /* read pin A & B right away                                   */\n    int PIND_REG=PIND;  // read entire register once\n\tint drB = bool(PIND_REG&(1<<5));int drA = bool(PIND_REG&(1<<6));  // PD5, PD6 --> D5, D6\n\n\t\n  // Find out which pin changed:\n  if(drB==Enc[3].Bprev){\n\t  // A must have changed\n\t  Enc[3].Aprev=drA;\n\t  // this updates the counter if A Changed:\n    if (drA == HIGH) {   // low->high on A?\n        if (drB == LOW) {  // check pin B\n            Enc[3].pos++;  // going clockwise: increment\n        } else {\n            Enc[3].pos--;  // going counterclockwise: decrement\n        }\n    }\n    else { // must be high to low on A\n        if (drB == HIGH) { // check pin B\n            Enc[3].pos++;  // going clockwise: increment\n        } else {\n            Enc[3].pos--;  // going counterclockwise: decrement\n        }\n    } // end counter update\n\t\n  } else {\n\t  // B must have changed\n\t  Enc[3].Bprev=drB;\n\t  // this updates the counter if B changed:\n    if (drB == HIGH) {   // low->high on B?\n        if (drA == HIGH) { // check pin A\n            Enc[3].pos++;  // going clockwise: increment\n        } else {\n            Enc[3].pos--;  // going counterclockwise: decrement\n        }\n    }\n    else { // must be high to low on B\n        if (drA == LOW) {  // check pin A\n            Enc[3].pos++;  // going clockwise: increment\n        } else {\n            Enc[3].pos--;  // going counterclockwise: decrement\n        }\n    } // end counter update\n\t  \n  }\n\t\n/*   // this updates the counter                                \n  if (drA == HIGH) {   // low->high on A?  \n      \n    if (drB == LOW) {  // check pin B  \n  \tEnc[3].pos++;  // going clockwise: increment          \n    } else {\n  \tEnc[3].pos--;  // going counterclockwise: decrement   \n    }\n    \n  } else {                       // must be high to low on A  \n  \n    if (drB == HIGH) { // check pin B  \n  \tEnc[3].pos++;  // going clockwise: increment          \n    } else {\n  \tEnc[3].pos--;  // going counterclockwise: decrement   \n    }\n    \n  } // end counter update    */                                  \n\n} // end ISR pin A Encoder 3   \n\n// ISR routines for PCINT1\n// Encoder using PCINT vector will be ENC[4]\n/* Interrupt Service Routine: change on pin A & B */\nISR( PCINT1_vect )\n{\n  /* read pin A & B right away                                   */\n    int PINB_REG=PINC;  // read entire register once\n\tint drB = bool(PINB_REG&(1<<2));int drA = bool(PINB_REG&(1<<3));  // PC2, PC3 --> A2, A3\n\n\t\n  // Find out which pin changed:\n  if(drB==Enc[4].Bprev){\n\t  // A must have changed\n\t  Enc[4].Aprev=drA;\n\t  // this updates the counter if A Changed:\n    if (drA == HIGH) {   // low->high on A?\n        if (drB == LOW) {  // check pin B\n            Enc[4].pos++;  // going clockwise: increment\n        } else {\n            Enc[4].pos--;  // going counterclockwise: decrement\n        }\n    }\n    else { // must be high to low on A\n        if (drB == HIGH) { // check pin B\n            Enc[4].pos++;  // going clockwise: increment\n        } else {\n            Enc[4].pos--;  // going counterclockwise: decrement\n        }\n    } // end counter update\n\t\n  } else {\n\t  // B must have changed\n\t  Enc[4].Bprev=drB;\n\t  // this updates the counter if B changed:\n    if (drB == HIGH) {   // low->high on B?\n        if (drA == HIGH) { // check pin A\n            Enc[4].pos++;  // going clockwise: increment\n        } else {\n            Enc[4].pos--;  // going counterclockwise: decrement\n        }\n    }\n    else { // must be high to low on B\n        if (drA == LOW) {  // check pin A\n            Enc[4].pos++;  // going clockwise: increment\n        } else {\n            Enc[4].pos--;  // going counterclockwise: decrement\n        }\n    } // end counter update\n\t  \n  }\n\t\n/*   // this updates the counter                                \n  if (drA == HIGH) {   // low->high on A?  \n      \n    if (drB == LOW) {  // check pin B  \n  \tEnc[4].pos++;  // going clockwise: increment          \n    } else {\n  \tEnc[4].pos--;  // going counterclockwise: decrement   \n    }\n    \n  } else {                       // must be high to low on A  \n  \n    if (drB == HIGH) { // check pin B  \n  \tEnc[4].pos++;  // going clockwise: increment          \n    } else {\n  \tEnc[4].pos--;  // going counterclockwise: decrement   \n    }\n    \n  } // end counter update    */                                  \n\n} // end ISR pin A Encoder 3      \n\n\n// Initialization function called by Encoder System object\nextern \"C\" void enc_init(int enc, int pinA, int pinB)\n{\n    // enc is the encoder number and it can be 0,1 or 2\n    // if other encoder blocks are present in the model\n    // up to a maximum of 3, they need to refer to a\n    // different encoder number\n    \n    // store pinA and pinB in global encoder structure Enc\n    // they will be needed later by the interrupt routine\n    // that will not be able to access s-function parameters\n    \n    Enc[enc].pinA=pinA;      // set pin A\n    Enc[enc].pinB=pinB;      // set pin B\n    \n    // set encoder pins as inputs\n    pinMode(Enc[enc].pinA, INPUT);\n    pinMode(Enc[enc].pinB, INPUT);\n        \n    // turn on pullup resistors\n    digitalWrite(Enc[enc].pinA, HIGH);\n    digitalWrite(Enc[enc].pinB, HIGH);\n    \n    // attach interrupts\n    switch(enc) {\n        case 0:\n            attachInterrupt(getIntNum(Enc[0].pinA), irsPinAEn0, CHANGE);\n            attachInterrupt(getIntNum(Enc[0].pinB), isrPinBEn0, CHANGE);\n            break;\n        case 1:\n            //attachInterrupt(getIntNum(Enc[1].pinA), irsPinAEn1, CHANGE);\n            //attachInterrupt(getIntNum(Enc[1].pinB), isrPinBEn1, CHANGE);\n            break;\n        case 2:\n            //attachInterrupt(getIntNum(Enc[2].pinA), irsPinAEn2, CHANGE);\n            //attachInterrupt(getIntNum(Enc[2].pinB), isrPinBEn2, CHANGE);\n            break;\n\t\tcase 3:\n\t\t\t// No Case 3 for uno nano\n\t\t\t// attach interrupts for enc[3]:\n\t\t\t// make analog pin A8 and RX3 (D13) into pin change interrupts:\n\t\t\t//PCICR |= (1 << PCIE2);     // enable PCINT 2\n\t\t\t//PCICR |= (1 << PCIE1);     // enable PCINT 1 \n\t\t\t//PCMSK2 |= (1 << PCINT16);  // Analog 8 as input\n\t\t\t//PCMSK1 |= (1 << PCINT9);  // RX3 D15 as input \n\t\t\t\n\t\t\tPCICR |= (1 << PCIE2);     // enable PCINT1  D5, D6 PCINT2)\n\t\t\tPCMSK2 |= (1 << PCINT21);  // analog D5 as input (uno, nano)\n\t\t\tPCMSK2 |= (1 << PCINT22);  // analog D6 as input (uno, nano)\n\t\t\tbreak;\t\t\n\t\tcase 4:\n\t\t\t// attach interrupts for enc[4]:\n\t\t\t// ping 11 and 12 into pin change interrupts:\n\t\t\t//\n\t\t\t///PCICR |= (1 << PCIE0);     // enable PCINT0  (pins 11 and 12 --> PCINT5, PCINT6 --> PCINT0 vec)\n\t\t\t//PCMSK0 |= (1 << PCINT3);  // Pin 11 (uno, nano)\n\t\t\t//PCMSK0 |= (1 << PCINT4);  // Pin 12 (uno, nano)\n\t\t\t\n\t\t\t// no longer use 11 and 12 for encoder inputs but instead PWM outputs \n\t\t\t// ADC2 and ACDC3 which are PCINT10, PCINT11 which is on PCINT 1 or PCINT1 vec\n\t\t\t\n\t\t\tPCICR |= (1 << PCIE1);     // enable PCINT1  (A2 & A3 --> PCINT10, PCINT11 --> PCINT1 vec)\n\t\t\tPCMSK1 |= (1 << PCINT10);  // analog A2 as input (uno, nano)\n\t\t\tPCMSK1 |= (1 << PCINT11);  // analog A3 as input (uno, nano)\n\t\t\t\n\t\t\t\n\t\t\tbreak;\t\t\t\n    }\n}\n\n// Output function called by Encoder System object\nextern \"C\" long enc_output(long enc)\n{\n    return (long)Enc[enc].pos;\n}\n// [EOF]\n\n"},{"name":"float2bytes.cpp","type":"source","group":"other","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"#include <math.h>\n#include \"Arduino.h\"\n#include \"float2bytes.h\"\n#include \"io_wrappers.h\"\n//#include \"inttypes.h\"\n//#include \"stdio.h\"\n//#include \"stdint.h\"\n\nunion{\n    unsigned char b[4];\n    float f;\n} bfloat;\n\n\nextern \"C\" void float2bytes(unsigned char* pfData, float fin)\n{\n// copy the value to memory\n// Write float data to memory:\nbfloat.f=fin;\n// Assign those bytes in big-endian\n// to the output vector\npfData[0]=bfloat.b[3];\npfData[1]=bfloat.b[2];\npfData[2]=bfloat.b[1];\npfData[3]=bfloat.b[0];\n}\n\n"},{"name":"int2bytes.cpp","type":"source","group":"other","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"#include <math.h>\n#include \"int2bytes.h\"\n\nunion{\n    unsigned char b[2];\n    int i;\n} bint;\n\n\nextern \"C\" void int2bytes(unsigned char* pfData, int int_in)\n{\n// copy the value to memory\n// Write int data to memory:\nbint.i=int_in;\n// Assign those bytes in big-endian\n// to the output vector\npfData[0]=bint.b[1];\npfData[1]=bint.b[0];\n}\n\n"},{"name":"io_wrappers.cpp","type":"source","group":"legacy","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/../../../Documents/MATLAB/SupportPackages/R2025b/toolbox/target/supportpackages/arduinobase/src","tag":"","groupDisplay":"Other files","code":"/*\n* Wrappers to make I/O functions available with C linkage. This allows C++\n* methods to be called from C code.\n*\n* Copyright 2011-2024 The MathWorks, Inc. */\n\n#include <inttypes.h>\n#include \"Arduino.h\"\n#include \"rtwtypes.h\"\n\n#if (defined(_RTT_TCPIP_EXTMODE_) && (_RTT_TCPIP_EXTMODE_ == 1)) || (defined(_RTT_UDP_) && (_RTT_UDP_ != 0)) || (defined(_RTT_TCP_) && (_RTT_TCP_ != 0) || defined(_RTT_THINGSPEAK_))\n#include <Ethernet.h>\n#include <EthernetUdp.h>\n#include <SPI.h>\n#endif\n\n#if defined(ARDUINO_ARM_CORTEX_M0_PLUS)\nextern \"C\" void __libc_init_array(void);\n#endif\n\nextern \"C\" {\n    void __cxa_pure_virtual(void);\n}\n\nextern \"C\" void Serial_begin(int port, long r, int c)\n{\n    static int serialInit=0;\n    #if !(defined(ESP_PLATFORM))\n    serialInit=0;   //Reset serialInit flag for all targets except ESP32\n    #endif\n    #if defined(ARDUINO_ARCH_SAM)\n    UARTClass::UARTModes config = UARTClass::UARTModes(c);\n    #else\n    int config = c;\n    #endif\n    #if defined(ARDUINO_NUM_SERIAL_PORTS)\n    switch(port) {\n        case 0:\n            if(serialInit & 1)return;\n            serialInit |= 1;\n            #if defined(SERIAL_MULTIPURPOSE_0)\n              #if defined(ESP_PLATFORM)\n                    Serial.begin(r,config,_RTT_RX_PIN_SERIAL0_,_RTT_TX_PIN_SERIAL0_);\n                #elif defined(ARDUINO_ARCH_RP2040)\n                    gpio_set_function(_RTT_RX_PIN_SERIAL0_, GPIO_FUNC_UART);\n                    gpio_set_function(_RTT_TX_PIN_SERIAL0_, GPIO_FUNC_UART);\n                    Serial.begin(r,config);\n                #endif\n            #elif (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n                Serial.begin(r);\n            #else\n                Serial.begin(r,config);\n            #endif\n            break;\n        case 1:\n            if(serialInit & 2)return;\n            serialInit |= 2;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 2)\n            #if defined(SERIAL_MULTIPURPOSE_1)\n                #if defined(ESP_PLATFORM)\n                    Serial1.begin(r,config,_RTT_RX_PIN_SERIAL1_,_RTT_TX_PIN_SERIAL1_);\n                #elif defined(ARDUINO_ARCH_RP2040)\n                    gpio_set_function(_RTT_RX_PIN_SERIAL1_, GPIO_FUNC_UART);\n                    gpio_set_function(_RTT_TX_PIN_SERIAL1_, GPIO_FUNC_UART);\n                    Serial1.begin(r,config);\n                #endif\n            #elif (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial1.begin(r);\n            #else\n            Serial1.begin(r,config);\n            #endif\n            #endif\n            break;\n        case 2:\n            if(serialInit & 4)return;\n            serialInit |= 4;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 3)\n            #if defined(SERIAL_MULTIPURPOSE_2)\n                #if defined(ESP_PLATFORM)\n                Serial2.begin(r,config,_RTT_RX_PIN_SERIAL2_,_RTT_TX_PIN_SERIAL2_);\n                #elif defined(ARDUINO_ARCH_RP2040)\n                gpio_set_function(_RTT_RX_PIN_SERIAL2_, GPIO_FUNC_UART);\n                gpio_set_function(_RTT_TX_PIN_SERIAL2_, GPIO_FUNC_UART);\n                Serial2.begin(r,config);\n                #endif\n            #elif (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial2.begin(r);\n            #else\n            Serial2.begin(r,config);\n            #endif\n            #endif\n            break;\n        case 3:\n            if(serialInit & 8)return;\n            serialInit |= 8;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 4)\n            #if (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial3.begin(r);\n            #else\n            Serial3.begin(r,config);\n            #endif\n            #endif\n\n            break;\n        case 4:\n            if(serialInit & 16)return;\n            serialInit |= 16;     \n            #if(ARDUINO_NUM_SERIAL_PORTS >= 5)\n            #if (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial4.begin(r);\n            #else\n            Serial4.begin(r,config);\n            #endif\n            #endif\n            break;\n       case 5:\n            if(serialInit & 32)return;\n            serialInit |= 32;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 6)\n            #if (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial5.begin(r);\n            #else\n            Serial5.begin(r,config);\n            #endif\n            #endif\n\n            break;\n       case 6:\n            if(serialInit & 64)return;\n            serialInit |= 64;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 7)\n            #if (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial6.begin(r);\n            #else\n            Serial6.begin(r,config);\n            #endif\n            #endif\n\n            break;\n        case 7:\n            if(serialInit & 128)return;\n            serialInit |= 128;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 8)\n            #if (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial7.begin(r);\n            #else\n            Serial7.begin(r,config);\n            #endif\n            #endif\n      case 8:\n            if(serialInit & 256)return;\n            serialInit |= 256;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 9)\n            #if (defined(ARDUINO_TEENSY41))\n            Serial8.begin(r);\n            #else\n            Serial8.begin(r,config);\n            #endif\n            #endif\n\n            break;\n\n            break;\n    }\n    #else\n    if(serialInit & 1)return;\n    serialInit |= 1;\n    Serial.begin(r,SERIAL_8N1);\n    #endif\n}\n\nextern \"C\" void Serial_read(int port, int showOutStatus, uint8_t *outData, int16_t *outStatus)\n{\n    int libFcnOutput;\n    #if defined(ARDUINO_NUM_SERIAL_PORTS)\n    switch(port) {\n        case 0:\n            libFcnOutput = Serial.read();\n            break;\n        case 1:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 2)\n            libFcnOutput = Serial1.read();\n            #endif\n            break;\n        case 2:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 3)\n            libFcnOutput = Serial2.read();\n            #endif\n            break;\n        case 3:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 4)\n            libFcnOutput = Serial3.read();\n            #endif\n            break;\n        case 4:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 5)\n            libFcnOutput = Serial4.read();\n            #endif\n            break;\n        case 5:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 6)\n            libFcnOutput = Serial5.read();\n            #endif\n            break;\n        case 6:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 7)\n            libFcnOutput = Serial6.read();\n            #endif\n            break;\n       case 7:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 8)\n            libFcnOutput = Serial7.read();\n            #endif\n            break;\n       case 8:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 9)\n            libFcnOutput = Serial8.read();\n            #endif\n            break;\n    }\n    #else\n    libFcnOutput = Serial.read();\n    #endif\n    *outData = (uint8_t) libFcnOutput;\n    *outStatus = (libFcnOutput != -1);\n}\n\nextern \"C\" void Serial_write(int port, uint8_t * c, size_t s)\n{\n    #if defined(ARDUINO_NUM_SERIAL_PORTS)\n    switch(port) {\n        case 0:\n            Serial.write(c, s);\n            break;\n        case 1:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 2)\n            Serial1.write(c, s);\n            #endif\n            break;\n        case 2:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 3)\n            Serial2.write(c, s);\n            #endif\n            break;\n        case 3:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 4)\n            Serial3.write(c, s);\n            #endif\n            break;\n        case 4:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 5)\n            Serial4.write(c, s);\n            #endif\n            break;\n        case 5:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 6)\n            Serial5.write(c, s);\n            #endif\n            break;\n        case 6:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 7)\n            Serial6.write(c, s);\n            #endif\n            break;\n        case 7:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 8)\n            Serial7.write(c, s);\n            #endif\n            break;\n        case 8:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 9)\n            Serial8.write(c, s);\n            #endif\n            break;\n    }\n    #else\n    Serial.write(c, s);\n    #endif\n}\n\n#if _RTT_UDP_ != 0\nEthernetUDP Udp[_RTT_UDP_];\nIPAddress localIpAddress(_RTT_Local_IP1, _RTT_Local_IP2, _RTT_Local_IP3, _RTT_Local_IP4);\nbyte mac[] = { _RTT_Local_MAC1, _RTT_Local_MAC2, _RTT_Local_MAC3, _RTT_Local_MAC4, _RTT_Local_MAC5, _RTT_Local_MAC6 };\nunsigned int localport[_RTT_UDP_] = {_RTT_UDP_LOCAL_PORT_ORDERED};\nint configureSuccess;\nint trialcount=0;\nextern \"C\" uint8_t MW_EthernetAndUDPBegin(uint8_t udpindex, uint32_t localPort)\n{\n    static int only_one_ethernet_begin;\n    if (only_one_ethernet_begin==0)\n    {\n        #if (defined(_RTT_DISABLE_Ethernet_DHCP_) && (_RTT_DISABLE_Ethernet_DHCP_ !=0))\n        Ethernet.begin(mac, localIpAddress);\n        configureSuccess = 1;\n        #else\n        configureSuccess = Ethernet.begin(mac);\n        #endif\n        only_one_ethernet_begin++;\n\n        for(trialcount=0;trialcount<5;trialcount++)\n        {\n            if(Serial)\n            {\n                break;\n            }else\n            {\n                delay(1000);\n            }\n        }\n        // Depending on if the IP address assignment using DHCP has been successful or not,\n        // send the appropriate information back to the host.\n        // If External mode over TCP/IP or Wifi, do not print this Info. Information of IP address will be printed as\n        // a part of rtiostream_open\n        #if (!(defined(_RTT_TCPIP_EXTMODE_) && (_RTT_TCPIP_EXTMODE_ == 1)))\n        if (configureSuccess==1)\n        {\n            if(Ethernet.localIP()[0] == 0 || Ethernet.localIP()[0] == 255)\n            {\n                /*Tried to assign Static IP, failed due to one of the following reasons :\n                * 1. Ethernet shield is not connected properly with Arduino.\n                * 2. Ethernet shield is not connected to a network.\n                **/\n                Serial.println(\"<<<IP address: Failed to configure.>>>\");\n            }\n            else\n            {\n                // If the Configuration is successful, relay back the assigned IP address.\n                Serial.print(\"<<<IP address: \");\n                for (byte thisByte = 0; thisByte < 4; thisByte++)\n                {\n                    // Print the value of each byte of the IP address:\n                    Serial.print(Ethernet.localIP()[thisByte], DEC);\n                    if (thisByte<3)\n                    {\n                        Serial.print(\".\");\n                    }\n                }\n                Serial.println(\">>>\");\n            }\n        }\n        else\n        {\n            // If the Configuration failed,relay back the error message.\n            Serial.println(\"<<<IP address: Failed to configure.>>>\");\n        }\n        Serial.flush();\n        #endif\n    }\n    return (Udp[udpindex].begin(localport[udpindex]));\n}\n\nextern \"C\" int MW_UDPFinalWrite(uint8_t udpindex, uint8_t data, uint8_t remoteIPOctect1,uint8_t remoteIPOctect2,uint8_t remoteIPOctect3,uint8_t remoteIPOctect4, uint32_t remoteport)\n{\n    IPAddress remoteIpAddress(remoteIPOctect1,remoteIPOctect2, remoteIPOctect3, remoteIPOctect4);\n    Udp[udpindex].beginPacket(remoteIpAddress, remoteport);\n    Udp[udpindex].write(data);\n    return(Udp[udpindex].endPacket());\n}\n\nextern \"C\" void MW_UDPFinalRead(uint8_t udpindex, uint8_t *data, int32_t *outStatus)\n{\n    int packetSize = Udp[udpindex].parsePacket();\n    if(packetSize)\n    {\n        int libFcnOutput;\n        libFcnOutput = Udp[udpindex].read();\n        *data = (uint8_t) libFcnOutput;\n        *outStatus = (libFcnOutput != -1);\n    }\n\n    else\n    {\n        //When the client is not connected the status flag is accordingly toggled.\n        *outStatus = 0;\n    }\n}\n#endif\n\n#if defined(_RTT_THINGSPEAK_) || (_RTT_TCP_ != 0)\nIPAddress localIpAddress(_RTT_Local_IP1, _RTT_Local_IP2, _RTT_Local_IP3, _RTT_Local_IP4);\nbyte mac[] = { _RTT_Local_MAC1, _RTT_Local_MAC2, _RTT_Local_MAC3, _RTT_Local_MAC4, _RTT_Local_MAC5, _RTT_Local_MAC6 };\nint configureSuccess;\nint trialcount;\n#if _RTT_TCP_ != 0\nEthernetServer server[_RTT_TCP_] = {_RTT_TCP_SERVER_PORT_ORDERED};\n#endif\nextern \"C\" void MW_EthernetAndTCPServerBegin(uint8_t tcpindex, uint32_t serverport)\n{\n    static int only_one_tcp_server_and_ethernet_begin = 0;\n\n    if (only_one_tcp_server_and_ethernet_begin==0)\n    {\n        #if (defined(_RTT_DISABLE_Ethernet_DHCP_) && (_RTT_DISABLE_Ethernet_DHCP_ !=0))\n        Ethernet.begin(mac, localIpAddress);\n        configureSuccess = 1;\n        #else\n        configureSuccess = Ethernet.begin(mac);\n        #endif\n        only_one_tcp_server_and_ethernet_begin++;\n\n        for(trialcount=0;trialcount<5;trialcount++)\n        {\n            if(Serial)\n            {\n                break;\n            }else\n            {\n                delay(1000);\n            }\n        }\n\n        // Depending on if the IP address assignment using DHCP has been successful or not,\n        // send the appropriate information back to the host.\n        // If External mode over TCP/IP or Wifi, do not print this Info. Information of IP address will be printed as\n        // a part of rtiostream_open\n        #if (!(defined(_RTT_TCPIP_EXTMODE_) && (_RTT_TCPIP_EXTMODE_ == 1)))\n        if (configureSuccess==1)\n        {\n            if(Ethernet.localIP()[0] == 0 || Ethernet.localIP()[0] == 255)\n            {\n                /*Tried to assign Static IP, failed due to one of the following reasons :\n                * 1. Ethernet shield is not connected properly with Arduino.\n                * 2. Ethernet shield is not connected to a network.\n                **/\n                Serial.println(\"<<<IP address: Failed to configure.>>>\");\n            }\n            else\n            {\n                // If the Configuration is successful, relay back the assigned IP address.\n                Serial.print(\"<<<IP address: \");\n                for (byte thisByte = 0; thisByte < 4; thisByte++)\n                {\n                    // Print the value of each byte of the IP address:\n                    Serial.print(Ethernet.localIP()[thisByte], DEC);\n                    if (thisByte<3)\n                    {\n                        Serial.print(\".\");\n                    }\n                }\n                Serial.println(\">>>\");\n            }\n        }\n        else\n        {\n            // If the Configuration failed,relay back the error message.\n            Serial.println(\"<<<IP address: Failed to configure.>>>\");\n        }\n        Serial.flush();\n        #endif\n\n        #if _RTT_TCP_ != 0\n        // Begin all servers based on the number of different TCP ports.\n        for (int i = 0;i < _RTT_TCP_;i++)\n        {\n            server[i].begin();\n        }\n        #endif\n        only_one_tcp_server_and_ethernet_begin = 1;\n    }\n}\n#endif\n#if _RTT_TCP_ != 0\nextern \"C\" void MW_TCPFinalread(uint8_t tcpindex, uint8_t *data, uint32_t serverport, int32_t *outStatus)\n{\n    int libFcnOutput;\n    EthernetClient client = server[tcpindex].available();\n    if (int(client) == true) {\n        libFcnOutput = client.read();\n        *data = (uint8_t) libFcnOutput;\n        *outStatus = (libFcnOutput != -1);\n\n    }\n    else\n    {\n        //When the client is not connected the status flag is accordingly toggled.\n        *outStatus = 0;\n    }\n\n}\nextern \"C\" void MW_TCPFinalWrite(uint8_t tcpindex, uint8_t data, uint32_t serverport)\n{\n    server[tcpindex].write(data);\n}\n#endif\n\n\n#if defined(_ROTH_LEONARDO_)\nextern \"C\" void MW_usbattach()\n{\n    USBDevice.attach();\n}\n#elif defined(ARDUINO_VIRTUAL_COM_PORT)\nextern \"C\" void MW_usbattach()\n{\n    __libc_init_array();\n    USBDevice.init();\n    USBDevice.attach();\n\n}\n#endif\n\nextern \"C\" void MW_pinModeExternalInterrupt(uint8_t pinNumber)\n{\n    pinMode(pinNumber, INPUT_PULLUP);\n}\n\nextern \"C\" void MW_delay_in_milliseconds(uint32_T period)\n{\n    uint32_T start_time = 0;\n    start_time = millis();\n    while(millis()- start_time <= period)\n    {\n        1;\n    }\n}\n\nextern \"C\" void MW_delay_in_microseconds(uint32_T period)\n{\n    uint32_T start_time = 0;\n    start_time = micros();\n    while(micros()- start_time <= period)\n    {\n        1;\n    }\n}\n\nextern \"C\" uint32_T MW_getCurrentTime_in_milliseconds()\n{\n   return (uint32_T)millis();\n}\n\n\n// #if defined(ARDUINO_ARDUINO_NANO33BLE)\n// #include \"Arduino.h\"\n// #include \"pins_arduino.h\"\n// #include \"mbed/drivers/AnalogIn.h\"\n// #include \"mbed.h\"\n//\n// extern uint8_t nano33BLE_dutycycle[21];\n// extern uint16_t nano33BLE_period[21];\n//\n//\n// events::EventQueue queue(32 * EVENTS_EVENT_SIZE);\n// rtos::Thread t;\n// mbed::Ticker tick;\n//\n// static int write_resolution = 8;\n// static int read_resolution = 10;\n//\n// extern \"C\" void MW_NANO33BLE_analogWrite_1(pin_size_t pin, int val, uint16_t period)\n// {\n//   if (pin >= PINS_COUNT) {\n//     return;\n//   }\n//   float percent = (float)val/(float)((1 << write_resolution)-1);\n//   mbed::PwmOut* pwm = digitalPinToPwm(pin);\n//   if (pwm == NULL) {\n//     pwm = new mbed::PwmOut(digitalPinToPinName(pin));\n//     digitalPinToPwm(pin) = pwm;\n//     pwm->period_ms(period);\n//   }\n//   pwm->write(percent);\n// }\n//\n// extern \"C\" void MW_NANO33BLE_PWM_Handler()\n// {\n//     MW_NANO33BLE_analogWrite_1(5, nano33BLE_dutycycle[5], nano33BLE_period[5]);\n// }\n//\n// extern \"C\" void MW_NANO33BLE_PWM_Setup()\n// {\n//   t.start(callback(&queue, &events::EventQueue::dispatch_forever));\n//   tick.attach(queue.event(MW_NANO33BLE_PWM_Handler),_RTT_PWM_PIN5_CST );\n// }\n//\n//\n//\n//\n// extern \"C\" void MW_NANO33BLE_analogWrite(PinName pin, int val, uint16_t period)\n// {\n// //   pin_size_t idx = PinNameToIndex(pin);\n// //   if (idx != NOT_A_PIN) {\n// //     MW_NANO33BLE_analogWrite_1(idx, 50, period);\n// //   } else {\n// //     mbed::PwmOut* pwm = new mbed::PwmOut(pin);\n// //     pwm->period_ms(2);\n// //     float percent = (float)50/(float)((1 << write_resolution)-1);\n// //     pwm->write(percent);\n// //   }\n// }\n//\n// #endif\n"},{"name":"platform_timer.cpp","type":"source","group":"legacy","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/../../../Documents/MATLAB/SupportPackages/R2025b/toolbox/target/supportpackages/arduinotarget/src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2023 The MathWorks, Inc. */\n#include \"rtwtypes.h\"\n#include \"Arduino.h\" /* Required for micros() function */\n\n#define MW_StringifyDefine(x) MW_StringifyDefineExpanded(x)\n#define MW_StringifyDefineExpanded(x)  #x\n\n#define MW_StringifyDefineHeader(x) MW_StringifyDefineHeaderExpand(x)\n#define MW_StringifyDefineHeaderExpand(x)  x.h\n\n#include MW_StringifyDefine(MW_StringifyDefineHeader(MODEL))\n\nstatic volatile uint32_T timestampInitialized = 0;\nstatic volatile uint32_T timestampStartTime = 0;\n\nstatic void timestampInit(void)\n{\n    if (0 == timestampInitialized)\n    {\n        timestampStartTime =  micros();\n        timestampInitialized = 1;\n    }\n}\n\n__attribute__((optimize(\"O3\"))) static uint32_T returnTimeElapsed(uint32_T timestampStartTime)\n{\n    uint32_T currentTime;\n    uint32_T ret = 0;\n    \n    currentTime = micros();\n    \n    if (currentTime >= timestampStartTime)\n    {\n        ret = (uint32_T) (currentTime - timestampStartTime);\n    }\n    else\n    {\n        ret = (uint32_T) (MAX_uint32_T - timestampStartTime + currentTime);\n    }\n    return ret ;\n}\n\nextern \"C\" __attribute__((optimize(\"O3\"))) uint32_T getCurrentTimestamp(void)\n{\n    uint32_T ret = 0;\n    if ((1 == runModel) || (1 == timestampInitialized))\n    {\n        if (0 == timestampInitialized)\n        {\n            timestampInit();\n        }\n        ret = returnTimeElapsed(timestampStartTime);\n    }\n    else\n    {\n        timestampStartTime =  micros();\n    }\n    return ret;\n}"},{"name":"quaternionFilters.cpp","type":"source","group":"other","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/tmp","tag":"","groupDisplay":"Other files","code":"\n// Implementation of Sebastian Madgwick's \"...efficient orientation filter\n// for... inertial/magnetic sensor arrays\"\n// (see http://www.x-io.co.uk/category/open-source/ for examples & more details)\n// which fuses acceleration, rotation rate, and magnetic moments to produce a\n// quaternion-based estimate of absolute device orientation -- which can be\n// converted to yaw, pitch, and roll. Useful for stabilizing quadcopters, etc.\n// The performance of the orientation filter is at least as good as conventional\n// Kalman-based filtering algorithms but is much less computationally\n// intensive---it can be performed on a 3.3 V Pro Mini operating at 8 MHz!\n\n#include \"quaternionFilters.h\"\n\n// These are the free parameters in the Mahony filter and fusion scheme, Kp\n// for proportional feedback, Ki for integral\n#define Kp 2.0f * 5.0f\n#define Ki 0.0f\n\nstatic float GyroMeasError = PI * (40.0f / 180.0f);\n// gyroscope measurement drift in rad/s/s (start at 0.0 deg/s/s)\nstatic float GyroMeasDrift = PI * (0.0f  / 180.0f);\n// There is a tradeoff in the beta parameter between accuracy and response\n// speed. In the original Madgwick study, beta of 0.041 (corresponding to\n// GyroMeasError of 2.7 degrees/s) was found to give optimal accuracy.\n// However, with this value, the LSM9SD0 response time is about 10 seconds\n// to a stable initial quaternion. Subsequent changes also require a\n// longish lag time to a stable output, not fast enough for a quadcopter or\n// robot car! By increasing beta (GyroMeasError) by about a factor of\n// fifteen, the response time constant is reduced to ~2 sec. I haven't\n// noticed any reduction in solution accuracy. This is essentially the I\n// coefficient in a PID control sense; the bigger the feedback coefficient,\n// the faster the solution converges, usually at the expense of accuracy.\n// In any case, this is the free parameter in the Madgwick filtering and\n// fusion scheme.\nstatic float beta = sqrt(3.0f / 4.0f) * GyroMeasError;   // Compute beta\n// Compute zeta, the other free parameter in the Madgwick scheme usually\n// set to a small or zero value\nstatic float zeta = sqrt(3.0f / 4.0f) * GyroMeasDrift;\n\n// Vector to hold integral error for Mahony method\nstatic float eInt[3] = {0.0f, 0.0f, 0.0f};\n// Vector to hold quaternion\nstatic float q[4] = {1.0f, 0.0f, 0.0f, 0.0f};\n\nvoid MadgwickQuaternionUpdate(float ax, float ay, float az, float gx, float gy, float gz, float mx, float my, float mz, float deltat)\n{\n  // short name local variable for readability\n  float q1 = q[0], q2 = q[1], q3 = q[2], q4 = q[3];\n  float norm;\n  float hx, hy, _2bx, _2bz;\n  float s1, s2, s3, s4;\n  float qDot1, qDot2, qDot3, qDot4;\n\n  // Auxiliary variables to avoid repeated arithmetic\n  float _2q1mx;\n  float _2q1my;\n  float _2q1mz;\n  float _2q2mx;\n  float _4bx;\n  float _4bz;\n  float _2q1 = 2.0f * q1;\n  float _2q2 = 2.0f * q2;\n  float _2q3 = 2.0f * q3;\n  float _2q4 = 2.0f * q4;\n  float _2q1q3 = 2.0f * q1 * q3;\n  float _2q3q4 = 2.0f * q3 * q4;\n  float q1q1 = q1 * q1;\n  float q1q2 = q1 * q2;\n  float q1q3 = q1 * q3;\n  float q1q4 = q1 * q4;\n  float q2q2 = q2 * q2;\n  float q2q3 = q2 * q3;\n  float q2q4 = q2 * q4;\n  float q3q3 = q3 * q3;\n  float q3q4 = q3 * q4;\n  float q4q4 = q4 * q4;\n\n  // Normalise accelerometer measurement\n  norm = sqrt(ax * ax + ay * ay + az * az);\n  if (norm == 0.0f) return; // handle NaN\n  norm = 1.0f/norm;\n  ax *= norm;\n  ay *= norm;\n  az *= norm;\n\n  // Normalise magnetometer measurement\n  norm = sqrt(mx * mx + my * my + mz * mz);\n  if (norm == 0.0f) return; // handle NaN\n  norm = 1.0f/norm;\n  mx *= norm;\n  my *= norm;\n  mz *= norm;\n\n  // Reference direction of Earth's magnetic field\n  _2q1mx = 2.0f * q1 * mx;\n  _2q1my = 2.0f * q1 * my;\n  _2q1mz = 2.0f * q1 * mz;\n  _2q2mx = 2.0f * q2 * mx;\n  hx = mx * q1q1 - _2q1my * q4 + _2q1mz * q3 + mx * q2q2 + _2q2 * my * q3 +\n       _2q2 * mz * q4 - mx * q3q3 - mx * q4q4;\n  hy = _2q1mx * q4 + my * q1q1 - _2q1mz * q2 + _2q2mx * q3 - my * q2q2 + my * q3q3 + _2q3 * mz * q4 - my * q4q4;\n  _2bx = sqrt(hx * hx + hy * hy);\n  _2bz = -_2q1mx * q3 + _2q1my * q2 + mz * q1q1 + _2q2mx * q4 - mz * q2q2 + _2q3 * my * q4 - mz * q3q3 + mz * q4q4;\n  _4bx = 2.0f * _2bx;\n  _4bz = 2.0f * _2bz;\n\n  // Gradient decent algorithm corrective step\n  s1 = -_2q3 * (2.0f * q2q4 - _2q1q3 - ax) + _2q2 * (2.0f * q1q2 + _2q3q4 - ay) - _2bz * q3 * (_2bx * (0.5f - q3q3 - q4q4) + _2bz * (q2q4 - q1q3) - mx) + (-_2bx * q4 + _2bz * q2) * (_2bx * (q2q3 - q1q4) + _2bz * (q1q2 + q3q4) - my) + _2bx * q3 * (_2bx * (q1q3 + q2q4) + _2bz * (0.5f - q2q2 - q3q3) - mz);\n  s2 = _2q4 * (2.0f * q2q4 - _2q1q3 - ax) + _2q1 * (2.0f * q1q2 + _2q3q4 - ay) - 4.0f * q2 * (1.0f - 2.0f * q2q2 - 2.0f * q3q3 - az) + _2bz * q4 * (_2bx * (0.5f - q3q3 - q4q4) + _2bz * (q2q4 - q1q3) - mx) + (_2bx * q3 + _2bz * q1) * (_2bx * (q2q3 - q1q4) + _2bz * (q1q2 + q3q4) - my) + (_2bx * q4 - _4bz * q2) * (_2bx * (q1q3 + q2q4) + _2bz * (0.5f - q2q2 - q3q3) - mz);\n  s3 = -_2q1 * (2.0f * q2q4 - _2q1q3 - ax) + _2q4 * (2.0f * q1q2 + _2q3q4 - ay) - 4.0f * q3 * (1.0f - 2.0f * q2q2 - 2.0f * q3q3 - az) + (-_4bx * q3 - _2bz * q1) * (_2bx * (0.5f - q3q3 - q4q4) + _2bz * (q2q4 - q1q3) - mx) + (_2bx * q2 + _2bz * q4) * (_2bx * (q2q3 - q1q4) + _2bz * (q1q2 + q3q4) - my) + (_2bx * q1 - _4bz * q3) * (_2bx * (q1q3 + q2q4) + _2bz * (0.5f - q2q2 - q3q3) - mz);\n  s4 = _2q2 * (2.0f * q2q4 - _2q1q3 - ax) + _2q3 * (2.0f * q1q2 + _2q3q4 - ay) + (-_4bx * q4 + _2bz * q2) * (_2bx * (0.5f - q3q3 - q4q4) + _2bz * (q2q4 - q1q3) - mx) + (-_2bx * q1 + _2bz * q3) * (_2bx * (q2q3 - q1q4) + _2bz * (q1q2 + q3q4) - my) + _2bx * q2 * (_2bx * (q1q3 + q2q4) + _2bz * (0.5f - q2q2 - q3q3) - mz);\n  norm = sqrt(s1 * s1 + s2 * s2 + s3 * s3 + s4 * s4);    // normalise step magnitude\n  norm = 1.0f/norm;\n  s1 *= norm;\n  s2 *= norm;\n  s3 *= norm;\n  s4 *= norm;\n\n  // Compute rate of change of quaternion\n  qDot1 = 0.5f * (-q2 * gx - q3 * gy - q4 * gz) - beta * s1;\n  qDot2 = 0.5f * (q1 * gx + q3 * gz - q4 * gy) - beta * s2;\n  qDot3 = 0.5f * (q1 * gy - q2 * gz + q4 * gx) - beta * s3;\n  qDot4 = 0.5f * (q1 * gz + q2 * gy - q3 * gx) - beta * s4;\n\n  // Integrate to yield quaternion\n  q1 += qDot1 * deltat;\n  q2 += qDot2 * deltat;\n  q3 += qDot3 * deltat;\n  q4 += qDot4 * deltat;\n  norm = sqrt(q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4);    // normalise quaternion\n  norm = 1.0f/norm;\n  q[0] = q1 * norm;\n  q[1] = q2 * norm;\n  q[2] = q3 * norm;\n  q[3] = q4 * norm;\n}\n\n\n\n// Similar to Madgwick scheme but uses proportional and integral filtering on\n// the error between estimated reference vectors and measured ones.\nvoid MahonyQuaternionUpdate(float ax, float ay, float az, float gx, float gy, float gz, float mx, float my, float mz, float deltat)\n{\n  // short name local variable for readability\n  float q1 = q[0], q2 = q[1], q3 = q[2], q4 = q[3];\n  float norm;\n  float hx, hy, bx, bz;\n  float vx, vy, vz, wx, wy, wz;\n  float ex, ey, ez;\n  float pa, pb, pc;\n\n  // Auxiliary variables to avoid repeated arithmetic\n  float q1q1 = q1 * q1;\n  float q1q2 = q1 * q2;\n  float q1q3 = q1 * q3;\n  float q1q4 = q1 * q4;\n  float q2q2 = q2 * q2;\n  float q2q3 = q2 * q3;\n  float q2q4 = q2 * q4;\n  float q3q3 = q3 * q3;\n  float q3q4 = q3 * q4;\n  float q4q4 = q4 * q4;\n\n  // Normalise accelerometer measurement\n  norm = sqrt(ax * ax + ay * ay + az * az);\n  if (norm == 0.0f) return; // Handle NaN\n  norm = 1.0f / norm;       // Use reciprocal for division\n  ax *= norm;\n  ay *= norm;\n  az *= norm;\n\n  // Normalise magnetometer measurement\n  norm = sqrt(mx * mx + my * my + mz * mz);\n  if (norm == 0.0f) return; // Handle NaN\n  norm = 1.0f / norm;       // Use reciprocal for division\n  mx *= norm;\n  my *= norm;\n  mz *= norm;\n\n  // Reference direction of Earth's magnetic field\n  hx = 2.0f * mx * (0.5f - q3q3 - q4q4) + 2.0f * my * (q2q3 - q1q4) + 2.0f * mz * (q2q4 + q1q3);\n  hy = 2.0f * mx * (q2q3 + q1q4) + 2.0f * my * (0.5f - q2q2 - q4q4) + 2.0f * mz * (q3q4 - q1q2);\n  bx = sqrt((hx * hx) + (hy * hy));\n  bz = 2.0f * mx * (q2q4 - q1q3) + 2.0f * my * (q3q4 + q1q2) + 2.0f * mz * (0.5f - q2q2 - q3q3);\n\n  // Estimated direction of gravity and magnetic field\n  vx = 2.0f * (q2q4 - q1q3);\n  vy = 2.0f * (q1q2 + q3q4);\n  vz = q1q1 - q2q2 - q3q3 + q4q4;\n  wx = 2.0f * bx * (0.5f - q3q3 - q4q4) + 2.0f * bz * (q2q4 - q1q3);\n  wy = 2.0f * bx * (q2q3 - q1q4) + 2.0f * bz * (q1q2 + q3q4);\n  wz = 2.0f * bx * (q1q3 + q2q4) + 2.0f * bz * (0.5f - q2q2 - q3q3);\n\n  // Error is cross product between estimated direction and measured direction of gravity\n  ex = (ay * vz - az * vy) + (my * wz - mz * wy);\n  ey = (az * vx - ax * vz) + (mz * wx - mx * wz);\n  ez = (ax * vy - ay * vx) + (mx * wy - my * wx);\n  if (Ki > 0.0f)\n  {\n    eInt[0] += ex;      // accumulate integral error\n    eInt[1] += ey;\n    eInt[2] += ez;\n  }\n  else\n  {\n    eInt[0] = 0.0f;     // prevent integral wind up\n    eInt[1] = 0.0f;\n    eInt[2] = 0.0f;\n  }\n\n  // Apply feedback terms\n  gx = gx + Kp * ex + Ki * eInt[0];\n  gy = gy + Kp * ey + Ki * eInt[1];\n  gz = gz + Kp * ez + Ki * eInt[2];\n \n  // Integrate rate of change of quaternion\n  pa = q2;\n  pb = q3;\n  pc = q4;\n  q1 = q1 + (-q2 * gx - q3 * gy - q4 * gz) * (0.5f * deltat);\n  q2 = pa + (q1 * gx + pb * gz - pc * gy) * (0.5f * deltat);\n  q3 = pb + (q1 * gy - pa * gz + pc * gx) * (0.5f * deltat);\n  q4 = pc + (q1 * gz + pa * gy - pb * gx) * (0.5f * deltat);\n\n  // Normalise quaternion\n  norm = sqrt(q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4);\n  norm = 1.0f / norm;\n  q[0] = q1 * norm;\n  q[1] = q2 * norm;\n  q[2] = q3 * norm;\n  q[3] = q4 * norm;\n}\n\nconst float * getQ () { return q; }\n"},{"name":"rtiostream_serial_daemon.cpp","type":"source","group":"legacy","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/../../../Documents/MATLAB/SupportPackages/R2025b/toolbox/target/supportpackages/arduinotarget/src","tag":"","groupDisplay":"Other files","code":"/*\n * File: rtiostream_serial.cpp\n * Copyright 2011-2024 The MathWorks, Inc.\n */\n\n#include \"Arduino.h\"\n#include \"MW_target_hardware_resources.h\"\n#include \"io_wrappers.h\"\n\n#ifndef _rtiostream\n\nextern \"C\" {                 /* sbcheck:ok:extern_c */\n#include \"rtiostream.h\"\nvoid rtIOStreamResync(void);\n}\n#define _rtiostream\n#endif\n\nextern \"C\" void __cxa_pure_virtual(void);   /* sbcheck:ok:extern_c */\n\n#if defined(XCP_CALIBRATION_SUPPORT)\n    #define SYNC_BYTE 0x02\n#else\n    #define SYNC_BYTE 'e'\n#endif\n\nvolatile boolean receivedSyncByteE = false;\n\nvoid rtIOStreamResync(){\n    receivedSyncByteE = false;\n}\n\n/* Function: rtIOStreamOpen =================================================\n * Abstract:\n *  Open the connection with the target.\n */\nint rtIOStreamOpen(int argc, void * argv[])\n{\n    /* ASCII character a is 65 */\n    #define RTIOSTREAM_OPEN_COMPLETE 65\n    static const uint8_t init_complete = RTIOSTREAM_OPEN_COMPLETE;\n    \n    int result = RTIOSTREAM_NO_ERROR;\n    int flushedData;\n    \n//     #ifndef MW_PIL_ARUDINOSERIAL //commented due to Serial1 not working with external mode in MKR1000\n//     init();\n//     #endif\n\n    #if defined(MW_PIL_ARUDINOSERIAL)\n        #if defined(MW_RTIO_SERIAL0)\n            Serial_begin(0, MW_PIL_SERIAL_BAUDRATE, SERIAL_8N1);\n        #elif defined(MW_RTIO_SERIAL1)\n            Serial_begin(1, MW_PIL_SERIAL_BAUDRATE, SERIAL_8N1);\n        #elif defined(MW_RTIO_SERIAL2)\n            Serial_begin(2, MW_PIL_SERIAL_BAUDRATE, SERIAL_8N1);\n        #elif defined(MW_RTIO_SERIAL3)\n            Serial_begin(3, MW_PIL_SERIAL_BAUDRATE, SERIAL_8N1);\n        #else\n            Serial_begin(0, MW_PIL_SERIAL_BAUDRATE, SERIAL_8N1);\n        #endif\n\n        \n        /* At high baud rates (i.e. 115200), the Arduino is receiving an \n         * initial byte of spurious data (0xF0 / 240) when opening a connection\n         * even though the host has not transmitted this data! This is causing\n         * an issue for PIL to read wrong init bytes at the beginning and\n         * loosing sync with host. Adding delay of 1 sec to wait for host to\n         * open the connection and then flush the spurious data from receive\n         * buffer. A delay of 5Sec(rtiostream postopenpause) is given on the\n         * host between opening the connection and init bytes.\n        */ \n        delay(1000);\n    #else\n        #if defined(MW_RTIO_SERIAL0)\n            Serial_begin(0, MW_EXTMODE_COMPORTBAUD, SERIAL_8N1);\n        #elif defined(MW_RTIO_SERIAL1)\n            Serial_begin(1, MW_EXTMODE_COMPORTBAUD, SERIAL_8N1);\n        #elif defined(MW_RTIO_SERIAL2)\n            Serial_begin(2, MW_EXTMODE_COMPORTBAUD, SERIAL_8N1);\n        #elif defined(MW_RTIO_SERIAL3)\n            Serial_begin(3, MW_EXTMODE_COMPORTBAUD, SERIAL_8N1);\n        #elif defined(MW_RTIO_SERIAL4)\n            Serial_begin(4, MW_EXTMODE_COMPORTBAUD, SERIAL_8N1);\n        #elif defined(MW_RTIO_SERIAL5)\n            Serial_begin(5, MW_EXTMODE_COMPORTBAUD, SERIAL_8N1);\n        #elif defined(MW_RTIO_SERIAL6)\n            Serial_begin(6, MW_EXTMODE_COMPORTBAUD, SERIAL_8N1);\n        #elif defined(MW_RTIO_SERIAL7)\n            Serial_begin(7, MW_EXTMODE_COMPORTBAUD, SERIAL_8N1);\n        #elif defined(MW_RTIO_SERIAL8)\n            Serial_begin(8, MW_EXTMODE_COMPORTBAUD, SERIAL_8N1);\n        #else\n            Serial_begin(0, MW_EXTMODE_COMPORTBAUD, SERIAL_8N1);\n        #endif\n    #endif\n   \n    /* Flush out the serial receive buffer when opening a connection. This\n     * works around an issue we've noticed with Arduino at high baud rates.\n     * At high baud rates (i.e. 115200), the Arduino is receiving an \n     * initial byte of spurious data (0xF0 / 240) even though the host has\n     * not transmitted this data! This may cause an issue for PIL and \n     * External mode during the handshaking process.\n     */\n        #if defined(MW_RTIO_SERIAL0)\n            while (Serial.available()) {\n                flushedData = Serial.read();\n            }\n        #elif defined(MW_RTIO_SERIAL1)\n            while (Serial1.available()) {\n                flushedData = Serial1.read();\n            }\n        #elif defined(MW_RTIO_SERIAL2)\n            while (Serial2.available()) {\n                flushedData = Serial2.read();\n            }\n        #elif defined(MW_RTIO_SERIAL3)\n            while (Serial3.available()) {\n                flushedData = Serial3.read();\n            }\n        #elif defined(MW_RTIO_SERIAL4)\n            while (Serial4.available()) {\n                flushedData = Serial4.read();\n            }\n        #elif defined(MW_RTIO_SERIAL5)\n            while (Serial5.available()) {\n                flushedData = Serial5.read();\n            }\n        #elif defined(MW_RTIO_SERIAL6)\n            while (Serial6.available()) {\n                flushedData = Serial6.read();\n            }\n        #elif defined(MW_RTIO_SERIAL7)\n            while (Serial7.available()) {\n                flushedData = Serial7.read();\n            }\n        #elif defined(MW_RTIO_SERIAL8)\n            while (Serial8.available()) {\n                flushedData = Serial8.read();\n            }\n        #else\n            while (Serial.available()) {\n                flushedData = Serial.read();\n            }\n        #endif\n   \n\n    return result;\n}\n\n/* Function: rtIOStreamSend =====================================================\n * Abstract:\n *  Sends the specified number of bytes on the serial line. Returns the number of\n *  bytes sent (if successful) or a negative value if an error occurred.\n */\nint rtIOStreamSend(\n    int          streamID,\n    const void * src,\n    size_t       size,\n    size_t     * sizeSent)\n{\n    #if defined(MW_RTIO_SERIAL0)\n        Serial.write( (const uint8_t *)src, (int16_t)size);\n    #elif defined(MW_RTIO_SERIAL1)\n        Serial1.write( (const uint8_t *)src, (int16_t)size);\n    #elif defined(MW_RTIO_SERIAL2)\n        Serial2.write( (const uint8_t *)src, (int16_t)size);\n    #elif defined(MW_RTIO_SERIAL3)\n        Serial3.write( (const uint8_t *)src, (int16_t)size);\n    #elif defined(MW_RTIO_SERIAL4)\n        Serial4.write( (const uint8_t *)src, (int16_t)size);\n    #elif defined(MW_RTIO_SERIAL5)\n        Serial5.write( (const uint8_t *)src, (int16_t)size);\n    #elif defined(MW_RTIO_SERIAL6)\n        Serial6.write( (const uint8_t *)src, (int16_t)size);\n    #elif defined(MW_RTIO_SERIAL7)\n        Serial7.write( (const uint8_t *)src, (int16_t)size);\n    #elif defined(MW_RTIO_SERIAL8)\n        Serial8.write( (const uint8_t *)src, (int16_t)size);\n    #else\n        Serial.write( (const uint8_t *)src, (int16_t)size);\n    #endif\n    \n    \n    *sizeSent = size;\n     \n    return RTIOSTREAM_NO_ERROR;\n}\n\n/* Function: rtIOStreamRecv ================================================\n * Abstract: receive data\n *\n */\nint rtIOStreamRecv(\n    int      streamID,\n    void   * dst,\n    size_t   size,\n    size_t * sizeRecvd)\n{\n    int data;\n    uint8_t * ptr = (uint8_t *)dst;\n  \n    *sizeRecvd = 0U;\n    #if defined(MW_RTIO_SERIAL0)\n            if (!Serial.available()) {\n                return RTIOSTREAM_NO_ERROR;\n            }\n        \n            while( !receivedSyncByteE ){\n                data = Serial.read();\n                if(data == SYNC_BYTE){\n                    receivedSyncByteE = true;\n                    *ptr++ = (uint8_t)data;\n                    (*sizeRecvd)++;\n                }\n            }\n        \n            while ((*sizeRecvd < size)) {\n                data = Serial.read();\n                if (data!=-1) {\n                    *ptr++ = (uint8_t) data;\n                    (*sizeRecvd)++;\n                }\n            }\n    #elif defined(MW_RTIO_SERIAL1)\n            if (!Serial1.available()) {\n                return RTIOSTREAM_NO_ERROR;\n            }\n        \n            while( !receivedSyncByteE ){\n                data = Serial1.read();\n                if(data == SYNC_BYTE){\n                    receivedSyncByteE = true;\n                    *ptr++ = (uint8_t)data;\n                    (*sizeRecvd)++;\n                }\n            }\n        \n            while ((*sizeRecvd < size)) {\n                data = Serial1.read();\n                if (data!=-1) {\n                    *ptr++ = (uint8_t) data;\n                    (*sizeRecvd)++;\n                }\n            }\n    #elif defined(MW_RTIO_SERIAL2)\n            if (!Serial2.available()) {\n                return RTIOSTREAM_NO_ERROR;\n            }\n        \n            while( !receivedSyncByteE ){\n                data = Serial2.read();\n                if(data == SYNC_BYTE){\n                    receivedSyncByteE = true;\n                    *ptr++ = (uint8_t)data;\n                    (*sizeRecvd)++;\n                }\n            }\n        \n            while ((*sizeRecvd < size)) {\n                data = Serial2.read();\n                if (data!=-1) {\n                    *ptr++ = (uint8_t) data;\n                    (*sizeRecvd)++;\n                }\n            }\n    #elif defined(MW_RTIO_SERIAL3)\n            if (!Serial3.available()) {\n                return RTIOSTREAM_NO_ERROR;\n            }\n        \n            while( !receivedSyncByteE ){\n                data = Serial3.read();\n                if(data == SYNC_BYTE){\n                    receivedSyncByteE = true;\n                    *ptr++ = (uint8_t)data;\n                    (*sizeRecvd)++;\n                }\n            }\n        \n            while ((*sizeRecvd < size)) {\n                data = Serial3.read();\n                if (data!=-1) {\n                    *ptr++ = (uint8_t) data;\n                    (*sizeRecvd)++;\n                }\n            }\n    #elif defined(MW_RTIO_SERIAL4)\n            if (!Serial4.available()) {\n                return RTIOSTREAM_NO_ERROR;\n            }\n        \n            while( !receivedSyncByteE ){\n                data = Serial4.read();\n                if(data == SYNC_BYTE){\n                    receivedSyncByteE = true;\n                    *ptr++ = (uint8_t)data;\n                    (*sizeRecvd)++;\n                }\n            }\n        \n            while ((*sizeRecvd < size)) {\n                data = Serial4.read();\n                if (data!=-1) {\n                    *ptr++ = (uint8_t) data;\n                    (*sizeRecvd)++;\n                }\n            }\n      #elif defined(MW_RTIO_SERIAL5)\n            if (!Serial5.available()) {\n                return RTIOSTREAM_NO_ERROR;\n            }\n        \n            while( !receivedSyncByteE ){\n                data = Serial5.read();\n                if(data == SYNC_BYTE){\n                    receivedSyncByteE = true;\n                    *ptr++ = (uint8_t)data;\n                    (*sizeRecvd)++;\n                }\n            }\n        \n            while ((*sizeRecvd < size)) {\n                data = Serial5.read();\n                if (data!=-1) {\n                    *ptr++ = (uint8_t) data;\n                    (*sizeRecvd)++;\n                }\n            }\n     #elif defined(MW_RTIO_SERIAL6)\n            if (!Serial6.available()) {\n                return RTIOSTREAM_NO_ERROR;\n            }\n        \n            while( !receivedSyncByteE ){\n                data = Serial6.read();\n                if(data == SYNC_BYTE){\n                    receivedSyncByteE = true;\n                    *ptr++ = (uint8_t)data;\n                    (*sizeRecvd)++;\n                }\n            }\n        \n            while ((*sizeRecvd < size)) {\n                data = Serial6.read();\n                if (data!=-1) {\n                    *ptr++ = (uint8_t) data;\n                    (*sizeRecvd)++;\n                }\n            }\n      #elif defined(MW_RTIO_SERIAL7)\n            if (!Serial7.available()) {\n                return RTIOSTREAM_NO_ERROR;\n            }\n        \n            while( !receivedSyncByteE ){\n                data = Serial7.read();\n                if(data == SYNC_BYTE){\n                    receivedSyncByteE = true;\n                    *ptr++ = (uint8_t)data;\n                    (*sizeRecvd)++;\n                }\n            }\n        \n            while ((*sizeRecvd < size)) {\n                data = Serial7.read();\n                if (data!=-1) {\n                    *ptr++ = (uint8_t) data;\n                    (*sizeRecvd)++;\n                }\n            }\n     #elif defined(MW_RTIO_SERIAL8)\n            if (!Serial8.available()) {\n                return RTIOSTREAM_NO_ERROR;\n            }\n        \n            while( !receivedSyncByteE ){\n                data = Serial8.read();\n                if(data == SYNC_BYTE){\n                    receivedSyncByteE = true;\n                    *ptr++ = (uint8_t)data;\n                    (*sizeRecvd)++;\n                }\n            }\n        \n            while ((*sizeRecvd < size)) {\n                data = Serial8.read();\n                if (data!=-1) {\n                    *ptr++ = (uint8_t) data;\n                    (*sizeRecvd)++;\n                }\n            }\n    #else\n            if (!Serial.available()) {\n                return RTIOSTREAM_NO_ERROR;\n            }\n        \n            while( !receivedSyncByteE ){\n                data = Serial.read();\n                if(data == SYNC_BYTE){\n                    receivedSyncByteE = true;\n                    *ptr++ = (uint8_t)data;\n                    (*sizeRecvd)++;\n                }\n            }\n        \n            while ((*sizeRecvd < size)) {\n                data = Serial.read();\n                if (data!=-1) {\n                    *ptr++ = (uint8_t) data;\n                    (*sizeRecvd)++;\n                }\n            }\n    #endif\n\n   \n    \n    return RTIOSTREAM_NO_ERROR;\n}\n\n/* Function: rtIOStreamClose ================================================\n * Abstract: close the connection.\n * For External mode over serial, Arduino MKR and its variants require\n * a flush out the serial receive buffer. This is done to get the last \n * acknowledgment \n *\n */\nint rtIOStreamClose(int streamID)\n{\n#if (defined(ARDUINO_ARDUINO_NANO33BLE))\n    #if defined(MW_RTOS) && (MW_RTOS == 'Baremetal')\n        //Do not let the program terminate\n        while(1);\n    #endif\n#else\n    delay(1000);\n    #if defined(ARDUINO_VIRTUAL_COM_PORT)\n        int flushedData;\n        while (Serial.available()) {\n            flushedData = Serial.read();\n        }\n    #endif\n#endif\n    return RTIOSTREAM_NO_ERROR;\n}"},{"name":"twi.c","type":"source","group":"legacy","path":"/home/emil/Skrivbord/r7003/LabB_CheckCommunications_ert_rtw/../../../Documents/MATLAB/SupportPackages/R2025b/3P.instrset/arduinoide.instrset/aCLI/data/packages/arduino/hardware/avr/1.8.3/libraries/Wire/src/utility","tag":"","groupDisplay":"Other files","code":"/*\n  twi.c - TWI/I2C library for Wiring & Arduino\n  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n  Modified 2012 by Todd Krein (todd@krein.org) to implement repeated starts\n  Modified 2020 by Greyson Christoforo (grey@christoforo.net) to implement timeouts\n*/\n\n#include <math.h>\n#include <stdlib.h>\n#include <inttypes.h>\n#include <avr/io.h>\n#include <avr/interrupt.h>\n#include <util/delay.h>\n#include <compat/twi.h>\n#include \"Arduino.h\" // for digitalWrite and micros\n\n#ifndef cbi\n#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))\n#endif\n\n#ifndef sbi\n#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))\n#endif\n\n#include \"pins_arduino.h\"\n#include \"twi.h\"\n\nstatic volatile uint8_t twi_state;\nstatic volatile uint8_t twi_slarw;\nstatic volatile uint8_t twi_sendStop;\t\t\t// should the transaction end with a stop\nstatic volatile uint8_t twi_inRepStart;\t\t\t// in the middle of a repeated start\n\n// twi_timeout_us > 0 prevents the code from getting stuck in various while loops here\n// if twi_timeout_us == 0 then timeout checking is disabled (the previous Wire lib behavior)\n// at some point in the future, the default twi_timeout_us value could become 25000\n// and twi_do_reset_on_timeout could become true\n// to conform to the SMBus standard\n// http://smbus.org/specs/SMBus_3_1_20180319.pdf\nstatic volatile uint32_t twi_timeout_us = 0ul;\nstatic volatile bool twi_timed_out_flag = false;  // a timeout has been seen\nstatic volatile bool twi_do_reset_on_timeout = false;  // reset the TWI registers on timeout\n\nstatic void (*twi_onSlaveTransmit)(void);\nstatic void (*twi_onSlaveReceive)(uint8_t*, int);\n\nstatic uint8_t twi_masterBuffer[TWI_BUFFER_LENGTH];\nstatic volatile uint8_t twi_masterBufferIndex;\nstatic volatile uint8_t twi_masterBufferLength;\n\nstatic uint8_t twi_txBuffer[TWI_BUFFER_LENGTH];\nstatic volatile uint8_t twi_txBufferIndex;\nstatic volatile uint8_t twi_txBufferLength;\n\nstatic uint8_t twi_rxBuffer[TWI_BUFFER_LENGTH];\nstatic volatile uint8_t twi_rxBufferIndex;\n\nstatic volatile uint8_t twi_error;\n\n/* \n * Function twi_init\n * Desc     readys twi pins and sets twi bitrate\n * Input    none\n * Output   none\n */\nvoid twi_init(void)\n{\n  // initialize state\n  twi_state = TWI_READY;\n  twi_sendStop = true;\t\t// default value\n  twi_inRepStart = false;\n  \n  // activate internal pullups for twi.\n  digitalWrite(SDA, 1);\n  digitalWrite(SCL, 1);\n\n  // initialize twi prescaler and bit rate\n  cbi(TWSR, TWPS0);\n  cbi(TWSR, TWPS1);\n  TWBR = ((F_CPU / TWI_FREQ) - 16) / 2;\n\n  /* twi bit rate formula from atmega128 manual pg 204\n  SCL Frequency = CPU Clock Frequency / (16 + (2 * TWBR))\n  note: TWBR should be 10 or higher for master mode\n  It is 72 for a 16mhz Wiring board with 100kHz TWI */\n\n  // enable twi module, acks, and twi interrupt\n  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA);\n}\n\n/* \n * Function twi_disable\n * Desc     disables twi pins\n * Input    none\n * Output   none\n */\nvoid twi_disable(void)\n{\n  // disable twi module, acks, and twi interrupt\n  TWCR &= ~(_BV(TWEN) | _BV(TWIE) | _BV(TWEA));\n\n  // deactivate internal pullups for twi.\n  digitalWrite(SDA, 0);\n  digitalWrite(SCL, 0);\n}\n\n/* \n * Function twi_slaveInit\n * Desc     sets slave address and enables interrupt\n * Input    none\n * Output   none\n */\nvoid twi_setAddress(uint8_t address)\n{\n  // set twi slave address (skip over TWGCE bit)\n  TWAR = address << 1;\n}\n\n/* \n * Function twi_setClock\n * Desc     sets twi bit rate\n * Input    Clock Frequency\n * Output   none\n */\nvoid twi_setFrequency(uint32_t frequency)\n{\n  TWBR = ((F_CPU / frequency) - 16) / 2;\n  \n  /* twi bit rate formula from atmega128 manual pg 204\n  SCL Frequency = CPU Clock Frequency / (16 + (2 * TWBR))\n  note: TWBR should be 10 or higher for master mode\n  It is 72 for a 16mhz Wiring board with 100kHz TWI */\n}\n\n/* \n * Function twi_readFrom\n * Desc     attempts to become twi bus master and read a\n *          series of bytes from a device on the bus\n * Input    address: 7bit i2c device address\n *          data: pointer to byte array\n *          length: number of bytes to read into array\n *          sendStop: Boolean indicating whether to send a stop at the end\n * Output   number of bytes read\n */\nuint8_t twi_readFrom(uint8_t address, uint8_t* data, uint8_t length, uint8_t sendStop)\n{\n  uint8_t i;\n\n  // ensure data will fit into buffer\n  if(TWI_BUFFER_LENGTH < length){\n    return 0;\n  }\n\n  // wait until twi is ready, become master receiver\n  uint32_t startMicros = micros();\n  while(TWI_READY != twi_state){\n    if((twi_timeout_us > 0ul) && ((micros() - startMicros) > twi_timeout_us)) {\n      twi_handleTimeout(twi_do_reset_on_timeout);\n      return 0;\n    }\n  }\n  twi_state = TWI_MRX;\n  twi_sendStop = sendStop;\n  // reset error state (0xFF.. no error occured)\n  twi_error = 0xFF;\n\n  // initialize buffer iteration vars\n  twi_masterBufferIndex = 0;\n  twi_masterBufferLength = length-1;  // This is not intuitive, read on...\n  // On receive, the previously configured ACK/NACK setting is transmitted in\n  // response to the received byte before the interrupt is signalled. \n  // Therefor we must actually set NACK when the _next_ to last byte is\n  // received, causing that NACK to be sent in response to receiving the last\n  // expected byte of data.\n\n  // build sla+w, slave device address + w bit\n  twi_slarw = TW_READ;\n  twi_slarw |= address << 1;\n\n  if (true == twi_inRepStart) {\n    // if we're in the repeated start state, then we've already sent the start,\n    // (@@@ we hope), and the TWI statemachine is just waiting for the address byte.\n    // We need to remove ourselves from the repeated start state before we enable interrupts,\n    // since the ISR is ASYNC, and we could get confused if we hit the ISR before cleaning\n    // up. Also, don't enable the START interrupt. There may be one pending from the \n    // repeated start that we sent ourselves, and that would really confuse things.\n    twi_inRepStart = false;\t\t\t// remember, we're dealing with an ASYNC ISR\n    startMicros = micros();\n    do {\n      TWDR = twi_slarw;\n      if((twi_timeout_us > 0ul) && ((micros() - startMicros) > twi_timeout_us)) {\n        twi_handleTimeout(twi_do_reset_on_timeout);\n        return 0;\n      }\n    } while(TWCR & _BV(TWWC));\n    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE);\t// enable INTs, but not START\n  } else {\n    // send start condition\n    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTA);\n  }\n\n  // wait for read operation to complete\n  startMicros = micros();\n  while(TWI_MRX == twi_state){\n    if((twi_timeout_us > 0ul) && ((micros() - startMicros) > twi_timeout_us)) {\n      twi_handleTimeout(twi_do_reset_on_timeout);\n      return 0;\n    }\n  }\n\n  if (twi_masterBufferIndex < length) {\n    length = twi_masterBufferIndex;\n  }\n\n  // copy twi buffer to data\n  for(i = 0; i < length; ++i){\n    data[i] = twi_masterBuffer[i];\n  }\n\n  return length;\n}\n\n/* \n * Function twi_writeTo\n * Desc     attempts to become twi bus master and write a\n *          series of bytes to a device on the bus\n * Input    address: 7bit i2c device address\n *          data: pointer to byte array\n *          length: number of bytes in array\n *          wait: boolean indicating to wait for write or not\n *          sendStop: boolean indicating whether or not to send a stop at the end\n * Output   0 .. success\n *          1 .. length to long for buffer\n *          2 .. address send, NACK received\n *          3 .. data send, NACK received\n *          4 .. other twi error (lost bus arbitration, bus error, ..)\n *          5 .. timeout\n */\nuint8_t twi_writeTo(uint8_t address, uint8_t* data, uint8_t length, uint8_t wait, uint8_t sendStop)\n{\n  uint8_t i;\n\n  // ensure data will fit into buffer\n  if(TWI_BUFFER_LENGTH < length){\n    return 1;\n  }\n\n  // wait until twi is ready, become master transmitter\n  uint32_t startMicros = micros();\n  while(TWI_READY != twi_state){\n    if((twi_timeout_us > 0ul) && ((micros() - startMicros) > twi_timeout_us)) {\n      twi_handleTimeout(twi_do_reset_on_timeout);\n      return (5);\n    }\n  }\n  twi_state = TWI_MTX;\n  twi_sendStop = sendStop;\n  // reset error state (0xFF.. no error occured)\n  twi_error = 0xFF;\n\n  // initialize buffer iteration vars\n  twi_masterBufferIndex = 0;\n  twi_masterBufferLength = length;\n  \n  // copy data to twi buffer\n  for(i = 0; i < length; ++i){\n    twi_masterBuffer[i] = data[i];\n  }\n  \n  // build sla+w, slave device address + w bit\n  twi_slarw = TW_WRITE;\n  twi_slarw |= address << 1;\n  \n  // if we're in a repeated start, then we've already sent the START\n  // in the ISR. Don't do it again.\n  //\n  if (true == twi_inRepStart) {\n    // if we're in the repeated start state, then we've already sent the start,\n    // (@@@ we hope), and the TWI statemachine is just waiting for the address byte.\n    // We need to remove ourselves from the repeated start state before we enable interrupts,\n    // since the ISR is ASYNC, and we could get confused if we hit the ISR before cleaning\n    // up. Also, don't enable the START interrupt. There may be one pending from the \n    // repeated start that we sent outselves, and that would really confuse things.\n    twi_inRepStart = false;\t\t\t// remember, we're dealing with an ASYNC ISR\n    startMicros = micros();\n    do {\n      TWDR = twi_slarw;\n      if((twi_timeout_us > 0ul) && ((micros() - startMicros) > twi_timeout_us)) {\n        twi_handleTimeout(twi_do_reset_on_timeout);\n        return (5);\n      }\n    } while(TWCR & _BV(TWWC));\n    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE);\t// enable INTs, but not START\n  } else {\n    // send start condition\n    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE) | _BV(TWSTA);\t// enable INTs\n  }\n\n  // wait for write operation to complete\n  startMicros = micros();\n  while(wait && (TWI_MTX == twi_state)){\n    if((twi_timeout_us > 0ul) && ((micros() - startMicros) > twi_timeout_us)) {\n      twi_handleTimeout(twi_do_reset_on_timeout);\n      return (5);\n    }\n  }\n  \n  if (twi_error == 0xFF)\n    return 0;\t// success\n  else if (twi_error == TW_MT_SLA_NACK)\n    return 2;\t// error: address send, nack received\n  else if (twi_error == TW_MT_DATA_NACK)\n    return 3;\t// error: data send, nack received\n  else\n    return 4;\t// other twi error\n}\n\n/* \n * Function twi_transmit\n * Desc     fills slave tx buffer with data\n *          must be called in slave tx event callback\n * Input    data: pointer to byte array\n *          length: number of bytes in array\n * Output   1 length too long for buffer\n *          2 not slave transmitter\n *          0 ok\n */\nuint8_t twi_transmit(const uint8_t* data, uint8_t length)\n{\n  uint8_t i;\n\n  // ensure data will fit into buffer\n  if(TWI_BUFFER_LENGTH < (twi_txBufferLength+length)){\n    return 1;\n  }\n  \n  // ensure we are currently a slave transmitter\n  if(TWI_STX != twi_state){\n    return 2;\n  }\n  \n  // set length and copy data into tx buffer\n  for(i = 0; i < length; ++i){\n    twi_txBuffer[twi_txBufferLength+i] = data[i];\n  }\n  twi_txBufferLength += length;\n  \n  return 0;\n}\n\n/* \n * Function twi_attachSlaveRxEvent\n * Desc     sets function called before a slave read operation\n * Input    function: callback function to use\n * Output   none\n */\nvoid twi_attachSlaveRxEvent( void (*function)(uint8_t*, int) )\n{\n  twi_onSlaveReceive = function;\n}\n\n/* \n * Function twi_attachSlaveTxEvent\n * Desc     sets function called before a slave write operation\n * Input    function: callback function to use\n * Output   none\n */\nvoid twi_attachSlaveTxEvent( void (*function)(void) )\n{\n  twi_onSlaveTransmit = function;\n}\n\n/* \n * Function twi_reply\n * Desc     sends byte or readys receive line\n * Input    ack: byte indicating to ack or to nack\n * Output   none\n */\nvoid twi_reply(uint8_t ack)\n{\n  // transmit master read ready signal, with or without ack\n  if(ack){\n    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);\n  }else{\n    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);\n  }\n}\n\n/* \n * Function twi_stop\n * Desc     relinquishes bus master status\n * Input    none\n * Output   none\n */\nvoid twi_stop(void)\n{\n  // send stop condition\n  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);\n\n  // wait for stop condition to be exectued on bus\n  // TWINT is not set after a stop condition!\n  // We cannot use micros() from an ISR, so approximate the timeout with cycle-counted delays\n  const uint8_t us_per_loop = 8;\n  uint32_t counter = (twi_timeout_us + us_per_loop - 1)/us_per_loop; // Round up\n  while(TWCR & _BV(TWSTO)){\n    if(twi_timeout_us > 0ul){\n      if (counter > 0ul){\n        _delay_us(10);\n        counter--;\n      } else {\n        twi_handleTimeout(twi_do_reset_on_timeout);\n        return;\n      }\n    }\n  }\n\n  // update twi state\n  twi_state = TWI_READY;\n}\n\n/* \n * Function twi_releaseBus\n * Desc     releases bus control\n * Input    none\n * Output   none\n */\nvoid twi_releaseBus(void)\n{\n  // release bus\n  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);\n\n  // update twi state\n  twi_state = TWI_READY;\n}\n\n/* \n * Function twi_setTimeoutInMicros\n * Desc     set a timeout for while loops that twi might get stuck in\n * Input    timeout value in microseconds (0 means never time out)\n * Input    reset_with_timeout: true causes timeout events to reset twi\n * Output   none\n */\nvoid twi_setTimeoutInMicros(uint32_t timeout, bool reset_with_timeout){\n  twi_timed_out_flag = false;\n  twi_timeout_us = timeout;\n  twi_do_reset_on_timeout = reset_with_timeout;\n}\n\n/* \n * Function twi_handleTimeout\n * Desc     this gets called whenever a while loop here has lasted longer than\n *          twi_timeout_us microseconds. always sets twi_timed_out_flag\n * Input    reset: true causes this function to reset the twi hardware interface\n * Output   none\n */\nvoid twi_handleTimeout(bool reset){\n  twi_timed_out_flag = true;\n\n  if (reset) {\n    // remember bitrate and address settings\n    uint8_t previous_TWBR = TWBR;\n    uint8_t previous_TWAR = TWAR;\n\n    // reset the interface\n    twi_disable();\n    twi_init();\n\n    // reapply the previous register values\n    TWAR = previous_TWAR;\n    TWBR = previous_TWBR;\n  }\n}\n\n/*\n * Function twi_manageTimeoutFlag\n * Desc     returns true if twi has seen a timeout\n *          optionally clears the timeout flag\n * Input    clear_flag: true if we should reset the hardware\n * Output   none\n */\nbool twi_manageTimeoutFlag(bool clear_flag){\n  bool flag = twi_timed_out_flag;\n  if (clear_flag){\n    twi_timed_out_flag = false;\n  }\n  return(flag);\n}\n\nISR(TWI_vect)\n{\n  switch(TW_STATUS){\n    // All Master\n    case TW_START:     // sent start condition\n    case TW_REP_START: // sent repeated start condition\n      // copy device address and r/w bit to output register and ack\n      TWDR = twi_slarw;\n      twi_reply(1);\n      break;\n\n    // Master Transmitter\n    case TW_MT_SLA_ACK:  // slave receiver acked address\n    case TW_MT_DATA_ACK: // slave receiver acked data\n      // if there is data to send, send it, otherwise stop \n      if(twi_masterBufferIndex < twi_masterBufferLength){\n        // copy data to output register and ack\n        TWDR = twi_masterBuffer[twi_masterBufferIndex++];\n        twi_reply(1);\n      }else{\n        if (twi_sendStop){\n          twi_stop();\n       } else {\n         twi_inRepStart = true;\t// we're gonna send the START\n         // don't enable the interrupt. We'll generate the start, but we\n         // avoid handling the interrupt until we're in the next transaction,\n         // at the point where we would normally issue the start.\n         TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;\n         twi_state = TWI_READY;\n        }\n      }\n      break;\n    case TW_MT_SLA_NACK:  // address sent, nack received\n      twi_error = TW_MT_SLA_NACK;\n      twi_stop();\n      break;\n    case TW_MT_DATA_NACK: // data sent, nack received\n      twi_error = TW_MT_DATA_NACK;\n      twi_stop();\n      break;\n    case TW_MT_ARB_LOST: // lost bus arbitration\n      twi_error = TW_MT_ARB_LOST;\n      twi_releaseBus();\n      break;\n\n    // Master Receiver\n    case TW_MR_DATA_ACK: // data received, ack sent\n      // put byte into buffer\n      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;\n      __attribute__ ((fallthrough));\n    case TW_MR_SLA_ACK:  // address sent, ack received\n      // ack if more bytes are expected, otherwise nack\n      if(twi_masterBufferIndex < twi_masterBufferLength){\n        twi_reply(1);\n      }else{\n        twi_reply(0);\n      }\n      break;\n    case TW_MR_DATA_NACK: // data received, nack sent\n      // put final byte into buffer\n      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;\n      if (twi_sendStop){\n        twi_stop();\n      } else {\n        twi_inRepStart = true;\t// we're gonna send the START\n        // don't enable the interrupt. We'll generate the start, but we\n        // avoid handling the interrupt until we're in the next transaction,\n        // at the point where we would normally issue the start.\n        TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;\n        twi_state = TWI_READY;\n      }\n      break;\n    case TW_MR_SLA_NACK: // address sent, nack received\n      twi_stop();\n      break;\n    // TW_MR_ARB_LOST handled by TW_MT_ARB_LOST case\n\n    // Slave Receiver\n    case TW_SR_SLA_ACK:   // addressed, returned ack\n    case TW_SR_GCALL_ACK: // addressed generally, returned ack\n    case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack\n    case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack\n      // enter slave receiver mode\n      twi_state = TWI_SRX;\n      // indicate that rx buffer can be overwritten and ack\n      twi_rxBufferIndex = 0;\n      twi_reply(1);\n      break;\n    case TW_SR_DATA_ACK:       // data received, returned ack\n    case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack\n      // if there is still room in the rx buffer\n      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){\n        // put byte in buffer and ack\n        twi_rxBuffer[twi_rxBufferIndex++] = TWDR;\n        twi_reply(1);\n      }else{\n        // otherwise nack\n        twi_reply(0);\n      }\n      break;\n    case TW_SR_STOP: // stop or repeated start condition received\n      // ack future responses and leave slave receiver state\n      twi_releaseBus();\n      // put a null char after data if there's room\n      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){\n        twi_rxBuffer[twi_rxBufferIndex] = '\\0';\n      }\n      // callback to user defined callback\n      twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);\n      // since we submit rx buffer to \"wire\" library, we can reset it\n      twi_rxBufferIndex = 0;\n      break;\n    case TW_SR_DATA_NACK:       // data received, returned nack\n    case TW_SR_GCALL_DATA_NACK: // data received generally, returned nack\n      // nack back at master\n      twi_reply(0);\n      break;\n    \n    // Slave Transmitter\n    case TW_ST_SLA_ACK:          // addressed, returned ack\n    case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack\n      // enter slave transmitter mode\n      twi_state = TWI_STX;\n      // ready the tx buffer index for iteration\n      twi_txBufferIndex = 0;\n      // set tx buffer length to be zero, to verify if user changes it\n      twi_txBufferLength = 0;\n      // request for txBuffer to be filled and length to be set\n      // note: user must call twi_transmit(bytes, length) to do this\n      twi_onSlaveTransmit();\n      // if they didn't change buffer & length, initialize it\n      if(0 == twi_txBufferLength){\n        twi_txBufferLength = 1;\n        twi_txBuffer[0] = 0x00;\n      }\n      __attribute__ ((fallthrough));\t\t  \n      // transmit first byte from buffer, fall\n    case TW_ST_DATA_ACK: // byte sent, ack returned\n      // copy data to output register\n      TWDR = twi_txBuffer[twi_txBufferIndex++];\n      // if there is more to send, ack, otherwise nack\n      if(twi_txBufferIndex < twi_txBufferLength){\n        twi_reply(1);\n      }else{\n        twi_reply(0);\n      }\n      break;\n    case TW_ST_DATA_NACK: // received nack, we are done \n    case TW_ST_LAST_DATA: // received ack, but we are done already!\n      // ack future responses\n      twi_reply(1);\n      // leave slave receiver state\n      twi_state = TWI_READY;\n      break;\n\n    // All\n    case TW_NO_INFO:   // no state information\n      break;\n    case TW_BUS_ERROR: // bus error, illegal stop/start\n      twi_error = TW_BUS_ERROR;\n      twi_stop();\n      break;\n  }\n}\n"},{"name":"xcp.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2025b/toolbox/coder/xcp/src/target/server/protocol/src","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2023 The MathWorks, Inc.\n*\n* File: xcp.c\n*\n* Abstract:\n*  Implementation of XCP Protocol Layer\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp.h\"\n#include \"xcp_internal.h\"\n#include \"xcp_transport_internal.h\"\n#include \"xcp_cfg.h\"\n#include \"xcp_types.h\"\n#include \"xcp_standard.h\"\n#include \"xcp_daq.h\"\n#include \"xcp_calibration.h\"\n#include \"xcp_mem.h\"\n\n\n/*****************************************************************************\n    Internal Global variables\n******************************************************************************/\n/* Initialization status */\nstatic boolean_T initialized = false;\n\n/** Current Status of the XCP Server according to the Protocol Layer */\nstatic XcpStatus xcpStatus = XCP_DISCONNECTED;\n\n/** Current Session Status of the XCP Server according to the Protocol Layer\n(see XCP Session Status bit masks) */\nstatic uint8_T xcpSessionStatus = 0;\n\n/** XCP Server Resource Protection Status (see XCP Resource bit masks) */\nstatic uint8_T xcpResourceProtectionStatus = 0;\n\n/** XCP Session configuration Id\n@note xcpSessionConfigurationId has to be set with an XCP SET_REQUEST\n      before a STORE_DAQ_REQ set. This allows the client device to verify that\n      automatically started DAQ lists contain the expected data transfer\n      configuration.\n      However the (optional) SET_REQUEST command is not supported at the\n      moment, so this value is hard-coded to 0 and never changed. */\nstatic uint16_T xcpSessionConfigurationId = 0;\n\n/** This table contains the list of XcpPacketLookupFunction to be used\n    (for each packets group) to get access to the corresponding\n    Packet Input and Output handlers */\nstatic XcpPacketLookupFunction groupPacketLookup[XCP_PACKETS_GROUP_NUMBER];\n\n/*****************************************************************************\n    Internal Functions\n******************************************************************************/\n/** Free the msgBuffer and allocate a new buffer to host a XCP packet of newPacketSize */\nstatic XcpErrorCode msgBufferRealloc(void **msgBuffer, size_t *msgBufferSize, size_t *packetOffset, size_t newPacketSize)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    xcpPoolId_T reservedPoolId = xcpTransportCtoReservedMemPoolId();\n\n    /* Free the original buffer */\n    xcpMemFree(*msgBuffer);\n\n    /* Allocate a new buffer with the proper size */\n    *msgBufferSize = xcpTransportMsgBufferSize(newPacketSize, XCP_CTO);\n    *packetOffset = xcpTransportPacketOffset();\n\n    if (*msgBufferSize > 0) {\n        /* Using a reserved memory pool, to guarantee that the reply\n           gets always delivered to the XCP Client */\n        *msgBuffer = xcpMemAllocFromPool(reservedPoolId, *msgBufferSize);\n        if (*msgBuffer == NULL) {\n            errorCode = XCP_NO_MEMORY;\n        }\n    }\n    else {\n        errorCode = XCP_INV_SIZE;\n    }\n\n    return errorCode;\n}\n\n/** Input Packet Handler to be used for packets that need to be discarded */\nstatic XcpProtoErrorCode discardInputPacketHandler(void   *msgBuffer,\n                                                   size_t  xcpPacketOffset,\n                                                   size_t *outputPacketSize)\n{\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    XCP_PRINTF(\"Detected attempt to send packet ID %xH when the XCP connection has not been established\\n\", \n               *((uint8_T *) msgBuffer + xcpPacketOffset));\n\n    if (msgBuffer != NULL) {\n        xcpMemFree(msgBuffer);\n    }\n\n    *outputPacketSize = 0;\n\n    return XCP_PROTO_SUCCESS;\n}\n\n/** Input Packet Handler to be used for unknown commands */\nstatic XcpProtoErrorCode unknownInputPacketHandler(void   *msgBuffer,\n                                                   size_t  xcpPacketOffset,\n                                                   size_t *outputPacketSize)\n{\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    XCP_PRINTF(\"Packet ID  %xH is not supported at the moment\\n\",\n    *((uint8_T *) msgBuffer + xcpPacketOffset));\n\n    *outputPacketSize = XCP_ERROR_PACKET_SIZE_IN_BYTES;\n\n    return XCP_PROTO_CMD_UNKNOWN;\n}\n\n/** The function returns the Group Id corresponding to a given Packet ID */\nstatic XcpPacketsGroupIdType xcpGetPacketGroupID(uint8_T pid, uint8_T level1Code)\n{\n    XcpPacketsGroupIdType groupId = XCP_UNKNOWN_PACKET_GROUP_ID;\n\n    if ((pid >= XCP_STANDARD_PACKETS_ID_MIN) /* && (pid <= XCP_STANDARD_PACKETS_ID_MAX) */) {\n        groupId = XCP_STANDARD_PACKETS_ID;\n    }\n    else if ((pid >= XCP_CALIBRATION_PACKETS_ID_MIN) && (pid <= XCP_CALIBRATION_PACKETS_ID_MAX)) {\n        groupId = XCP_CALIBRATION_PACKETS_ID;\n    }\n    else if (((pid >= XCP_DAQ_PACKETS_ID_MIN) && (pid <= XCP_DAQ_PACKETS_ID_MAX)) ||\n             ((pid == XCP_PID_LEVEL1_COMMAND) && \n             (level1Code >= XCP_DAQ_LEVEL1_CODE_MIN) && (level1Code <= XCP_DAQ_LEVEL1_CODE_MAX))) {\n        groupId = XCP_DAQ_PACKETS_ID;\n    }\n    else if ((pid >= XCP_PROGRAM_PACKETS_ID_MIN) && (pid <= XCP_PROGRAM_PACKETS_ID_MAX)) {\n        groupId = XCP_PROGRAM_PACKETS_ID;\n    }\n\n    return groupId;\n}\n\n/** Identify the internal packet handler functions responsible for processing a specific XCP packet.\n    @note If the status is XCP_DISCONNECTED, no packets are accepted except XCP_PID_CONNECT\n          If the command is not supported, the XCP server has to reply with a ERR response packet\n          and ERR_CMD_UNKNOWN error code */\nstatic void xcpGetPacketHandlers(const uint8_T *packet,\n                                 size_t packetSize,\n                                 XcpInputPacketHandler  *inputHandler,\n                                 XcpOutputPacketHandler *outputHandler)\n{\n    /* uint8_T gets promoted to a higher data-type. On C2000, it is \n     * unsigned int. Since data is packed, a non-zero MSB in packet[0]\n     * can then make PID an invalid identifier. Explicitly mask to\n     * remove the upper byte if any.\n     */\n     const XcpLevel1CommandPacketFrame* command = (const XcpLevel1CommandPacketFrame*) packet;\n\n    uint8_T PID = command->PID; /* Retrieve Packet ID */\n    uint8_T level1CommandCode = 0;\n    if ((PID == XCP_PID_LEVEL1_COMMAND) && (packetSize > 1)) {\n        level1CommandCode = command->level1Code;\n    }\n\n    if (xcpStatus != XCP_DISCONNECTED) {\n        /* Check if the received XCP packet is supported and\n           retrieve the corresponding handler */\n        XcpPacketsGroupIdType groupId = xcpGetPacketGroupID(PID, level1CommandCode);\n        boolean_T found = false;\n\n        if (groupId != XCP_UNKNOWN_PACKET_GROUP_ID) {\n            XcpPacketLookupFunction getPacket = groupPacketLookup[groupId];\n            const XcpPacketHandlers *packetInfo = NULL;\n\n            if (getPacket != NULL) {\n                packetInfo = getPacket(PID);\n                found = (packetInfo != NULL);\n                if (found) {\n                    *inputHandler = packetInfo->inputHandler;\n                    *outputHandler = packetInfo->outputHandler;\n                }\n            }\n        }\n\n        if (!found) {\n            /* Packet is not supported*/\n            *inputHandler = unknownInputPacketHandler;\n            *outputHandler = genericOutputPacketHandler;\n        }\n    }\n    else {\n        /* If the XCP Server is in the XCP_DISCONNECTED status,\n        * no other XCP packets are accepted except XCP_PID_CONNECT */\n        if (PID == XCP_PID_CONNECT) {\n            XcpPacketLookupFunction getPacket = groupPacketLookup[XCP_STANDARD_PACKETS_ID];\n\n            *inputHandler = NULL;\n            *outputHandler = NULL;\n\n            if (getPacket != NULL) {\n                const XcpPacketHandlers *connect = getPacket(XCP_PID_CONNECT);\n                if (connect != NULL) {\n                    /* Note: if the Protocol layer is correctly configured,\n                       the CONNECT command should be always implemented */\n                    *inputHandler = connect->inputHandler;\n                    *outputHandler = connect->outputHandler;\n                }\n            }\n        }\n        else {\n            /* Input packet must be ignored and discarded */\n            *inputHandler = discardInputPacketHandler;\n            *outputHandler = NULL;\n        }\n    }\n}\n\n/*****************************************************************************\n    Public Functions (shared across different XCP commands)\n******************************************************************************/\nXcpStatus xcpStatusGet(void)\n{\n    return xcpStatus;\n}\n\nvoid xcpStatusSet(XcpStatus status)\n{\n    xcpStatus = status;\n}\n\nuint8_T xcpSessionStatusGet(void)\n{\n    return xcpSessionStatus;\n}\n\nvoid xcpSessionStatusSet(uint8_T status)\n{\n    xcpSessionStatus = status;\n}\n\nvoid xcpSessionStatusSetMask(uint8_T mask)\n{\n    XCP_SET_MASK(xcpSessionStatus, mask);\n}\n\nvoid xcpSessionStatusClearMask(uint8_T mask)\n{\n    XCP_CLEAR_MASK(xcpSessionStatus, mask);\n}\n\nuint8_T xcpResourceProtectionStatusGet(void)\n{\n    return xcpResourceProtectionStatus;\n}\n\nvoid xcpResourceProtectionStatusSet(uint8_T status)\n{\n    xcpResourceProtectionStatus = status;\n}\n\nvoid xcpResourceProtectionSetMask(uint8_T mask)\n{\n    XCP_SET_MASK(xcpResourceProtectionStatus, mask);\n}\n\nvoid xcpResourceProtectionClearMask(uint8_T mask)\n{\n    XCP_CLEAR_MASK(xcpResourceProtectionStatus, mask);\n}\n\nuint16_T xcpSessionConfigurationIdGet(void)\n{\n    return xcpSessionConfigurationId;\n}\n\nvoid xcpSessionConfigurationIdSet(uint16_T id)\n{\n    xcpSessionConfigurationId = id;\n}\n\nvoid genericOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize)\n{\n    XCP_UNUSED_PARAM(packetSize);\n\n    if (inputCode == XCP_PROTO_SUCCESS) {\n        /* Send back a generic RES packet */\n        XcpGenericResPacketFrame *frame = (XcpGenericResPacketFrame *)packet;\n        frame->PID = XCP_PID_RES;\n    }\n    else {\n        XcpErrorPacketFrame *frame = (XcpErrorPacketFrame *)packet;\n        frame->PID = XCP_PID_ERR;\n\n        switch (inputCode) {\n        case XCP_PROTO_MEMORY_OVERFLOW:\n            frame->errorCode = XCP_ERR_MEMORY_OVERFLOW;\n            break;\n        case XCP_PROTO_SEQUENCE_ERROR:\n            frame->errorCode = XCP_ERR_SEQUENCE;\n            break;\n        case XCP_PROTO_OUT_OF_RANGE:\n            frame->errorCode = XCP_ERR_OUT_OF_RANGE;\n            break;\n        case XCP_PROTO_CMD_UNKNOWN:\n            frame->errorCode = XCP_ERR_CMD_UNKNOWN;\n            break;\n        case XCP_PROTO_SYNCH:\n            frame->errorCode = XCP_ERR_CMD_SYNC;\n            break;\n        case XCP_PROTO_WRITE_PROTECTED:\n            frame->errorCode = XCP_ERR_WRITE_PROTECTED;\n            break;\n        case XCP_PROTO_CMD_SYNTAX:\n            frame->errorCode = XCP_ERR_CMD_SYNTAX;\n            break;\n        case XCP_PROTO_DAQ_ACTIVE:\n            frame->errorCode = XCP_ERR_DAQ_ACTIVE;\n            break;\n        case XCP_PROTO_MODE_NOT_VALID:\n            frame->errorCode = XCP_ERR_MODE_NOT_VALID;\n            break;\n        case XCP_PROTO_DAQ_CONFIG_ERROR:\n            frame->errorCode = XCP_ERR_DAQ_CONFIG;\n            break;\n        case XCP_PROTO_BUSY:\n            frame->errorCode = XCP_ERR_CMD_BUSY;\n            break;\n        case XCP_PROTO_ACCESS_DENIED:\n            frame->errorCode = XCP_ERR_ACCESS_DENIED;\n            break;\n        case XCP_PROTO_SEGMENT_UNKNOWN:\n            frame->errorCode = XCP_ERR_SEGMENT_NOT_VALID;\n            break;\n        case XCP_PROTO_PAGE_UNKNOWN:\n            frame->errorCode = XCP_ERR_PAGE_NOT_VALID;\n            break;\n        case XCP_PROTO_GENERIC_ERROR:\n            frame->errorCode = XCP_ERR_GENERIC;\n            break;\n        case XCP_PROTO_RESOURCE_NOT_ACCESSIBLE:\n            frame->errorCode = XCP_ERR_RESOURCE_NOT_ACCESSIBLE;\n            break;\n        default:\n            /* This should never happen */\n            XCP_PRINTF(\"genericOutputPacketHandler error: %d input code is not supported\", inputCode);\n            frame->errorCode = XCP_ERR_CMD_UNKNOWN;\n        }\n    }\n}\n\n\nconst XcpPacketHandlers* xcpFindPacket(XcpRxPidCode pid, const XcpPacketHandlers* packets, size_t packetsNumber)\n{\n    const XcpPacketHandlers* packet = NULL;\n\n    if (packets != NULL) {\n        size_t i = 0;\n        for (i = 0; (i < packetsNumber) && (packet == NULL); i++) {\n            if (pid == packets[i].PID) {\n                packet = &packets[i];\n            }\n        }\n    }\n\n    return packet;\n}\n\n/*****************************************************************************\n    Public Functions (implementing the Protocol Layer interface)\n******************************************************************************/\nXcpErrorCode xcpInit(\n    int   argc,   /**< [in] number of init parameters              */\n    void *argv[]  /**< [in] array of parameters values (C strings) */\n    )\n{\n    XCP_UNUSED_PARAM(argc);\n    XCP_UNUSED_PARAM(argv);\n\n    XCP_ERROR_IF(initialized, XCP_ERROR, \"xcpInit: protocol layer already initialized\\n\");\n\n    /* Initialize Standard Commands support */\n    xcpStandardInit();\n    groupPacketLookup[XCP_STANDARD_PACKETS_ID] = xcpStandardGetPacketLookup();\n\n    /* Initialize DAQ lists (and STIM) support */\n    xcpDaqInit();\n    groupPacketLookup[XCP_DAQ_PACKETS_ID] = xcpDaqGetPacketLookup();\n\n    /* Initialize Calibration support */\n    xcpCalibrationInit();\n    groupPacketLookup[XCP_CALIBRATION_PACKETS_ID] = xcpCalibrationGetPacketLookup();\n\n    initialized = true;\n\n    return XCP_SUCCESS;\n}\n\nXcpErrorCode xcpRun(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *msgBuffer = NULL;\n    size_t   msgBufferSize = 0;\n    size_t   packetOffset = 0;\n    size_t   packetSize = 0;\n    size_t   outputPacketSize = 0;\n    uint8_T *packet = NULL;\n    XcpInputPacketHandler  inputHandler  = NULL;\n    XcpOutputPacketHandler outputHandler = NULL;\n\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpRun: protocol layer not initialized\\n\");\n\n    /* Extract a packet from the transport layer */\n    errorCode = xcpTransportRxPacketGet(XCP_TRANSPORT_RX_DEFAULT_QUEUE,\n                                       (void**)&msgBuffer, &msgBufferSize,\n                                       &packetOffset, &packetSize);\n    if ((errorCode != XCP_SUCCESS) &&\n        (errorCode != XCP_PKT_OUT_OF_SEQUENCE) && /* If a wrong packet counter is detected,       */\n        (errorCode != XCP_PKT_LOST)) {            /* the packet content is still considered valid */\n        goto error;\n    }\n\n    /* Check buffer sizes and retrieve the pointer to the XCP packet area */\n    if ((msgBuffer == NULL) || ((packetOffset + XCP_IN_HW_AG(packetSize)) > msgBufferSize)) { \n        errorCode = XCP_INV_SIZE;\n        goto error;\n    }\n\n    /* Identify the handler suitable for processing the given XCP packet */\n    packet = msgBuffer + packetOffset;\n    xcpGetPacketHandlers(packet, packetSize, &inputHandler, &outputHandler);\n\n    /* An input handler needs to be always present */\n    if (inputHandler == NULL) {\n        XCP_PRINTF(\"xcpRun: missing input handler for packet ID %xH\", packet[0]);\n        errorCode = XCP_ERROR;\n        goto error;\n    }\n\n    /* Process input packet */\n    protoErrorCode = inputHandler(msgBuffer, packetOffset, &outputPacketSize);\n\n    if ((outputHandler != NULL) && (outputPacketSize > 0)) {\n        errorCode = XCP_SUCCESS;\n\n        /* An Output Packet needs to be generated -> check if current message buffer is big enough for the response packet */\n        if (packetSize < outputPacketSize) {\n            errorCode = msgBufferRealloc((void **)&msgBuffer, &msgBufferSize, &packetOffset, outputPacketSize);\n        }\n\n        XCP_MEMSET(packet, 0, XCP_IN_HW_AG(packetSize));\n\n        if (errorCode == XCP_SUCCESS) {\n            /* Fill the response packet */\n            packet = msgBuffer + packetOffset;\n            outputHandler(protoErrorCode, packet, outputPacketSize);\n\n            /* Send the response back to the Transport Layer\n               @note to guarantee the maximum responsiveness even when the TX traffic\n                     is maxed out, the highest priority queue is used */\n            errorCode = xcpTransportTxPacketSet(XCP_TRANSPORT_TX_HIGHEST_PRIO_QUEUE,\n                                                XCP_TRANSPORT_NOT_A_DAQ,\n                                                msgBuffer, msgBufferSize,\n                                                packetOffset, outputPacketSize);\n            if (errorCode != XCP_SUCCESS) {\n                goto error;\n            }\n        }\n    }\n\n    return errorCode;\n\nerror:\n    if (msgBuffer != NULL) {\n        xcpMemFree(msgBuffer);\n    }\n\n    return errorCode;\n}\n\nXcpErrorCode xcpEvent(XcpEventIdType eventId)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    uint32_T timestamp = 0;\n\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpEvent: protocol layer not initialized\\n\");\n\n    timestamp = (uint32_T)XCP_TIMESTAMP_GET();\n    \n    /* Process DAQ Lists associated to the event */\n    errorCode = xcpDaqEvent(eventId, timestamp, false);\n\n    return errorCode;\n}\n\nXcpErrorCode xcpEventExternalTimestamp(XcpEventIdType eventId, uint32_T timestamp)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpEvent: protocol layer not initialized\\n\");\n\n    /* Process DAQ Lists associated to the event */\n    errorCode = xcpDaqEvent(eventId, timestamp, false);\n\n    return errorCode;\n}\n\nXcpErrorCode xcpEventNotificationReq(XcpEventCode eventCode, const void *eventData, size_t eventDataSize)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t packetOffset = xcpTransportPacketOffset();\n    size_t maxEventDataSize = xcpTransportMaxCtoSize() - XCP_EVENT_PACKET_SIZE_IN_BYTES;\n    size_t packetSize = 0;\n    uint8_T *msgBuffer = NULL;\n    size_t msgBufferSize = 0;\n\n    /* Validate input parameters */\n    XCP_ERROR_IF((eventDataSize > 0) && (eventData == NULL), XCP_INV_ARG, \"xcpEventNotificationReq: invalid eventData buffer\\n\");\n    XCP_ERROR_IF(eventDataSize > maxEventDataSize, XCP_INV_ARG, \"xcpEventNotificationReq: invalid eventDataSize\\n\");\n\n    /* Calculate the required message buffer size */\n    packetSize = eventDataSize + XCP_EVENT_PACKET_SIZE_IN_BYTES;\n\n    /* Allocate the message buffer */\n    msgBufferSize = xcpTransportMsgBufferSize(packetSize, XCP_CTO);\n    msgBuffer = (uint8_T *)xcpMemAlloc(msgBufferSize);\n\n    if (msgBuffer != NULL) {\n        XcpEventPacketFrame *frame = (XcpEventPacketFrame *) (msgBuffer + packetOffset);\n\n        /* Fill the EV packet information */\n        frame->PID = XCP_PID_EV;\n        frame->eventCode = eventCode;\n\n        if (eventDataSize > 0) {\n            uint8_T *packetEventData = msgBuffer + packetOffset + XCP_IN_HW_AG(XCP_EVENT_PACKET_SIZE_IN_BYTES);\n\n            /* Copy the optional event data */\n            XCP_MEMCPY(packetEventData, eventData, XCP_IN_HW_AG(eventDataSize));\n        }\n\n        /* Send the EV packet to the Transport Layer\n           @note to guarantee that this packet gets delivered as soon as possible\n                 to the XCP Client, the highest priority queue is used */\n        errorCode = xcpTransportTxPacketSet(XCP_TRANSPORT_TX_HIGHEST_PRIO_QUEUE,\n                                            XCP_TRANSPORT_NOT_A_DAQ,\n                                            msgBuffer, msgBufferSize,\n                                            packetOffset, packetSize);\n        if (errorCode != XCP_SUCCESS) {\n            xcpMemFree(msgBuffer);\n        }\n    }\n    else\n    {\n        errorCode = XCP_NO_MEMORY;\n    }\n\n    return errorCode;\n}\n\nXcpErrorCode xcpRemoteServiceReq(XcpReqServiceCode serviceReqCode, const void *serviceReqData, size_t serviceReqDataSize)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t packetOffset = xcpTransportPacketOffset();\n    size_t maxServiceReqDataSize = xcpTransportMaxCtoSize() - XCP_SERVICE_REQ_PACKET_SIZE_IN_BYTES;\n    size_t packetSize = 0;\n    uint8_T *msgBuffer = NULL;\n    size_t msgBufferSize = 0;\n\n    /* Validate input parameters */\n    XCP_ERROR_IF((serviceReqDataSize > 0) && (serviceReqData == NULL), XCP_INV_ARG, \"xcpRemoteServiceReq: invalid serviceReqData buffer\\n\");\n    XCP_ERROR_IF(serviceReqDataSize > maxServiceReqDataSize, XCP_INV_ARG, \"xcpRemoteServiceReq: invalid serviceReqDataSize\\n\");\n\n    /* Calculate the required message buffer size */\n    packetSize = serviceReqDataSize + XCP_SERVICE_REQ_PACKET_SIZE_IN_BYTES;\n\n    /* Allocate the message buffer */\n    msgBufferSize = xcpTransportMsgBufferSize(packetSize, XCP_CTO);\n    msgBuffer = (uint8_T *)xcpMemAlloc(msgBufferSize);\n\n    if (msgBuffer != NULL) {\n        XcpServiceReqPacketFrame *frame = (XcpServiceReqPacketFrame *) (msgBuffer + packetOffset);\n\n        /* Fill the SERV packet information */\n        frame->PID = XCP_PID_SERV;\n        frame->serviceReqCode = serviceReqCode;\n\n        if (serviceReqDataSize > 0) {\n            uint8_T *packetServiceReqData = msgBuffer + packetOffset + XCP_IN_HW_AG(XCP_SERVICE_REQ_PACKET_SIZE_IN_BYTES);\n\n            /* Copy the optional event data */\n            XCP_MEMCPY(packetServiceReqData, serviceReqData, XCP_IN_HW_AG(serviceReqDataSize));\n        }\n\n        /* Send the SERV packet to the Transport Layer\n           @note to guarantee that this packet gets delivered as soon as possible\n                 to the XCP Client, the highest priority queue is used */\n        errorCode = xcpTransportTxPacketSet(XCP_TRANSPORT_TX_HIGHEST_PRIO_QUEUE,\n                                            XCP_TRANSPORT_NOT_A_DAQ,\n                                            msgBuffer, msgBufferSize,\n                                            packetOffset, packetSize);\n        if (errorCode != XCP_SUCCESS) {\n            xcpMemFree(msgBuffer);\n        }\n    }\n    else\n    {\n        errorCode = XCP_NO_MEMORY;\n    }\n\n    return errorCode;\n}\n\nXcpStatus xcpGetStatus(void)\n{\n    return xcpStatus;\n}\n\nXcpErrorCode xcpReset(void)\n{\n    if (!initialized) {\n        XCP_PRINTF(\"xcpReset: protocol layer already reset\\n\");\n        /* Nothing to do: just printing out a warning message*/\n    }\n\n    /* Reset Calibration support */\n    xcpCalibrationReset();\n\n    /* Reset DAQ lists (and STIM) support */\n    xcpDaqReset();\n\n    /* Reset Standard Commands support */\n    xcpStandardReset();\n\n    XCP_MEMSET((void*)groupPacketLookup, 0, sizeof(groupPacketLookup));\n\n    initialized = false;\n\n    return XCP_SUCCESS;\n}\n\nXcpErrorCode xcpSetCustomPoolMemoryManager(XcpEventIdType eventId, XcpCustomAllocHandler allocHandler, XcpCustomFreeHandler freeHandler)\n{\n    XcpErrorCode errorCode;\n\n    /* Forward registration to DAQ list */\n    errorCode = xcpDaqSetCustomPoolMemoryManager(eventId, allocHandler, freeHandler);\n\n    return errorCode;\n}\n\nXcpErrorCode xcpGetCustomPoolMemoryManager(XcpEventIdType *eventId, XcpCustomAllocHandler *allocHandler, XcpCustomFreeHandler *freeHandler)\n{\n    XcpErrorCode errorCode;\n\n    /* Forward query to DAQ list */\n    errorCode = xcpDaqGetCustomPoolMemoryManager(eventId, allocHandler, freeHandler);\n\n    return errorCode;\n}\n\nXcpErrorCode xcpPackedModeEventsFlush(uint32_T timestamp)\n{\n    XcpErrorCode errorCode;\n\n    errorCode = xcpDaqEventsFlush(timestamp);\n\n    return errorCode;\n}\n\nXcpErrorCode xcpPackedModeEventReset(XcpEventIdType eventId)\n{\n    XcpErrorCode errorCode;\n    boolean_T resetSamples = true;\n\n    /* Reset the status of pending packed DAQ lists,\n       discarding incomplete packets. */\n    errorCode = xcpDaqEvent(eventId, 0, resetSamples);\n\n    return errorCode;\n}\n\n#ifdef XCP_INTERNAL_DAQ_CONFIG_ACCESS_SUPPORT\n\nXcpErrorCode xcpGetDaqOdtEntries(XcpEventIdType eventId,\n                                 XcpOdtEntry* entries,\n                                 size_t* entriesNumber,\n                                 size_t maxEntriesNumber)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    errorCode = xcpDaqGetOdtEntries(eventId, XCP_DIRECTION_DAQ,\n                                 entries, entriesNumber,\n                                 maxEntriesNumber);\n    return errorCode;\n}\n\n#endif /* XCP_INTERNAL_DAQ_CONFIG_ACCESS_SUPPORT */\n\n\n#ifndef XCP_DAQ_SUPPORT\n\nvoid xcpDaqInit(void) {}\nXcpPacketLookupFunction xcpDaqGetPacketLookup(void) {return NULL;}\nvoid xcpDaqSetPacketLookup(XcpPacketLookupFunction getPacket) {XCP_UNUSED_PARAM(getPacket);}\nXcpErrorCode xcpDaqEvent(XcpEventIdType eventId, uint32_T timestamp, boolean_T resetSamples) {XCP_UNUSED_PARAM(eventId); XCP_UNUSED_PARAM(timestamp); XCP_UNUSED_PARAM(resetSamples); return XCP_SUCCESS;}\nboolean_T xcpResetDaqListStatus(void) {return true;}\nXcpErrorCode xcpDaqEventsFlush(uint32_T timestamp) {XCP_UNUSED_PARAM(timestamp); return XCP_SUCCESS;}\nboolean_T xcpDaqLock(void) {return true;}\nvoid xcpDaqUnlock(void) {}\nvoid xcpDaqReset(void) {}\nXcpErrorCode xcpDaqSetCustomPoolMemoryManager(XcpEventIdType eventId, XcpCustomAllocHandler allocHandler, XcpCustomFreeHandler freeHandler) {\n    XCP_UNUSED_PARAM(eventId); XCP_UNUSED_PARAM(allocHandler); XCP_UNUSED_PARAM(freeHandler); return XCP_SUCCESS;}\nXcpErrorCode xcpDaqGetCustomPoolMemoryManager(XcpEventIdType *eventId, XcpCustomAllocHandler *allocHandler, XcpCustomFreeHandler *freeHandler) {\n    XCP_UNUSED_PARAM(eventId); XCP_UNUSED_PARAM(allocHandler); XCP_UNUSED_PARAM(freeHandler); return XCP_SUCCESS;}\n\n#ifdef XCP_INTERNAL_DAQ_CONFIG_ACCESS_SUPPORT\nXcpErrorCode xcpGetDaqOdtEntries(XcpEventIdType eventId, XcpOdtEntry* entries, size_t* entriesNumber, size_t maxEntriesNumber){\n    XCP_UNUSED_PARAM(eventId); XCP_UNUSED_PARAM(entries); XCP_UNUSED_PARAM(entriesNumber); XCP_UNUSED_PARAM(maxEntriesNumber); return XCP_SUCCESS;}\n#endif /* XCP_INTERNAL_DAQ_CONFIG_ACCESS_SUPPORT */\n\n#endif\n\n\n#ifndef XCP_CALIBRATION_SUPPORT\n\nvoid xcpCalibrationInit(void) {}\nXcpPacketLookupFunction xcpCalibrationGetPacketLookup(void) {return NULL;}\nvoid xcpCalibrationSetPacketLookup(XcpPacketLookupFunction getPacket) {XCP_UNUSED_PARAM(getPacket);}\nvoid xcpCalibrationReset(void) {}\n\n#endif\n"},{"name":"xcp_calibration.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2025b/toolbox/coder/xcp/src/target/server/protocol/src","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2017-2020 The MathWorks, Inc.\n*\n* File: xcp_calibration.c\n*\n* Abstract:\n*  Implementation of XCP Protocol Layer Calibration support\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp.h\"\n#include \"xcp_cfg.h\"\n#include \"xcp_calibration.h\"\n\n#ifdef XCP_CALIBRATION_SUPPORT\n\n#ifdef XCP_CALIBRATION_EXTENDED_SUPPORT\n#include \"xcp_calibration_ext.h\"\n#endif\n\n#include \"xcp_types.h\"\n#include \"xcp_calibration_types.h\"\n#include \"xcp_standard.h\"\n#include \"xcp_transport_internal.h\"\n\n/*****************************************************************************\n    Internal Functions specific to Calibration support\n******************************************************************************/\nstatic boolean_T isValidShortDownloadSize(uint8_T size)\n{\n    size_t addressGranularity = XCP_ADDRESS_GRANULARITY_BYTES_NUMBER;\n    size_t maxCtoSize = xcpTransportMaxCtoSize();\n\n    return (size <= ((maxCtoSize - 8) / addressGranularity));\n}\n\n#if XCP_SET_MTA_ENABLE == 1\n    static boolean_T isValidDownloadSize(uint8_T size)\n    {\n        size_t addressGranularity = XCP_ADDRESS_GRANULARITY_BYTES_NUMBER;\n        size_t maxCtoSize = xcpTransportMaxCtoSize();\n        \n        return ( (size >= 1)  && (size <= (maxCtoSize-2) / addressGranularity ) );\n    }\n#endif  /* XCP_SET_MTA_ENABLE == 1 */\n\n/** memcpy function used to copy data from packet to MTA address */\nstatic void xcpMemcpyToMTA(uint8_T *packet, uint8_T size)\n{\n    /* Retrieve memory address */\n    uint8_T *xcpMTARawPointer = xcpStandardGetAddressFromMta();\n\n    XCP_PRINTF(\"writing at address %p\\n\", xcpMTARawPointer);\n\n#ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n{\n    uint32_T address;\n    uint8_T addressExtension;\n    uint8_T dstOffsetBytes;\n    xcpStandardGetMta(&address, &addressExtension);\n    dstOffsetBytes = XCP_BYTE_OFFSET_GET(address);\n    xcpMemcpyByte(xcpMTARawPointer, dstOffsetBytes, packet, 0, size);\n}\n#else\n    XCP_MEMCPY(xcpMTARawPointer, packet, size);\n#endif\n}\n\n/*****************************************************************************\n    XCP DOWNLOAD\n******************************************************************************/\n#if XCP_SET_MTA_ENABLE == 1\n    static XcpProtoErrorCode downloadInputPacketHandler(void   *msgBuffer,\n        size_t  xcpPacketOffset,\n        size_t *outputPacketSize)\n    {\n        XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n        uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n        XcpDownloadCmdPacketFrame *frame = (XcpDownloadCmdPacketFrame *)packet;\n        boolean_T ok = false;\n        uint8_T *xcpMTARawPointer = xcpStandardGetAddressFromMta();\n\n        /* Check if the number of data elements is valid */\n        ok = isValidDownloadSize((uint8_T)frame->size);\n        XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n            (\"DOWNLOAD: invalid number of data elements (%d)\\n\", frame->size));\n            \n        /* Check if a valid MTA address is available */\n        XCP_INPUT_PKT_ERROR_IF((xcpMTARawPointer == 0) || (xcpMTARawPointer == NULL), \n            XCP_PROTO_ACCESS_DENIED, (\"DOWNLOAD: invalid address\\n\"));\n\n        XCP_PRINTF(\"DOWNLOAD: \");\n    \n        /* Update the value of the parameter with the data element content */\n        xcpMemcpyToMTA(packet + sizeof(XcpDownloadCmdPacketFrame), (uint8_T)frame->size);\n    \n        /* Post-increment MTA by the frame size in address granularity units */\n        xcpStandardIncrementMta((uint8_T)frame->size);\n        \n        *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n        return protoErrorCode;\n    }\n#endif  /* XCP_SET_MTA_ENABLE == 1 */\n\n/*****************************************************************************\n    XCP SHORT_DOWNLOAD\n******************************************************************************/\nstatic XcpProtoErrorCode shortDownloadInputPacketHandler(void   *msgBuffer,\n    size_t  xcpPacketOffset,\n    size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpShortDownloadCmdPacketFrame *frame = (XcpShortDownloadCmdPacketFrame *)packet;\n    boolean_T ok = false;\n\n    /* Check if the number of data elements is valid */\n    ok = isValidShortDownloadSize((uint8_T)frame->size);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"SHORT_DOWNLOAD: invalid number of data elements (%d)\\n\", frame->size));\n\n    /* Check if the memory address is valid and set the MTA pointer */\n    ok = xcpStandardSetMta(frame->address, (uint8_T)frame->addressExtension);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_ACCESS_DENIED, (\"SHORT_DOWNLOAD: invalid address\\n\"));\n\n    XCP_PRINTF(\"SHORT_DOWNLOAD: \");\n\n    /* Update the value of the parameter with the data element content */\n    xcpMemcpyToMTA(packet + sizeof(XcpShortDownloadCmdPacketFrame), (uint8_T)frame->size);\n\n    /* Post-increment MTA by the frame size in address granularity units */\n    xcpStandardIncrementMta((uint8_T)frame->size);\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n\n/** This table contains the list of supported Rx packets and the corresponding handlers */\nstatic const XcpPacketHandlers calibrationSupportedRxPacket[] =\n{\n#if XCP_SET_MTA_ENABLE == 1\n    { XCP_PID_DOWNLOAD,       downloadInputPacketHandler,     genericOutputPacketHandler },\n#endif\n    { XCP_PID_SHORT_DOWNLOAD, shortDownloadInputPacketHandler, genericOutputPacketHandler }\n};\n\n\n/*****************************************************************************\n    XCP Packet Lookup Function for basic calibration commands\n******************************************************************************/\n\n/* Default Calibration Packet Lookup function, supporting only basic commands\n   listed in the table above */\nstatic const XcpPacketHandlers* getPacket(XcpRxPidCode pid)\n{\n    return xcpFindPacket(pid, calibrationSupportedRxPacket,\n                         XCP_ELEMENTS_NUMBER(calibrationSupportedRxPacket));\n}\n\nstatic XcpPacketLookupFunction packetLookup = NULL;\n\n\n\n/*****************************************************************************\n    Public Functions (invoked within the Protocol Layer)\n******************************************************************************/\nvoid xcpCalibrationInit(void)\n{\n    /* Initialize the packet lookup function to support only basic\n       calibration commands */\n    xcpCalibrationSetPacketLookup(getPacket);\n\n#ifdef XCP_CALIBRATION_EXTENDED_SUPPORT\n    /* Initialize support for the extended list of calibration commands */\n    xcpCalibrationExtendedInit();\n#endif\n}\n\n\nXcpPacketLookupFunction xcpCalibrationGetPacketLookup(void)\n{\n    return packetLookup;\n}\n\n\nvoid xcpCalibrationSetPacketLookup(XcpPacketLookupFunction getPacketFcn)\n{\n    packetLookup = getPacketFcn;\n}\n\nvoid xcpCalibrationReset(void)\n{\n#ifdef XCP_CALIBRATION_EXTENDED_SUPPORT\n    /* Reset support for the extended list of calibration commands */\n    xcpCalibrationExtendedReset();\n#endif\n}\n\n#endif\n"},{"name":"xcp_daq.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2025b/toolbox/coder/xcp/src/target/server/protocol/src","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2023 The MathWorks, Inc.\n*\n* File: xcp_daq.c\n*\n* Abstract:\n*  Implementation of XCP Protocol Layer DAQ Lists (and STIM) support\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp.h\"\n#include \"xcp_internal.h\"\n#include \"xcp_cfg.h\"\n#include \"xcp_daq.h\"\n\n#ifdef XCP_DAQ_SUPPORT\n#include \"xcp_daq_ext.h\"\n#include \"xcp_transport_internal.h\"\n#include \"xcp_types.h\"\n#include \"xcp_daq_types.h\"\n#include \"xcp_mem.h\"\n\n/*****************************************************************************\n    Internal Global variables specific to DAQ support\n******************************************************************************/\n\n/** Dynamic DAQ Lists data structures */\nstatic XcpDaqLists xcpDynamicDaqLists;\n\n/** Number of event threads currently in execution */\nstatic size_t xcpRunningEventCounter = 0;\n\n/** ID of the selected DAQ List on START_STOP_DAQ_LIST command */\n#define XCP_INVALID_DAQ_LIST_ID -1\nstatic int32_T startStopDaqListId = XCP_INVALID_DAQ_LIST_ID;\n\n/** Pointer to current ODT entry */\nstatic XcpDaqPtr   xcpCurrentDaq = { 0xFFFF, 0xFF, 0xFF };\n\nstatic XcpEventCustomMemoryManager xcpEventCustomMemoryManager = {XCP_DAQ_CUSTOM_MEMORY_INVALID_EVENT_ID, NULL, NULL};\n\n#ifndef XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n/* XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT is typically enabled\n   for multi-core applications, where it is critical to limit\n   the interference between threads streaming data.\n   For this reason, by default we enable the independent lock\n   of the DAQ list data structures between events */\n#define XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK 1\n#else\n/* XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT is typically disabled\n   for single-core bare-metal applications, where it is critical\n   to limit the memory footprint of the target executable.\n   For this reason, by default we disable the independent lock\n   of the DAQ list data structures between events and use a single\n   mutex to protect the DAQ lists data structures */\n#define XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK 0\n#endif\n\n#endif\n\n\n#if !defined(XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK) || (XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK == 0)\n/* Mutex protecting against the concurrent access to DAQ Lists data structures */\nstatic XCP_MUTEX_DEFINE(daqLock);\n\nstatic boolean_T xcpDaqWriteLock(XcpEventIdType eventId)\n{\n    boolean_T locked = false;\n    XCP_UNUSED_PARAM(eventId);\n    XCP_WRITE_TRY_LOCK(daqLock, xcpRunningEventCounter, locked);\n\n    return locked;\n}\n\nstatic void xcpDaqWriteUnlock(XcpEventIdType eventId)\n{\n    XCP_UNUSED_PARAM(eventId);\n    XCP_WRITE_UNLOCK(daqLock);\n}\n\nstatic void xcpDaqReadLock(XcpEventIdType eventId)\n{\n    XCP_UNUSED_PARAM(eventId);\n    XCP_READ_LOCK(daqLock, xcpRunningEventCounter);\n}\n\nstatic void xcpDaqReadUnlock(XcpEventIdType eventId)\n{\n    XCP_UNUSED_PARAM(eventId);\n    XCP_READ_UNLOCK(daqLock, xcpRunningEventCounter);\n}\n\n#else\n/* Each XCP event has an independent mutex to protect the read/write access\n   to the DAQ list data structures */\n#ifndef XCP_MAX_EVENT_DATA_NUMBER\n#define XCP_MAX_EVENT_DATA_NUMBER XCP_MAX_EVENT_CHANNEL\n#endif\n\ntypedef struct XcpEventData {\n    XCP_MUTEX_DEFINE(lock);\n} XcpEventData;\n\n/** Array of event-specific data */\nstatic XcpEventData xcpEventData[XCP_MAX_EVENT_DATA_NUMBER];\n\nstatic boolean_T xcpDaqWriteLock(XcpEventIdType eventId)\n{\n    XCP_MUTEX_LOCK(xcpEventData[eventId].lock);\n    return true;\n}\n\nstatic void xcpDaqWriteUnlock(XcpEventIdType eventId)\n{\n    XCP_MUTEX_UNLOCK(xcpEventData[eventId].lock);\n}\n\nstatic void xcpDaqReadLock(XcpEventIdType eventId)\n{\n    XCP_MUTEX_LOCK(xcpEventData[eventId].lock);\n}\n\nstatic void xcpDaqReadUnlock(XcpEventIdType eventId)\n{\n    XCP_MUTEX_UNLOCK(xcpEventData[eventId].lock);\n}\n\n#endif\n\n#ifndef XCP_MIN_EVENT_NO_RESERVED_POOL\n#define XCP_MIN_EVENT_NO_RESERVED_POOL 0xFFFF\n#endif\n\n/*****************************************************************************\n    Internal Functions specific to DAQ support\n******************************************************************************/\n\n/* When enabled, timestamp is required for first ODT in the DAQ list */\n#if XCP_TIMESTAMP_FIXED == 0\n#define IS_TIMESTAMP_REQUIRED(mode, odtNumber) ((odtNumber == 0) && \\\n            XCP_READ_BIT_VALUE(mode, XCP_DAQ_MODE_TIMESTAMP_MASK))\n#else\n#define IS_TIMESTAMP_REQUIRED(mode, odtNumber) (odtNumber == 0)\n#endif\n\n/* Incrementing pointer. byteOffset argument will have a valid value only when\n   we are emulating as a BYTE addressable target. Otherwise, it is 0. */\n#ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n#define XCP_HW_PTR_INCREMENT(ptr, incr, byteOffset) (uint8_T *)(byteOffset ? (ptr + XCP_IN_HW_AG(incr - 1)) : (ptr + XCP_IN_HW_AG(incr)))\n#else\n#define XCP_HW_PTR_INCREMENT(ptr, incr, byteOffset) (uint8_T *)(ptr + incr)\n#endif\n\n/* Update byteOffset when emulating as a BYTE addressable target */\n#ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n#define XCP_HW_BYTE_OFFSET_UPDATE(offset, size) ((offset + size) % XCP_HARDWARE_ADDRESS_GRANULARITY_BYTES_NUMBER)\n#else\n#define XCP_HW_BYTE_OFFSET_UPDATE(offset, size) 0\n#endif\n\n#define IS_USING_CUSTOM_POOL(x) (x == xcpEventCustomMemoryManager.eventId)\n\nstatic boolean_T isActiveDaqList(uint16_T daqListId)\n{\n    return (xcpDynamicDaqLists.daq[daqListId].status == XCP_DAQ_SELECTED) ||\n           (xcpDynamicDaqLists.daq[daqListId].status == XCP_DAQ_STARTED);\n}\n\nstatic boolean_T noActiveDaqLists(void)\n{\n    boolean_T found = 0;\n    uint16_T i = 0;\n\n    for (i = 0; (i < xcpDynamicDaqLists.daqCount) && !found; i++) {\n        found = isActiveDaqList(i);\n    }\n\n    return !found;\n}\n\nstatic boolean_T isValidDaqPtr(uint16_T daqListId, uint8_T odtId, uint8_T odtEntryId)\n{\n    boolean_T ret = (xcpDynamicDaqLists.daq != NULL) &&\n                    (daqListId < xcpDynamicDaqLists.daqCount) &&\n                    (xcpDynamicDaqLists.daq[daqListId].odt != NULL) &&\n                    (odtId < xcpDynamicDaqLists.daq[daqListId].odtCount) &&\n                    (xcpDynamicDaqLists.daq[daqListId].odt[odtId].entry != NULL) &&\n                    (odtEntryId < xcpDynamicDaqLists.daq[daqListId].odt[odtId].entriesCount);\n\n    return ret;\n}\n\nstatic boolean_T isValidDaqEntry(uint8_T bitOffset, uint8_T size, uint32_T address)\n{\n    boolean_T ret = false;\n    uint16_T  entrySize = size;     /* cast to 16-bit avoids -Werror=type-limits */\n\n    if (bitOffset == 0xFF) {\n        /* \"Normal\" (non-bitwise) access has been selected */\n        if ( (entrySize <= XCP_MAX_ODT_ENTRY_SIZE) &&\n             (entrySize % (XCP_ODT_ENTRY_SIZE_GRANULARITY/XCP_ADDRESS_GRANULARITY_BYTES_NUMBER) == 0) &&\n             (  address % (XCP_ODT_ENTRY_SIZE_GRANULARITY/XCP_ADDRESS_GRANULARITY_BYTES_NUMBER) == 0) ) {\n            ret = true;\n        }\n    }\n    else {\n        /* Bitwise access has been selected */\n        if ((bitOffset <= 0x1F) && (address % XCP_ODT_ENTRY_SIZE_GRANULARITY) &&\n            (entrySize == XCP_ODT_ENTRY_SIZE_GRANULARITY)) {\n            ret = true;\n        }\n    }\n\n    return ret;\n}\n\n/** The current supported mode includes:\n- alternating = 0\n- direction = 0 (DAQ only)\n- timestamp = 1 or 0\n- PID OFF = 0\n*/\nstatic boolean_T isSupportedDaqListMode(uint8_T mode)\n{\n    #if XCP_TIMESTAMP_FIXED == 0\n        return ( (mode & ~XCP_DAQ_MODE_TIMESTAMP_MASK) == 0 );\n    #else\n        return (mode == XCP_DAQ_MODE_TIMESTAMP_MASK);\n    #endif\n}\n\nstatic boolean_T isValidStartStopMode(uint8_T mode)\n{\n    boolean_T ret = false;\n\n    if ((mode == XCP_DAQ_LIST_STOP) ||\n        (mode == XCP_DAQ_LIST_START) ||\n        (mode == XCP_DAQ_LIST_SELECT))\n        ret = true;\n\n    return ret;\n}\n\nstatic boolean_T isValidStartStopSynchMode(uint8_T mode)\n{\n    boolean_T ret = false;\n\n    if ((mode == XCP_DAQ_LIST_STOP_ALL) ||\n        (mode == XCP_DAQ_LIST_START_SELECTED) ||\n        (mode == XCP_DAQ_LIST_STOP_SELECTED))\n        ret = true;\n\n    return ret;\n}\n\nstatic boolean_T absoluteOdtNumberIdentification(void)\n{\n    return (XCP_ID_FIELD_TYPE == XCP_ID_ABSOLUTE_ODT_NUMBER);\n}\n\nstatic boolean_T isDaqPackedModeEnabled(uint16_T daqListId)\n{\n    /* DAQ Packed Mode is only supported for event-grouped packing and \n       reserved memory pool */\n\n    boolean_T isEnabled = (xcpDynamicDaqLists.daq[daqListId].packedMode == XCP_DAQ_EVENT_GROUPED_PACKING) &&\n                          !IS_USING_CUSTOM_POOL(xcpDynamicDaqLists.daq[daqListId].eventId);\n    \n#if XCP_MEM_DAQ_RESERVED_POOLS_NUMBER > 0\n    isEnabled = isEnabled && (daqListId < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER);\n#endif\n\n    return isEnabled;\n}\n\n/* Return size of packet associated with the odt at the protocol layer */\nstatic size_t odtPacketSize(XcpDaq *daq, uint8_T odtNumber) {\n    XcpOdt *odt = &daq->odt[odtNumber];\n    size_t packetSize = XCP_IN_BYTES(odt->size * daq->sampleCount + XCP_IN_AG(XCP_ID_FIELD_SIZE));\n\n    if (IS_TIMESTAMP_REQUIRED(daq->mode, odtNumber)) {\n        packetSize += XCP_TIMESTAMP_SIZE;\n    }\n\n    return packetSize;\n}\n\n/* Try to allocate a reserved memory pool dedicated to the packets in the DAQ list.\n   @note depending on the configuration of the memory allocator, this may fail\n         so we just set daq->poolId to XCP_INVALID_POOL_ID in that case */\nstatic XcpErrorCode createDaqReservedPool(XcpDaq *daq)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t poolBlockSize = 0;\n    uint8_T i = 0;\n\n    /* Calculate the max size for the ODT packets in the given DAQ list */\n    for (i = 0; i < daq->odtCount; i++) {\n        /* Calculate the required message buffer size */\n        size_t packetSize = odtPacketSize(daq, i);\n        size_t msgBufferSize = 0;\n\n        msgBufferSize = xcpTransportMsgBufferSize(packetSize, XCP_DTO);\n\n        if (msgBufferSize > poolBlockSize) {\n            poolBlockSize = msgBufferSize;\n        }\n    }\n\n    /* Try the allocation of the dedicate pool */\n    errorCode = xcpMemReservedPoolCreate(poolBlockSize,\n        (size_t)XCP_MEM_DAQ_RESERVED_POOL_BLOCKS_NUMBER * daq->odtCount,\n        &daq->poolId);\n    if (errorCode != XCP_SUCCESS) {\n        daq->poolId = XCP_INVALID_POOL_ID;\n    }\n\n    #ifdef XCP_DEBUG_SUPPORT\n    xcpMemPrintDiagnostics();\n    #endif\n\n    return errorCode;\n}\n\nstatic void destroyDaqReservedPool(XcpDaq *daq)\n{\n    if (daq->poolId != XCP_INVALID_POOL_ID) {\n        xcpMemReservedPoolDestroy(daq->poolId);\n    }\n\n    daq->poolId = XCP_INVALID_POOL_ID;\n}\n\n\n/*****************************************************************************\n    XCP SET DAQ PTR\n******************************************************************************/\nstatic XcpProtoErrorCode setDaqPtrInputPacketHandler(void   *msgBuffer,\n                                                     size_t  xcpPacketOffset,\n                                                     size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpSetDaqPtrCmdPacketFrame *frame = (XcpSetDaqPtrCmdPacketFrame *) packet;\n    uint16_T daqListId  = (uint16_T)frame->daqListId;\n    uint8_T  odtId      = (uint8_T)frame->odtId;\n    uint8_T  odtEntryId = (uint8_T)frame->odtEntryId;\n    boolean_T ok = false;\n\n    /* Check if the selected ODT Entry is available */\n    ok = isValidDaqPtr(daqListId, odtId, odtEntryId);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"SET_DAQ_PTR: ODT entry not available (DAQ %d, ODT %d, Entry %d)\\n\", daqListId, odtId, odtEntryId));\n\n    /* Check if the DAQ list is currently active */\n    ok = !isActiveDaqList(daqListId);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_DAQ_ACTIVE, (\"SET_DAQ_PTR: DAQ list %d is currently active\\n\", daqListId));\n\n    /* Everything is fine -> proceed and update the current ODT entry pointer */\n    XCP_PRINTF(\"SET_DAQ_PTR: updating current ODT entry pointer to DAQ %d, ODT %d, Entry %d\\n\",\n               daqListId, odtId, odtEntryId);\n\n    xcpCurrentDaq.daqListId  = daqListId;\n    xcpCurrentDaq.odtId      = odtId;\n    xcpCurrentDaq.odtEntryId = odtEntryId;\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP WRITE DAQ\n******************************************************************************/\nstatic XcpProtoErrorCode writeDaqInputPacketHandler(void   *msgBuffer,\n                                                    size_t  xcpPacketOffset,\n                                                    size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpWriteDaqCmdPacketFrame *frame = (XcpWriteDaqCmdPacketFrame *)packet;\n    uint16_T daqListId = xcpCurrentDaq.daqListId;\n    uint8_T  odtId = xcpCurrentDaq.odtId;\n    uint8_T  odtEntryId = xcpCurrentDaq.odtEntryId;\n    XcpOdtEntry *entry = NULL;\n    boolean_T ok = false;\n\n    /* Check if the selected ODT Entry is available */\n    ok = isValidDaqPtr(daqListId, odtId, odtEntryId);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_WRITE_PROTECTED,\n        (\"WRITE_DAQ: current ODT entry not available for write operations (DAQ %d, ODT %d, Entry %d)\\n\", daqListId, odtId, odtEntryId));\n\n    /* Check if the DAQ list is currently active */\n    ok = !isActiveDaqList(daqListId);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_DAQ_ACTIVE, (\"XCP_WRITE_DAQ: DAQ list %d is currently active\\n\", daqListId));\n\n    /* Check if the Entry values are valid */\n    ok = isValidDaqEntry((uint8_T)frame->bitOffset, (uint8_T)frame->size, (uint32_T)frame->address);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"XCP_WRITE_DAQ: invalid DAQ %d ODT %d Entry %d value: bitOffset = %xH size = %d addressExtension = %dH address = %xH\\n\",\n         daqListId, odtId, odtEntryId, frame->bitOffset, frame->size, frame->addressExtension, frame->address));\n\n    /* Everything is fine -> proceed and write the entry */\n    XCP_PRINTF(\"XCP_WRITE_DAQ: writing DAQ %d ODT %d Entry %d: bitOffset = %xH size = %d addressExtension = %dH address = %xH\\n\",\n               daqListId, odtId, odtEntryId, frame->bitOffset, frame->size, frame->addressExtension, frame->address);\n\n    entry = &(xcpDynamicDaqLists.daq[daqListId].odt[odtId].entry[odtEntryId]);\n\n    entry->bitOffset        = (uint8_T)frame->bitOffset;\n    entry->size             = (uint8_T)frame->size;\n    entry->addressExtension = (uint8_T)frame->addressExtension;\n    entry->address          = (uint32_T)frame->address;\n\n    /* After a successful WRITE_DAQ, the xcpDaqPtr odtEntryId needs to be post incremented */\n    xcpCurrentDaq.odtEntryId++;\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP SET DAQ LIST MODE\n******************************************************************************/\nstatic XcpProtoErrorCode setDaqListModeInputPacketHandler(void   *msgBuffer,\n                                                          size_t  xcpPacketOffset,\n                                                          size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpSetDaqListModeCmdPacketFrame *frame = (XcpSetDaqListModeCmdPacketFrame *)packet;\n    XcpDaq *daqList = NULL;\n    boolean_T ok = false;\n\n    /* Check if the DAQ List is available */\n    ok = (xcpDynamicDaqLists.daq != NULL) && (frame->daqListId < xcpDynamicDaqLists.daqCount);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE, (\"SET_DAQ_LIST_MODE: DAQ list %d not available\\n\", frame->daqListId));\n\n    daqList = &(xcpDynamicDaqLists.daq[frame->daqListId]);\n\n    /* Check if the DAQ list is currently active */\n    ok = !isActiveDaqList((uint16_T)frame->daqListId);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_DAQ_ACTIVE, (\"SET_DAQ_LIST_MODE: DAQ list %d is currently active\\n\", frame->daqListId));\n\n    /* Check if the Event Id is valid */\n    ok = (frame->eventId < XCP_MAX_EVENT_CHANNEL);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE, (\"SET_DAQ_LIST_MODE: invalid event channel Id %d\\n\", frame->eventId));\n\n    /* Check DAQ list priority */\n    ok = (frame->priority == 0);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE, (\"SET_DAQ_LIST_MODE: priority not supported, must be zero\\n\"));\n\n    /* Check if DAQ list mode is supported */\n    ok = isSupportedDaqListMode((uint8_T)frame->mode);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_MODE_NOT_VALID, (\"SET_DAQ_LIST_MODE: DAQ list mode not supported %xH\\n\", frame->mode));\n\n    /* Everything is fine -> proceed and set the DAQ list mode */\n    XCP_PRINTF(\"SET_DAQ_LIST_MODE: setting DAQ list %d: mode = %xH, eventId = %d, prescaler = %d, priority = %d\\n\",\n        frame->daqListId, frame->mode, frame->eventId, frame->prescaler, frame->priority);\n\n    daqList->mode       = (uint8_T)frame->mode;\n    daqList->eventId    = (uint16_T)frame->eventId;\n    daqList->prescaler  = (uint8_T)frame->prescaler;\n    daqList->priority   = (uint8_T)frame->priority;\n\n    /* Assuming that prescaler = 0 means value that you are not interested in using it */\n    if (daqList->prescaler <= 1)\n        daqList->prescaler = 1;\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP START_STOP_DAQ_LIST\n******************************************************************************/\nstatic XcpProtoErrorCode startStopDaqListInputPacketHandler(void   *msgBuffer,\n                                                            size_t  xcpPacketOffset,\n                                                            size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpStartStopDaqListCmdPacketFrame *frame = (XcpStartStopDaqListCmdPacketFrame *)packet;\n    XcpDaq *daqList = NULL;\n    int32_T daqListId = frame->daqListId;\n    boolean_T ok = false;\n    boolean_T locked = false;\n\n    /* Check if the DAQ List is available */\n    ok = (xcpDynamicDaqLists.daq != NULL) && (daqListId < xcpDynamicDaqLists.daqCount);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"START_STOP_DAQ_LIST: DAQ list %d not available\\n\", daqListId));\n\n    startStopDaqListId = daqListId;\n    daqList = &(xcpDynamicDaqLists.daq[daqListId]);\n\n    /* Check if requested mode is valid */\n    ok = isValidStartStopMode((uint8_T)frame->mode);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_MODE_NOT_VALID,\n        (\"START_STOP_DAQ_LIST: invalid mode %d selected \\n\", frame->mode));\n\n    /* Assign the Absolute ODT number */\n    if (absoluteOdtNumberIdentification()) {\n        if (daqList->status == XCP_DAQ_INIT) {\n            /* The DAQ list has never been started/stopped/selected before\n            -> PIDs for the ODTs needs to be reserved */\n            if (XCP_READ_BIT_VALUE(daqList->mode, XCP_DAQ_MODE_DIRECTION_MASK)) {\n                /* STIM */\n                ok = (daqList->odt != NULL) &&\n                       ((xcpDynamicDaqLists.firstAvailableStimPid +\n                        daqList->odtCount) <= XCP_MAX_STIM_ODT_NUMBER);\n\n                if (ok) {\n                    daqList->firstPid = xcpDynamicDaqLists.firstAvailableStimPid;\n                    xcpDynamicDaqLists.firstAvailableStimPid += daqList->odtCount;\n                }\n            }\n            else {\n                /* DAQ */\n                ok = (daqList->odt != NULL) &&\n                       ((xcpDynamicDaqLists.firstAvailableDaqPid +\n                        daqList->odtCount) <= XCP_MAX_DAQ_ODT_NUMBER);\n\n                if (ok) {\n                    daqList->firstPid = xcpDynamicDaqLists.firstAvailableDaqPid;\n                    xcpDynamicDaqLists.firstAvailableDaqPid += daqList->odtCount;\n                }\n            }\n\n            XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_DAQ_CONFIG_ERROR,\n                (\"START_STOP_DAQ_LIST: cannot assign PIDs for DAQ list %d \\n\", daqListId));\n        }\n    }\n\n    /* Check the ODT configuration and also if the ODT sizes fits the Max DTO size */\n    if ((frame->mode == XCP_DAQ_LIST_START) || (frame->mode == XCP_DAQ_LIST_SELECT)) {\n        int i = 0;\n\n        ok = true;\n        for (i = 0; (i < daqList->odtCount) && ok; i++) {\n            int j = 0;\n            size_t odtSize = 0;\n\n            /* Calculate the resulting ODT size */\n            for (j = 0; j < daqList->odt[i].entriesCount; j++) {\n                odtSize += daqList->odt[i].entry[j].size;\n            }\n\n            /* Check that the resulting ODT size is valid */\n            if (IS_TIMESTAMP_REQUIRED(daqList->mode, i)){\n                ok = (XCP_IN_BYTES(odtSize * daqList->sampleCount + XCP_IN_AG(XCP_ID_FIELD_SIZE)) + XCP_TIMESTAMP_SIZE) <= xcpTransportMaxDtoSize();\n            }\n            else{\n                ok = (XCP_IN_BYTES(odtSize * daqList->sampleCount + XCP_IN_AG(XCP_ID_FIELD_SIZE))) <= xcpTransportMaxDtoSize();\n            }\n            XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_DAQ_CONFIG_ERROR,\n                (\"START_STOP_DAQ_LIST: in DAQ list %d the ODT entries size is larger than Max DTO size for ODT %d \\n\", daqListId, i));\n\n            /* Update the ODT size */\n            daqList->odt[i].size = odtSize;\n        }\n    }\n\n    /* Everything is fine -> proceed and change the DAQ list status */\n    locked = xcpDaqWriteLock(daqList->eventId);\n\n    if (locked) {\n        XcpErrorCode createPoolError = XCP_SUCCESS;\n\n        switch (frame->mode) {\n        case XCP_DAQ_LIST_STOP:\n            XCP_PRINTF(\"START_STOP_DAQ_LIST: stopping DAQ list %d\\n\", daqListId);\n            daqList->status = XCP_DAQ_STOPPED;\n            if (noActiveDaqLists()) {\n                /* update status if this was the only active DAQ list */\n                xcpStatusSet(XCP_CONNECTED);\n                xcpSessionStatusClearMask(XCP_SESSION_DAQ_RUNNING_MASK);\n            }\n            break;\n\n        case XCP_DAQ_LIST_START:\n            XCP_PRINTF(\"START_STOP_DAQ_LIST: starting DAQ list %d\\n\", daqListId);\n\n            /* daqList->poolId is initialized with XCP_INVALID_POOL_ID in\n               allocDaqInputPacketHandler.\n\n               Allocate a reserved memory pool for the DAQ list, if needed. */\n            if (daqList->poolId == XCP_INVALID_POOL_ID) {\n                if (IS_USING_CUSTOM_POOL(daqList->eventId)) {\n                    /* Forward custom memory information to the memory manager */\n                    createPoolError = xcpMemCustomPoolCreate(\n                                          xcpEventCustomMemoryManager.allocHandler, \n                                          xcpEventCustomMemoryManager.freeHandler,\n                                          &daqList->poolId);\n                } else if (daqListId < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER\n                    && daqList->eventId < XCP_MIN_EVENT_NO_RESERVED_POOL) {\n                    /* Create a reserved memory pool, if not already created */\n                    createPoolError = createDaqReservedPool(daqList);\n                    daqList->currentSample = 0;\n                }\n            }\n\n            if (createPoolError == XCP_SUCCESS) {\n                daqList->status = XCP_DAQ_STARTED;\n                xcpStatusSet(XCP_SYNC_DATA_TRANSFER);\n                xcpSessionStatusSetMask(XCP_SESSION_DAQ_RUNNING_MASK);\n            }\n            break;\n\n        case XCP_DAQ_LIST_SELECT:\n            XCP_PRINTF(\"START_STOP_DAQ_LIST: selected DAQ list %d\\n\", frame->daqListId);\n            daqList->status = XCP_DAQ_SELECTED;\n            break;\n        }\n\n        xcpDaqWriteUnlock(daqList->eventId);\n\n        *outputPacketSize = XCP_START_STOP_DAQ_LIST_RES_PACKET_SIZE_IN_BYTES;\n        XCP_INPUT_PKT_ERROR_IF(createPoolError != XCP_SUCCESS, XCP_PROTO_MEMORY_OVERFLOW,\n                (\"START_STOP_DAQ_LIST: cannot allocate reserved memory pool for the DAQ list\\n\"));\n    }\n\n    /* Error if the command cannot be executed as the processing of\n       at least one event was in progress */\n    XCP_INPUT_PKT_ERROR_IF(!locked, XCP_PROTO_BUSY,\n        (\"START_STOP_DAQ_LIST: cannot be carried out as an event was processed\\n\"));\n\n    return protoErrorCode;\n}\n\nstatic void startStopDaqListOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize)\n{\n    if (inputCode == XCP_PROTO_SUCCESS) {\n        XcpStartStopDaqListResPacketFrame *frame = (XcpStartStopDaqListResPacketFrame *)packet;\n\n        /* Fill the response */\n        frame->PID      = XCP_PID_RES;\n        frame->firstPid = xcpDynamicDaqLists.daq[startStopDaqListId].firstPid;\n    }\n    else {\n        genericOutputPacketHandler(inputCode, packet, packetSize);\n    }\n}\n\n/*****************************************************************************\n    XCP START_STOP_SYNCH\n******************************************************************************/\nstatic XcpProtoErrorCode startStopSynchInputPacketHandler(void   *msgBuffer,\n                                                          size_t  xcpPacketOffset,\n                                                          size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpStartStopSynchCmdPacketFrame *frame = (XcpStartStopSynchCmdPacketFrame *)packet;\n    boolean_T ok = false;\n    boolean_T locked = false;\n    int32_T i = 0;\n\n    /* Check if requested mode is valid */\n    ok = isValidStartStopSynchMode((uint8_T)frame->mode);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_MODE_NOT_VALID,\n        (\"START_STOP_SYNCH: invalid mode %d selected \\n\", frame->mode));\n\n    /* Check if the DAQ Lists are available */\n    ok = (xcpDynamicDaqLists.daq != NULL) && (xcpDynamicDaqLists.daqCount > 0);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"START_STOP_SYNCH: DAQ lists not available\\n\"));\n\n    /* Everything is fine -> proceed and try to change the DAQ list status */\n\n    /* Need to get the lock to guarantee that they are all done in the same cycle */\n    locked = xcpDaqLock();\n\n    if (locked) {\n        XcpErrorCode createPoolError = XCP_SUCCESS;\n        uint16_T daqListId = 0;\n\n        switch (frame->mode) {\n        case XCP_DAQ_LIST_STOP_ALL:\n            for (i = 0; i < xcpDynamicDaqLists.daqCount; i++) {\n                if (xcpDynamicDaqLists.daq[i].status != XCP_DAQ_INIT) {\n                    XCP_PRINTF(\"START_STOP_SYNCH: stopping DAQ list %d\\n\", i);\n                    xcpDynamicDaqLists.daq[i].status = XCP_DAQ_STOPPED;\n                }\n            }\n\n            /* update status as there are no more active DAQ list */\n            xcpStatusSet(XCP_CONNECTED);\n            xcpSessionStatusClearMask(XCP_SESSION_DAQ_RUNNING_MASK);\n            break;\n\n        case XCP_DAQ_LIST_START_SELECTED:\n            /* xcpDynamicDaqLists.daq[i].poolId is initialized with\n               XCP_INVALID_POOL_ID in allocDaqInputPacketHandler.\n\n               Allocate a reserved memory pool for the DAQ list, if needed. */\n            for (i = 0; (i < xcpDynamicDaqLists.daqCount) && (createPoolError == XCP_SUCCESS); i++) {\n                if ((xcpDynamicDaqLists.daq[i].status == XCP_DAQ_SELECTED) && \n                    (xcpDynamicDaqLists.daq[i].poolId == XCP_INVALID_POOL_ID)) {\n                    if (IS_USING_CUSTOM_POOL(xcpDynamicDaqLists.daq[i].eventId)) {\n                        /* Allocate custom pool if custom memory functions are\n                           provided for this eventId */\n                        createPoolError = xcpMemCustomPoolCreate(\n                                              xcpEventCustomMemoryManager.allocHandler,\n                                              xcpEventCustomMemoryManager.freeHandler,\n                                              &xcpDynamicDaqLists.daq[i].poolId);\n                    } else if (i < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER\n                        && xcpDynamicDaqLists.daq[i].eventId < XCP_MIN_EVENT_NO_RESERVED_POOL) {\n                        /* Create a reserved memory pool, if not already created */\n                        createPoolError = createDaqReservedPool(&xcpDynamicDaqLists.daq[i]);\n                        xcpDynamicDaqLists.daq[i].currentSample = 0;\n                        daqListId = (uint16_T) i;\n                    }\n                }\n            }\n\n            if (createPoolError == XCP_SUCCESS) {\n                /* If the allocation went well for all the DAQ lists, start them */\n                for (i = 0; (i < xcpDynamicDaqLists.daqCount); i++) {\n                    if (xcpDynamicDaqLists.daq[i].status == XCP_DAQ_SELECTED) {\n                        XCP_PRINTF(\"START_STOP_SYNCH: starting DAQ list %d\\n\", i);\n\n                        xcpDynamicDaqLists.daq[i].status = XCP_DAQ_STARTED;\n                        xcpStatusSet(XCP_SYNC_DATA_TRANSFER);\n                        xcpSessionStatusSetMask(XCP_SESSION_DAQ_RUNNING_MASK);\n                    }\n                }\n            }\n            break;\n\n        case XCP_DAQ_LIST_STOP_SELECTED:\n            for (i = 0; i < xcpDynamicDaqLists.daqCount; i++) {\n                if (xcpDynamicDaqLists.daq[i].status == XCP_DAQ_SELECTED) {\n                    XCP_PRINTF(\"START_STOP_SYNCH: stopping DAQ list %d\\n\", i);\n                    xcpDynamicDaqLists.daq[i].status = XCP_DAQ_STOPPED;\n                }\n            }\n\n            if (noActiveDaqLists()) {\n                /* update status if this was the only active DAQ list */\n                xcpStatusSet(XCP_CONNECTED);\n                xcpSessionStatusClearMask(XCP_SESSION_DAQ_RUNNING_MASK);\n            }\n            break;\n        }\n\n        /* Unlock all the events */\n        xcpDaqUnlock();\n\n        (void)daqListId; /* to suppress unused-but-set-variable when XCP_PRINTF is empty */\n        XCP_INPUT_PKT_ERROR_IF(createPoolError != XCP_SUCCESS, XCP_PROTO_MEMORY_OVERFLOW,\n                (\"START_STOP_SYNCH: cannot allocate reserved memory pool for the DAQ list %d\\n\", daqListId));\n\n        *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n    }\n\n    /* Error if the command cannot be executed as the processing of\n       at least one event was in progress */\n    XCP_INPUT_PKT_ERROR_IF(!locked, XCP_PROTO_BUSY,\n        (\"START_STOP_SYNCH: cannot be carried out as an event was processed\\n\"));\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP GET DAQ PROCESSOR INFO\n******************************************************************************/\nstatic XcpProtoErrorCode getDaqProcessorInfoInputPacketHandler(void   *msgBuffer,\n                                                               size_t  xcpPacketOffset,\n                                                               size_t *outputPacketSize)\n{\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    XCP_PRINTF(\"GET DAQ PROCESSOR INFO\\n\");\n\n    *outputPacketSize =  XCP_GET_DAQ_PROCESSOR_INFO_RES_PACKET_SIZE_IN_BYTES;\n\n    return XCP_PROTO_SUCCESS;\n}\n\nstatic void getDaqProcessorInfoOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize)\n{\n    XcpGetDaqProcessorInfoResPacketFrame *frame = (XcpGetDaqProcessorInfoResPacketFrame *)packet;\n\n    XCP_UNUSED_PARAM(inputCode);\n    XCP_UNUSED_PARAM(packetSize);\n\n    /* Fill Get Daq Processor Info response */\n    XCP_MEMSET(frame, 0, sizeof(*frame));\n\n    frame->PID = XCP_PID_RES;\n    frame->daqProperties = XCP_DAQ_PROPERTIES_VALUE;\n    frame->maxDaq = XCP_MAX_DAQ;\n    frame->maxEventChannel = XCP_MAX_EVENT_CHANNEL;\n    frame->minDaq = XCP_MIN_DAQ;\n    frame->daqKeyByte = XCP_DAQ_KEY_VALUE;\n\n    XCP_PRINTF(\"* DAQ Properties:    %xH\\n\", frame->daqProperties);\n    XCP_PRINTF(\"* MAX_DAQ:           %d\\n\", frame->maxDaq);\n    XCP_PRINTF(\"* MAX_EVENT_CHANNEL: %d\\n\", frame->maxEventChannel);\n    XCP_PRINTF(\"* MIN_DAQ:           %d\\n\", frame->minDaq);\n    XCP_PRINTF(\"* Daq Key Byte:      %xH\\n\", frame->daqKeyByte);\n}\n\n/*****************************************************************************\n    XCP GET DAQ RESOLUTION INFO\n******************************************************************************/\nstatic XcpProtoErrorCode getDaqResolutionInfoInputPacketHandler(void   *msgBuffer,\n    size_t  xcpPacketOffset,\n    size_t *outputPacketSize)\n{\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    XCP_PRINTF(\"GET DAQ RESOLUTION INFO\\n\");\n\n    *outputPacketSize = XCP_GET_DAQ_RESOLUTION_INFO_RES_PACKET_SIZE_IN_BYTES;\n\n    return XCP_PROTO_SUCCESS;\n}\n\nstatic void getDaqResolutionInfoOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize)\n{\n    XcpGetDaqResolutionInfoResPacketFrame *frame = (XcpGetDaqResolutionInfoResPacketFrame *)packet;\n\n    XCP_UNUSED_PARAM(inputCode);\n    XCP_UNUSED_PARAM(packetSize);\n\n    /* Fill Get Daq Resolution Info response */\n    XCP_MEMSET(frame, 0, sizeof(*frame));\n\n    frame->PID = XCP_PID_RES;\n\n    /* @note in the current version the same limits apply for DAQ and STIM */\n    frame->daqOdtEntrySizeGranularity = XCP_ODT_ENTRY_SIZE_GRANULARITY;\n    frame->maxDaqOdtEntrySize = XCP_MAX_ODT_ENTRY_SIZE;\n    frame->stimOdtEntrySizeGranularity = XCP_ODT_ENTRY_SIZE_GRANULARITY;\n    frame->maxStimOdtEntrySize = XCP_MAX_ODT_ENTRY_SIZE;\n    frame->timestampMode = XCP_TIMESTAMP_MODE_VALUE;\n    frame->timestampTicks = XCP_TIMESTAMP_TICKS;\n\n    XCP_PRINTF(\"* DAQ ODT Entry size granularity:   %d\\n\",  frame->daqOdtEntrySizeGranularity);\n    XCP_PRINTF(\"* Max DAQ ODT Entry size:           %d\\n\",  frame->maxDaqOdtEntrySize);\n    XCP_PRINTF(\"* STIM ODT Entry size granularity:  %d\\n\",  frame->stimOdtEntrySizeGranularity);\n    XCP_PRINTF(\"* Max STIM ODT Entry size:          %d\\n\",  frame->maxStimOdtEntrySize);\n    XCP_PRINTF(\"* Timestamp Mode =                  %xH\\n\", frame->timestampMode);\n    XCP_PRINTF(\"* Timestamp Ticks =                 %d\\n\",  frame->timestampTicks);\n}\n\n/*****************************************************************************\n    XCP FREE_DAQ\n******************************************************************************/\nstatic XcpProtoErrorCode freeDaqInputPacketHandler(void   *msgBuffer,\n                                                   size_t  xcpPacketOffset,\n                                                   size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    boolean_T ok = false;\n\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    XCP_PRINTF(\"FREE_DAQ: clearing existing dynamic DAQ lists\\n\");\n    ok = xcpResetDaqListStatus();\n\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_BUSY,\n        (\"FREE_DAQ: cannot be carried out as an event was processed\\n\"));\n\n    /* No DAQ lists are running -> XCP_SYNC_DATA_TRANSFER cannot be active anymore */\n    xcpStatusSet(XCP_CONNECTED);\n\n    /* Everything is fine -> send positive response */\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP ALLOC_DAQ\n******************************************************************************/\nstatic XcpProtoErrorCode allocDaqInputPacketHandler(void   *msgBuffer,\n                                                    size_t  xcpPacketOffset,\n                                                    size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpAllocDaqCmdPacketFrame *frame = (XcpAllocDaqCmdPacketFrame *) packet;\n    int32_T daqCount = (uint16_T)frame->daqCount;\n    XcpDaq *daq = NULL;\n    boolean_T ok = false;\n    int i = 0;\n\n    /* Check if DAQ lists have already been allocated */\n    ok = xcpDynamicDaqLists.daq == NULL;\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_SEQUENCE_ERROR,\n        (\"ALLOC_DAQ: sequence error detected, DAQ lists already allocated\\n\"));\n\n    /* Check if the number of DAQ lists requested is supported */\n    ok = (daqCount > 0) && (daqCount <= (XCP_MAX_DAQ - XCP_MIN_DAQ));\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"ALLOC_DAQ: invalid number of DAQ lists (%d)\\n\", daqCount));\n\n    XCP_PRINTF(\"ALLOC_DAQ: allocating %d DAQ lists (%lu B)\\n\", daqCount, (unsigned long) ((size_t)daqCount * sizeof(XcpDaq)));\n\n    /* Proceed and allocate the DAQ lists */\n    daq = (XcpDaq *)xcpMemAlloc((size_t) daqCount * sizeof(XcpDaq));\n    XCP_INPUT_PKT_ERROR_IF(daq == NULL, XCP_PROTO_MEMORY_OVERFLOW,\n        (\"ALLOC_DAQ: not enough memory to allocate %d DAQ lists\\n\", daqCount));\n\n    XCP_MEMSET(daq, 0, (size_t)daqCount * sizeof(XcpDaq));\n\n    /* Make sure that the DAQ lists are available for use */\n    xcpDynamicDaqLists.daq = daq;\n    xcpDynamicDaqLists.daqCount = (uint16_T) daqCount;\n\n    for (i = 0; i < daqCount; i++) {\n        daq[i].poolId        = XCP_INVALID_POOL_ID;\n        daq[i].packedMode    = XCP_DAQ_DATA_NOT_PACKED;\n        daq[i].timestampMode = XCP_DAQ_SINGLE_TIMESTAMP_FIRST_SAMPLE;\n        daq[i].sampleCount   = 1;\n        daq[i].currentSample = 0;\n    }\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP ALLOC_ODT\n******************************************************************************/\nstatic XcpProtoErrorCode allocOdtInputPacketHandler(void   *msgBuffer,\n                                                    size_t  xcpPacketOffset,\n                                                    size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpAllocOdtCmdPacketFrame *frame = (XcpAllocOdtCmdPacketFrame *)packet;\n    uint16_T daqListId = (uint16_T)frame->daqListId;\n    uint8_T  odtCount  = (uint8_T)frame->odtCount;\n    boolean_T ok = false;\n\n    /* Check if DAQ lists have already been allocated */\n    ok = (xcpDynamicDaqLists.daq != NULL);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_SEQUENCE_ERROR,\n        (\"ALLOC_ODT: sequence error detected, DAQ lists not allocated\\n\"));\n\n    /* Check if the DAQ List Id is valid */\n    ok = (daqListId < xcpDynamicDaqLists.daqCount);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"ALLOC_ODT: DAQ list id %d is out of range\\n\", daqListId));\n\n    /* Check if the number of ODTs is valid */\n    ok = (odtCount > 0) && (odtCount <= XCP_MAX_DAQ_ODT_NUMBER);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"ALLOC_ODT: invalid number of ODT (%d) for DAQ list id %d\\n\", odtCount, daqListId));\n\n    /* Check if the ODTs have already been allocated */\n    ok = (xcpDynamicDaqLists.daq[daqListId].odt == NULL);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_SEQUENCE_ERROR,\n        (\"ALLOC_ODT: sequence error detected, ODT already allocated\\n\"));\n\n    XCP_PRINTF(\"ALLOC_ODT: allocating %d ODTs in DAQ list %d (%lu B)\\n\",\n        odtCount, daqListId, (unsigned long)(odtCount * sizeof(XcpOdt)));\n\n    /* Everything is fine -> proceed and allocate the ODTs */\n    xcpDynamicDaqLists.daq[daqListId].odt = (XcpOdt *)xcpMemAlloc(odtCount * sizeof(XcpOdt));\n    XCP_INPUT_PKT_ERROR_IF(xcpDynamicDaqLists.daq[daqListId].odt == NULL, XCP_PROTO_MEMORY_OVERFLOW,\n        (\"ALLOC_ODT: not enough memory to allocate %d ODT in DAQ list %d\\n\", odtCount, daqListId));\n\n    XCP_MEMSET(xcpDynamicDaqLists.daq[daqListId].odt, 0, odtCount * sizeof(XcpOdt));\n\n    xcpDynamicDaqLists.daq[daqListId].odtCount = odtCount;\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP ALLOC_ODT_ENTRY\n******************************************************************************/\nstatic XcpProtoErrorCode allocOdtEntryInputPacketHandler(void   *msgBuffer,\n    size_t  xcpPacketOffset,\n    size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpAllocOdtEntryCmdPacketFrame *frame = (XcpAllocOdtEntryCmdPacketFrame *)packet;\n    uint16_T daqListId       = (uint16_T)frame->daqListId;\n    uint8_T  odtId           = (uint8_T)frame->odtId;\n    uint8_T  odtEntriesCount = (uint8_T)frame->odtEntriesCount;\n    boolean_T ok = false;\n\n    /* Check if the DAQ lists have already been allocated */\n    ok = (xcpDynamicDaqLists.daq != NULL);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_SEQUENCE_ERROR,\n        (\"ALLOC_ODT_ENTRY: sequence error detected, DAQ lists not allocated\\n\"));\n\n    /* Check if the DAQ List Id is valid */\n    ok = (daqListId < xcpDynamicDaqLists.daqCount);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"ALLOC_ODT_ENTRY: DAQ list id %d is out of range\\n\", daqListId));\n\n    /* Check if the ODTs have already been allocated */\n    ok = (xcpDynamicDaqLists.daq[daqListId].odt != NULL);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_SEQUENCE_ERROR,\n        (\"ALLOC_ODT_ENTRY: sequence error detected, ODTs not allocated\\n\"));\n\n    /* Check if the ODT Id is valid */\n    ok = (odtId < xcpDynamicDaqLists.daq[daqListId].odtCount);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"ALLOC_ODT_ENTRY: ODT id %d is out of range\\n\", odtId));\n\n    /* Check if the ODT entries have already been allocated */\n    ok = (xcpDynamicDaqLists.daq[daqListId].odt[odtId].entry == NULL);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_SEQUENCE_ERROR,\n        (\"ALLOC_ODT_ENTRY: sequence error detected, ODT Entries already allocated\\n\"));\n\n    /* Check if the number of ODT Entries is valid */\n    ok = (odtEntriesCount > 0);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"ALLOC_ODT_ENTRY: invalid number of ODT entries (%d) for ODT %d in DAQ list %d\\n\", odtEntriesCount, odtId, daqListId));\n\n    XCP_PRINTF(\"ALLOC_ODT_ENTRY: allocating %d ODT Entries in DAQ list %d ODT %d (%lu B)\\n\", \n        odtEntriesCount, daqListId, odtId, (unsigned long)(odtEntriesCount * sizeof(XcpOdtEntry)));\n\n    /* Everything is fine -> proceed and allocate the ODT entries */\n    xcpDynamicDaqLists.daq[daqListId].odt[odtId].entry = (XcpOdtEntry *)xcpMemAlloc(odtEntriesCount * sizeof(XcpOdtEntry));\n\n    XCP_INPUT_PKT_ERROR_IF(xcpDynamicDaqLists.daq[daqListId].odt[odtId].entry == NULL, XCP_PROTO_MEMORY_OVERFLOW,\n        (\"ALLOC_ODT_ENTRY: not enough memory to allocate %d ODT in DAQ list %d ODT %d\\n\", odtEntriesCount, daqListId, odtId));\n\n    XCP_MEMSET(xcpDynamicDaqLists.daq[daqListId].odt[odtId].entry, 0, odtEntriesCount * sizeof(XcpOdtEntry));\n\n    xcpDynamicDaqLists.daq[daqListId].odt[odtId].entriesCount = odtEntriesCount;\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP GET DAQ CLOCK\n******************************************************************************/\n\nstatic XcpProtoErrorCode getDaqClockInputPacketHandler(void *msgBuffer,\n                                                       size_t xcpPacketOffset,\n                                                       size_t *outputPacketSize)\n{\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n    *outputPacketSize = XCP_ERROR_PACKET_SIZE_IN_BYTES;\n    return XCP_PROTO_RESOURCE_NOT_ACCESSIBLE;\n}\n\n/*****************************************************************************\n    XCP LEVEL1 COMMAND\n******************************************************************************/\n\n/* The only supported Level 1 command is SET DAQ PACKED MODE */\nstatic XcpProtoErrorCode setDaqPackedModeInputPacketHandler(void   *msgBuffer,\n                                                            size_t  xcpPacketOffset,\n                                                            size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpSetDaqPackedModeCmdPacketFrame *frame = (XcpSetDaqPackedModeCmdPacketFrame *)packet;\n    uint16_T daqListId        = (uint16_T) frame->daqListId;\n    uint8_T  daqPackedMode    = (uint8_T)  frame->daqPackedMode;\n    uint8_T  dpmTimestampMode = (uint8_T)  frame->dpmTimestampMode;\n    uint16_T dpmSampleCount   = (uint16_T) frame->dpmSampleCount;\n    boolean_T ok = true;\n\n    /* Check if the DAQ lists have already been allocated */\n    ok = (xcpDynamicDaqLists.daq != NULL);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_SEQUENCE_ERROR,\n        (\"SET_DAQ_PACKED_MODE: sequence error detected, DAQ lists not allocated\\n\"));\n\n    /* Check if the DAQ List Id is valid */\n    ok = (daqListId < xcpDynamicDaqLists.daqCount);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"SET_DAQ_PACKED_MODE: DAQ list id %d is out of range\\n\", daqListId));\n\n#if XCP_MEM_DAQ_RESERVED_POOLS_NUMBER > 0\n    /* DAQ Packed Mode is only supported for DAQ lists with a reserved memory pool */\n    ok = (daqListId < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_MODE_NOT_VALID,\n        (\"SET_DAQ_PACKED_MODE: packed mode is not supported for DAQ list id %d, with no reserved memory pool\\n\", daqListId));\n#else\n    ok = false;\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_MODE_NOT_VALID,\n        (\"SET_DAQ_PACKED_MODE: packed mode is not supported for DAQ list id %d, with no reserved memory pool\\n\", daqListId));\n#endif\n\n    /* Check if the selected DAQ packed mode is valid. \n       Currently we only support event-grouped data packing */\n    ok = ((daqPackedMode == XCP_DAQ_DATA_NOT_PACKED) || \n          (daqPackedMode == XCP_DAQ_EVENT_GROUPED_PACKING));\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_MODE_NOT_VALID,\n        (\"SET_DAQ_PACKED_MODE: DAQ Packed mode %d is not supported\\n\", daqPackedMode));\n\n    /* Check if the selected DAQ Timestamp mode is valid. \n       Currently we only support single timestamp of the first sample */\n    ok = (dpmTimestampMode == XCP_DAQ_SINGLE_TIMESTAMP_FIRST_SAMPLE);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_MODE_NOT_VALID,\n        (\"SET_DAQ_PACKED_MODE: DAQ Packed timestamp mode %d is not supported\\n\", dpmTimestampMode));\n\n    /* Check if the selected DAQ Packed sample count is valid. */\n    ok = ((daqPackedMode == XCP_DAQ_DATA_NOT_PACKED && (dpmSampleCount == 1)) ||\n         ((daqPackedMode != XCP_DAQ_DATA_NOT_PACKED) && (dpmSampleCount >= XCP_DAQ_PACKED_SAMPLE_COUNT_MIN)));\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_MODE_NOT_VALID,\n        (\"SET_DAQ_PACKED_MODE: DAQ Packed sample count %d is not supported.\\n\", dpmSampleCount));\n\n    /* Check that the DAQ list is not already running */\n    ok = !isActiveDaqList(daqListId);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_DAQ_ACTIVE,\n        (\"SET_DAQ_PACKED_MODE: packed mode configuration cannot be changed if the DAQ is running.\\n\"));\n\n    /* Finally: select the new configuration */\n    XCP_PRINTF(\"SET_DAQ_PACKED_MODE: setting packed mode %d timestamp mode %d sample count %d\\n\", \n               daqPackedMode, dpmTimestampMode, dpmSampleCount);\n\n    xcpDynamicDaqLists.daq[daqListId].packedMode    = daqPackedMode;\n    xcpDynamicDaqLists.daq[daqListId].timestampMode = dpmTimestampMode;\n    xcpDynamicDaqLists.daq[daqListId].sampleCount   = dpmSampleCount;\n    xcpDynamicDaqLists.daq[daqListId].currentSample = 0;\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\nstatic XcpProtoErrorCode level1CommandInputPacketHandler(void  *msgBuffer,\n                                                        size_t  xcpPacketOffset,\n                                                        size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    XcpLevel1CommandPacketFrame* command = (XcpLevel1CommandPacketFrame*) ((uint8_T *)msgBuffer + xcpPacketOffset);\n    boolean_T ok = (command->level1Code == XCP_DAQ_LEVEL1_CODE_SET_DAQ_PACKED_MODE);\n\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_CMD_UNKNOWN,\n        (\"DAQ LEVEL1 COMMAND: command code %d is not supported\\n\", command->level1Code));\n\n    /* The only supported Level 1 command is SET_DAQ_PACKED_MODE */\n    protoErrorCode = setDaqPackedModeInputPacketHandler(msgBuffer, xcpPacketOffset, outputPacketSize);\n\n    return protoErrorCode;\n}\n\n\n/** This table contains the list of supported Rx packets and the corresponding handlers */\nstatic const XcpPacketHandlers daqSupportedRxPacket[] =\n{\n    { XCP_PID_START_STOP_DAQ_LIST,     startStopDaqListInputPacketHandler,     startStopDaqListOutputPacketHandler },\n    { XCP_PID_START_STOP_SYNCH,        startStopSynchInputPacketHandler,       genericOutputPacketHandler },\n    { XCP_PID_GET_DAQ_PROCESSOR_INFO,  getDaqProcessorInfoInputPacketHandler,  getDaqProcessorInfoOutputPacketHandler},\n    { XCP_PID_GET_DAQ_RESOLUTION_INFO, getDaqResolutionInfoInputPacketHandler, getDaqResolutionInfoOutputPacketHandler },\n    { XCP_PID_SET_DAQ_PTR,             setDaqPtrInputPacketHandler,            genericOutputPacketHandler },\n    { XCP_PID_WRITE_DAQ,               writeDaqInputPacketHandler,             genericOutputPacketHandler },\n    { XCP_PID_SET_DAQ_LIST_MODE,       setDaqListModeInputPacketHandler,       genericOutputPacketHandler },\n    { XCP_PID_FREE_DAQ,                freeDaqInputPacketHandler,              genericOutputPacketHandler },\n    { XCP_PID_ALLOC_DAQ,               allocDaqInputPacketHandler,             genericOutputPacketHandler },\n    { XCP_PID_ALLOC_ODT,               allocOdtInputPacketHandler,             genericOutputPacketHandler },\n    { XCP_PID_ALLOC_ODT_ENTRY,         allocOdtEntryInputPacketHandler,        genericOutputPacketHandler },\n    { XCP_PID_GET_DAQ_CLOCK,           getDaqClockInputPacketHandler,          genericOutputPacketHandler },\n    { XCP_PID_LEVEL1_COMMAND,          level1CommandInputPacketHandler,        genericOutputPacketHandler }\n};\n\n\n\n/*****************************************************************************\n    XCP Packet Lookup Function for basic DAQ commands\n******************************************************************************/\n\n/* Default DAQ Packet Lookup function, supporting only basic commands\n   listed in the table above */\nstatic const XcpPacketHandlers* getPacket(XcpRxPidCode pid)\n{\n    return xcpFindPacket(pid, daqSupportedRxPacket,\n                         XCP_ELEMENTS_NUMBER(daqSupportedRxPacket));\n}\n\nstatic XcpPacketLookupFunction packetLookup = NULL;\n\n\n\n/*****************************************************************************\n    Public Functions (invoked within the Protocol Layer)\n******************************************************************************/\nvoid xcpDaqInit(void)\n{\n#if !defined(XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK) || (XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK == 0)\n    XCP_MUTEX_INIT(daqLock);\n#else\n    uint16_T i = 0;\n\n    /* Initialize Event locks */\n    for (i = 0; i < XCP_MAX_EVENT_DATA_NUMBER; i++) {\n        XCP_MUTEX_INIT(xcpEventData[i].lock);\n    }\n#endif\n\n    xcpRunningEventCounter = 0;\n    XCP_MEMSET(&xcpDynamicDaqLists, 0, sizeof(xcpDynamicDaqLists));\n\n    /* Initialize the packet lookup function to support only basic\n       DAQ commands */\n    xcpDaqSetPacketLookup(getPacket);\n\n    /* Initialize support for the extended list of DAQ commands\n       @note this may override the default Packet lookup function\n             by adding support for more (optional) commands */\n    xcpDaqExtendedInit();\n}\n\n\nXcpPacketLookupFunction xcpDaqGetPacketLookup(void)\n{\n    return packetLookup;\n}\n\n\nvoid xcpDaqSetPacketLookup(XcpPacketLookupFunction getPacketFcn)\n{\n    packetLookup = getPacketFcn;\n}\n\n/**\n Reset a DAQ list, deleting any partial packet associated with it. This can only happen if the DAQ\n list is using packed mode.\n*/\nstatic XcpErrorCode xcpResetDaq(uint16_T daqIndex) {\n    int i = 0;\n    XcpDaq *daq = NULL;\n\n    XCP_ERROR_IF(\n        xcpDynamicDaqLists.daq == NULL || xcpDynamicDaqLists.daqCount <= daqIndex,\n        XCP_INV_ARG,\n        \"xcpProcessDaq: invalid daqIndex\");\n\n    daq = &xcpDynamicDaqLists.daq[daqIndex];\n\n    /* Resetting only needs to do something if a DAQ list is using packed mode and has started\n        writing the packet */\n    if (!isDaqPackedModeEnabled(daqIndex) || daq->currentSample == 0) {\n        return XCP_SUCCESS;\n    }\n\n    for (i = 0; i < daq->odtCount; ++i) {\n        xcpMemFree(daq->odt[i].msgBuffer);\n    }\n\n    daq->currentSample = 0;\n\n    return XCP_SUCCESS;\n}\n\n/**\n Writes xcp data needed at the beginning of an XCP packet for the given ODT. `currentValuePtr` and\n `offsetBytes` are updated accordingly.\n @note The current implementation only supports absolute ODT number.\n*/\nstatic void daqWriteXCPDataForOdt(XcpDaq* daq, uint8_T odtNumber, uint32_T timestamp) {\n    XcpOdt *odt = &daq->odt[odtNumber];\n    uint8_T *packet = odt->currentValuePtr;\n\n#ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n    odt->offsetBytes = (XCP_IN_AG(XCP_ID_FIELD_SIZE)) % XCP_HARDWARE_ADDRESS_GRANULARITY_BYTES_NUMBER;\n#else\n    /* Dummy variable used when we are not emulating as BYTE addressable target */\n    odt->offsetBytes = 0;\n#endif\n\n    /* Fill the Identification Field first\n    @note this is hard-coded to support absolute ODT number at the moment */\n    *packet = (uint8_T)(daq->firstPid + odtNumber);\n    packet = XCP_HW_PTR_INCREMENT(packet, XCP_IN_AG(XCP_ID_FIELD_SIZE), odt->offsetBytes);\n\n    /* Add the timestamp for the first DTO\n    @note this is hard-coded to support timestamp size of 4 bytes */\n    if (IS_TIMESTAMP_REQUIRED(daq->mode, odtNumber)) {\n    #ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n        size_t srcOffsetBytes = 0;\n        xcpMemcpyByte(packet, odt->offsetBytes, &timestamp, srcOffsetBytes, XCP_IN_HW_BYTES(sizeof(timestamp)));\n    #else\n        XCP_MEMCPY(packet, &timestamp, sizeof(timestamp));\n    #endif\n\n        packet = XCP_HW_PTR_INCREMENT(packet, XCP_IN_AG(XCP_TIMESTAMP_SIZE + odt->offsetBytes), odt->offsetBytes);\n        odt->offsetBytes = XCP_HW_BYTE_OFFSET_UPDATE(odt->offsetBytes, XCP_IN_AG(XCP_TIMESTAMP_SIZE));\n    }\n    odt->currentValuePtr = packet;\n}\n\n/**\n Writes the value of the entries for the given ODT, at the memory pointed by `currentValuePtr` and\n `offsetBytes`, which are updated accordingly.\n*/\nstatic void odtWriteEntries(XcpOdt *odt) {\n    uint8_T entryIndex = 0;\n    uint8_T *packet = odt->currentValuePtr;\n\n    for (entryIndex = 0; entryIndex < odt->entriesCount; ++entryIndex) {\n        XcpOdtEntry *entry = &(odt->entry[entryIndex]);\n        uint8_T const* address = XCP_ADDRESS_GET_READ(entry->addressExtension, entry->address);\n\n        if (entry->bitOffset != 0xFF) {\n            /* Bitwise access has been selected */\n        #ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n            uint32_T dword;\n            uint8_T bitValue;\n            size_t srcOffsetBytes = XCP_BYTE_OFFSET_GET(entry->address);\n            xcpMemcpyByte(&dword, 0, address, srcOffsetBytes, 4);\n            bitValue = (uint8_T) ((dword & ((uint32_T)(1 << entry->bitOffset))) != 0);\n            xcpMemcpyByte(packet, odt->offsetBytes, &bitValue, 0, entry->size);\n        #else\n            uint32_T const* dword = (uint32_T const*)address;\n            *packet = (uint8_T) ((*dword & ((uint32_T)(1 << entry->bitOffset))) != 0);\n        #endif\n        }\n        else {\n            /* 'Normal' (non-bitwise) access has been selected */\n        #ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n            size_t srcOffsetBytes = XCP_BYTE_OFFSET_GET(entry->address);\n            xcpMemcpyByte(packet, odt->offsetBytes, address, srcOffsetBytes, entry->size);\n        #else\n            XCP_MEMCPY(packet, address, entry->size);\n        #endif\n        }\n\n        packet = XCP_HW_PTR_INCREMENT(packet, entry->size + odt->offsetBytes, odt->offsetBytes);\n        odt->offsetBytes = XCP_HW_BYTE_OFFSET_UPDATE(odt->offsetBytes, entry->size);\n    }\n\n    odt->currentValuePtr = packet;\n}\n\n/**\n Process a DAQ, allocate memory, write pid and timestamp if needed, and copies variables values in\n the XCP packet.\n */\nstatic XcpErrorCode xcpProcessDaq(uint16_T daqIndex, uint32_T timestamp, XcpTransportQueueType_T txQueue) {\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    boolean_T error = false;\n    XcpDaq *daq = NULL;\n    uint8_T odtIndex = 0;\n    boolean_T daqPackedModeEnabled = false;\n    boolean_T transmitRequest = false;\n\n    XCP_ERROR_IF(\n        xcpDynamicDaqLists.daq == NULL || xcpDynamicDaqLists.daqCount <= daqIndex,\n        XCP_INV_ARG,\n        \"xcpProcessDaq: invalid daqIndex\");\n\n    daq = &xcpDynamicDaqLists.daq[daqIndex];\n\n    daqPackedModeEnabled = isDaqPackedModeEnabled(daqIndex);\n    /* In packed Mode we only want to transmit when the expected number of \n        samples has been reached */\n    transmitRequest = !daqPackedModeEnabled ||\n                                ((daq->currentSample + 1) == daq->sampleCount);\n\n    /* @note prescaler is not supported at the moment */\n    for (odtIndex = 0; (odtIndex < daq->odtCount) && !error; odtIndex++) {\n        XcpOdt *odt = &daq->odt[odtIndex];\n        size_t packetOffset = xcpTransportPacketOffset();\n        size_t msgBufferSize = 0;\n\n        /* when packed mode is active the allocation occurs at the first sample */\n        boolean_T requestNewMessageBuffer = !daqPackedModeEnabled || (daq->currentSample == 0);\n\n        if (requestNewMessageBuffer) {\n            /* Calculate the required XCP packet size */\n            odt->packetSize = odtPacketSize(daq, odtIndex);\n\n            /* Calculate the overall message buffer */\n            msgBufferSize = xcpTransportMsgBufferSize(odt->packetSize, XCP_DTO);\n\n            if (daq->poolId != XCP_INVALID_POOL_ID) {\n                /* A dedicated memory pool is available */\n                odt->msgBuffer = (uint8_T *)xcpMemAllocFromPool(daq->poolId, msgBufferSize);\n            } else {\n                /* No memory pool available, use the Main memory instead */\n                odt->msgBuffer = (uint8_T *)xcpMemAlloc(msgBufferSize);\n            }\n\n            if (odt->msgBuffer != NULL) {\n                /* Allocation went well, set current pointer to the beginning of the XCP packet */\n                odt->currentValuePtr = odt->msgBuffer + packetOffset;\n\n                /* let's fill the PID and timestamp field if required */\n                daqWriteXCPDataForOdt(daq, odtIndex, timestamp);\n\n            } else {\n                /* An issue occurred during the memory allocation */\n                error = true;\n                errorCode = XCP_NO_MEMORY;\n            }\n        }\n\n        if (!error && (odt->msgBuffer != NULL)) {\n            if (!IS_USING_CUSTOM_POOL(daq->eventId)) {\n                odtWriteEntries(odt);\n            }\n\n            if (transmitRequest) {\n                /* Send the response back to the Transport Layer */\n                /* Calculate the overall message buffer */\n                msgBufferSize = xcpTransportMsgBufferSize(odt->packetSize, XCP_DTO);\n\n                errorCode = xcpTransportTxPacketSet(txQueue,\n                                                    daqIndex,\n                                                    odt->msgBuffer, msgBufferSize,\n                                                    packetOffset, odt->packetSize);\n                if (errorCode != XCP_SUCCESS) {\n                    xcpMemFree(odt->msgBuffer);\n                }\n            }\n        }\n    }\n\n    daq->currentSample = (daq->currentSample + 1) % daq->sampleCount;\n\n    return errorCode;\n}\n\nXcpErrorCode xcpDaqEvent(XcpEventIdType eventId, uint32_T timestamp, boolean_T resetSamples)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    /* The lock is used to protect against the concurrent execution of XCP commands\n    (within xcpRun()) that can modify the DAQ list data structures */\n    xcpDaqReadLock(eventId);\n\n    if ((xcpDynamicDaqLists.daq != NULL) && (xcpDynamicDaqLists.daqCount > 0)) {\n        uint16_T i = 0;\n        XcpDaq *daq = xcpDynamicDaqLists.daq;\n\n        for (i = 0; (i < xcpDynamicDaqLists.daqCount) && errorCode == XCP_SUCCESS; i++) {\n            if (!XCP_READ_BIT_VALUE(daq[i].mode, XCP_DAQ_MODE_DIRECTION_MASK) && /* it's a DAQ list */\n                (daq[i].status == XCP_DAQ_STARTED) &&                            /* it's running */\n                (daq[i].eventId == eventId)) {                                   /* and associated to this event */\n\n                boolean_T txReady = xcpTransportTxReady(XCP_TRANSPORT_TX_DEFAULT_QUEUE, i);\n                XcpTransportQueueType_T txQueue = txReady ? XCP_TRANSPORT_TX_DEFAULT_QUEUE :\n                                                            XCP_TRANSPORT_DEFERRED_TX_QUEUE;\n\n            #ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n                if (txReady &&\n                    (daq[i].poolId != XCP_INVALID_POOL_ID)) {\n                    /* If the Tx queue is ready, it is safe to flush the free memory,\n                        so that the deferred free blocks become available for subsequent allocations */\n                    xcpMemReservedPoolFlushFreeMem(daq[i].poolId);\n                }\n            #endif\n\n                if (resetSamples) {\n                    errorCode = xcpResetDaq(i);\n                } else {\n                    errorCode = xcpProcessDaq(i, timestamp, txQueue);\n                }\n\n                if (txReady) {\n                /* Trigger the transmission of the packets that have been enqueued\n                    for this DAQ list */\n                    xcpTransportTxTrigger(XCP_TRANSPORT_TX_DEFAULT_QUEUE, i);\n                }\n\n            }\n        }\n    }\n\n    xcpDaqReadUnlock(eventId);\n\n    return errorCode;\n}\n\nXcpErrorCode xcpDaqEventsFlush(uint32_T timestamp)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    XCP_UNUSED_PARAM(timestamp);\n\n    if (xcpDynamicDaqLists.daq != NULL) {\n        boolean_T locked = xcpDaqLock();\n\n        if (locked) {\n            XcpDaq  *daq = xcpDynamicDaqLists.daq;\n            int32_T  daqCount = xcpDynamicDaqLists.daqCount;\n            uint16_T i = 0;\n\n            for (i = 0; i < daqCount; i++) {\n                boolean_T daqPackedModeEnabled = isDaqPackedModeEnabled(i);\n\n                if (daqPackedModeEnabled &&\n                    (daq[i].status == XCP_DAQ_STARTED) &&\n                    (daq[i].currentSample > 0)) {\n                    \n                    boolean_T txReady = xcpTransportTxReady(XCP_TRANSPORT_TX_DEFAULT_QUEUE, i);\n                    XcpTransportQueueType_T txQueue = txReady ? XCP_TRANSPORT_TX_DEFAULT_QUEUE :\n                                                            XCP_TRANSPORT_DEFERRED_TX_QUEUE;\n                    uint16_T j = 0;\n\n                    for (j = 0; j < daq[i].odtCount; j++) {\n                        if (daq[i].odt[j].msgBuffer != NULL) {\n                            size_t msgBufferSize = xcpTransportMsgBufferSize(daq[i].odt[j].packetSize, XCP_DTO);\n                            size_t packetOffset = xcpTransportPacketOffset();\n                            uint8_T *packet = daq[i].odt[j].msgBuffer + packetOffset;\n                            size_t notInitializedDataSize = XCP_IN_HW_AG(daq[i].odt[j].packetSize) - \n                                                             ((size_t) (daq[i].odt[j].currentValuePtr - packet));\n\n                            XCP_MEMSET(daq[i].odt[j].currentValuePtr, 0, notInitializedDataSize);\n\n                            errorCode = xcpTransportTxPacketSet(txQueue,\n                                                                i,\n                                                                daq[i].odt[j].msgBuffer, msgBufferSize,\n                                                                packetOffset, daq[i].odt[j].packetSize);\n                            if (errorCode != XCP_SUCCESS) {\n                                xcpMemFree(daq[i].odt[j].msgBuffer);\n                            }\n\n                        }\n                    }\n\n                    daq[i].currentSample = 0;\n                }\n            }\n\n            xcpDaqUnlock();\n        } else {\n            errorCode = XCP_BUSY;\n        }\n    }\n\n    return errorCode;\n}\n\n\n\nboolean_T xcpDaqLock(void)\n{\n    boolean_T locked = true;\n#if !defined(XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK) || (XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK == 0)\n    locked = xcpDaqWriteLock(0);\n#else\n    XcpEventIdType i = 0;\n\n    for(i = 0; i < XCP_MAX_EVENT_DATA_NUMBER; i++) {\n        xcpDaqWriteLock(i);\n    }\n#endif\n    return locked;\n}\n\n\n/* Unlock DAQ list transmission */\nvoid xcpDaqUnlock(void)\n{\n#if !defined(XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK) || (XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK == 0)\n    xcpDaqWriteUnlock(0);\n#else\n    XcpEventIdType i = 0;\n\n    for(i = 0; i < XCP_MAX_EVENT_DATA_NUMBER; i++) {\n        /* Unlock in reverse order, to prevent deadlock */\n    \txcpDaqWriteUnlock(XCP_MAX_EVENT_DATA_NUMBER - 1 - i);\n    }\n#endif\n}\n\n\nboolean_T xcpResetDaqListStatus(void)\n{\n    boolean_T locked = true;\n\n    if (xcpDynamicDaqLists.daq != NULL) {\n        XcpDaq *daq = xcpDynamicDaqLists.daq;\n        int32_T  daqCount = xcpDynamicDaqLists.daqCount;\n\n        locked = xcpDaqLock();\n\n        if (locked) {\n            /* No events were processed, it's safe to remove the DAQ lists */\n            int32_T i = 0;\n            int32_T j = 0;\n\n            /* No events are currently running,\n               it's safe to remove the DAQ lists */\n            xcpDynamicDaqLists.daq = NULL;\n            xcpDynamicDaqLists.daqCount = 0;\n            xcpDynamicDaqLists.firstAvailableDaqPid = 0;\n            xcpDynamicDaqLists.firstAvailableStimPid = 0;\n            \n            /* Reset ID of the DAQ List selected by START_STOP_DAQ_LIST command */\n            startStopDaqListId = XCP_INVALID_DAQ_LIST_ID;\n\n            /* Let's release the locks */\n            xcpDaqUnlock();\n\n            /* Prepare the Transport Layer for subsequent connections\n               (by resetting the Frame Handler counters and deleting the\n               existing packets in TX/RX fifos) */\n            xcpTransportRestart();\n\n            /* Delete all the Dynamic DAQ data structures and\n               reserved  memory pools */\n            for (i = 0; i < daqCount; i++) {\n                if (IS_USING_CUSTOM_POOL(daq[i].eventId)) {\n                    xcpMemCustomPoolDestroy(daq[i].poolId);\n                } else if (i < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER\n                 && daq[i].eventId < XCP_MIN_EVENT_NO_RESERVED_POOL) {\n                    destroyDaqReservedPool(&daq[i]);\n                }\n\n                if (daq[i].odt != NULL) {\n                    for (j = 0; j < daq[i].odtCount; j++) {\n                        if (daq[i].odt[j].entry != NULL) {\n                            xcpMemFree(daq[i].odt[j].entry);\n                        }\n                    }\n\n                    xcpMemFree(daq[i].odt);\n                }\n            }\n\n            xcpMemFree(daq);\n\n            xcpSessionStatusClearMask(XCP_SESSION_DAQ_RUNNING_MASK);\n        }\n    }\n\n    return locked;\n}\n\n\nvoid xcpDaqReset(void)\n{\n    xcpResetDaqListStatus();\n\n    /* reset support for the extended list of DAQ commands */\n    xcpDaqExtendedReset();\n\n    /* Restore the original value for the lookup function */\n    xcpDaqSetPacketLookup(NULL);\n\n#if !defined(XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK) || (XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK == 0)\n    XCP_MUTEX_INIT(daqLock);\n#else\n    {\n        uint16_T i = 0;\n\n        for (i = 0; i < XCP_MAX_EVENT_DATA_NUMBER; i++) {\n            XCP_MUTEX_INIT(xcpEventData[i].lock);\n        }\n    }\n#endif\n}\n\n\nXcpErrorCode xcpDaqSetCustomPoolMemoryManager(XcpEventIdType eventId, \n                                              XcpCustomAllocHandler allocHandler, \n                                              XcpCustomFreeHandler freeHandler)\n{\n    if (allocHandler == NULL || freeHandler == NULL) {\n        return XCP_INV_ARG;\n    }\n\n    xcpEventCustomMemoryManager.eventId = eventId;\n    xcpEventCustomMemoryManager.allocHandler = allocHandler;\n    xcpEventCustomMemoryManager.freeHandler = freeHandler;\n\n    return XCP_SUCCESS;\n}\n\n\nXcpErrorCode xcpDaqGetCustomPoolMemoryManager(XcpEventIdType *eventId,\n                                              XcpCustomAllocHandler *allocHandler,\n                                              XcpCustomFreeHandler *freeHandler)\n{\n    if (xcpEventCustomMemoryManager.eventId == XCP_DAQ_CUSTOM_MEMORY_INVALID_EVENT_ID) {\n        return XCP_NOT_INITIALIZED;\n    }\n    if (allocHandler == NULL || freeHandler == NULL) {\n        return XCP_INV_ARG;\n    }\n\n    *eventId = xcpEventCustomMemoryManager.eventId;\n    *allocHandler = xcpEventCustomMemoryManager.allocHandler;\n    *freeHandler = xcpEventCustomMemoryManager.freeHandler;\n\n    return XCP_SUCCESS;\n}\n\n\n#ifdef XCP_INTERNAL_DAQ_CONFIG_ACCESS_SUPPORT\n\nXcpErrorCode xcpDaqGetOdtEntries(XcpEventIdType eventId, \n                                 XcpDaqDirection direction, \n                                 XcpOdtEntry* entries,\n                                 size_t* entriesNumber,\n                                 size_t maxEntriesNumber)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    XcpOdtEntry* currentEntry = entries;\n    size_t entriesCount = 0;\n    boolean_T memOverflow = false;\n\n    XCP_ERROR_IF(eventId >= XCP_MAX_EVENT_CHANNEL, XCP_INV_ARG, \"xcpDaqGetOdtEntries: invalid eventId\\n\");\n    XCP_ERROR_IF(direction != XCP_DIRECTION_DAQ, XCP_NOT_SUPPORTED, \"xcpDaqGetOdtEntries: direction not supported\\n\");\n    XCP_ERROR_IF(entries == NULL, XCP_INV_ARG, \"xcpDaqGetOdtEntries: invalid entries\\n\");\n    XCP_ERROR_IF(entriesNumber == NULL, XCP_INV_ARG, \"xcpDaqGetOdtEntries: invalid entriesNumber\\n\");\n    XCP_ERROR_IF(maxEntriesNumber == 0, XCP_INV_ARG, \"xcpDaqGetOdtEntries: invalid maxEntriesNumber\\n\");\n\n    /* Extract the ODT entries by navigating the whole DAQ List hierarchy */\n    if (xcpDynamicDaqLists.daq != NULL) {\n        uint16_T daqId = 0;\n        for (daqId = 0; (daqId < xcpDynamicDaqLists.daqCount) && !memOverflow; daqId++) {\n            XcpDaq *daq = &xcpDynamicDaqLists.daq[daqId];\n\n            if ((daq->eventId == eventId) &&\n                ((direction == XCP_DIRECTION_DAQ) &&\n                 !XCP_READ_BIT_VALUE(daq[daqId].mode, XCP_DAQ_MODE_DIRECTION_MASK)) &&\n                 isActiveDaqList(daqId)) {\n                /* only active DAQ lists are considered */\n                if (daq->odt != NULL) {\n                    uint8_T odtId = 0;\n\n                    for (odtId = 0; (odtId < daq->odtCount) && !memOverflow; odtId++) {\n                        XcpOdt *odt = &daq->odt[odtId];\n  \n                        if (odt->entry != NULL) {\n                            uint8_T entryId = 0;\n\n                            for (entryId = 0; (entryId < odt->entriesCount) && !memOverflow; entryId++) {\n                                XcpOdtEntry *odtEntry = &odt->entry[entryId];\n                                \n                                if (entriesCount < maxEntriesNumber) {\n                                    XCP_MEMCPY(currentEntry, odtEntry, sizeof(XcpOdtEntry));\n                                    currentEntry++;\n                                    entriesCount++;\n                                } else {\n                                    memOverflow = true;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    /* update number of entries copied and error code */\n    *entriesNumber = entriesCount;\n    if (memOverflow) {\n        errorCode = XCP_NO_MEMORY;\n    }\n\n    return errorCode;\n}\n\n#endif /* XCP_INTERNAL_DAQ_CONFIG_ACCESS_SUPPORT */\n\n\n#ifndef XCP_DAQ_EXTENDED_SUPPORT\n\nvoid xcpDaqExtendedInit(void) {}\nvoid xcpDaqExtendedReset(void) {}\n\n#endif\n\n#endif\n"},{"name":"xcp_drv_rtiostream.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2025b/toolbox/coder/xcp/src/target/server/platform/default","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2023 The MathWorks, Inc.\n*\n* File: xcp_drv_rtiostream.c\n*\n* Abstract:\n*  Implementation of XCP driver based on rtIOStream\n*/\n\n#include \"rtiostream.h\"\n#include \"xcp_common.h\"\n#include \"xcp.h\"\n#include \"xcp_drv.h\"\n\n#define INVALID_DRV_ID  -1\n\n/* Timeout expected for the reception of a packet, once the reception has started */\nstatic const uint32_T XCP_RECEIVE_PACKET_TIMEOUT_IN_MICROSECONDS  = 1000000L;  /* 1s */\n\n/* Delay before attempting the reception of new data */\nstatic const uint32_T XCP_RECEIVE_RETRY_TIME_IN_MICROSECONDS = 10L;  /* 10us */\n\n/* Timeout expected for the transmission of a packet, once the transmission has started */\nstatic const uint32_T XCP_SEND_PACKET_TIMEOUT_IN_MICROSECONDS = 2000000L;   /* 2s */\n\n/* Delay before attempting the transmission of new data */\nstatic const uint32_T XCP_SEND_RETRY_TIME_IN_MICROSECONDS = 10L;  /* 10us */\n\n\n/* According to the XCP standard, the XCP server only supports the connection\n   with one XCP Client at a time. The active connection is identified by\n   a specific drvID */\nstatic int drvID = INVALID_DRV_ID;\n\n\n/* If set to true, force the xcpDrvSend and xcpDrvRecv APIs to be blocking */\nstatic boolean_T  forceBlocking = false;\n\n\nXcpErrorCode xcpDrvOpen(\n    int   argc,\n    void *argv[]\n    )\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    if (drvID != INVALID_DRV_ID) {\n        XCP_PRINTF(\"xcpDrvOpen: XCP driver already initialized\\n\");\n        return XCP_ERROR;\n    }\n\n    /* Open the actual communication channel */\n    drvID = rtIOStreamOpen(argc, argv);\n    if (drvID < 0) {\n        XCP_PRINTF(\"xcpDrvOpen: unable to open communication channel\\n\");\n        drvID = INVALID_DRV_ID;\n        errorCode = XCP_ERROR;\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpDrvIoctl(XcpDrvIoctlCommand cmd)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    XCP_ERROR_IF((cmd != XCP_DRV_RESTORE_DEFAULT_BLOCKING_SETUP) &&\n                 (cmd != XCP_DRV_FORCE_BLOCKING), XCP_INV_ARG,\n                 \"xcpDrvIoctl: invalid command\\n\");\n\n    forceBlocking = (cmd == XCP_DRV_FORCE_BLOCKING);\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpDrvSend(const void *src, size_t size)\n{\n    int ret = RTIOSTREAM_NO_ERROR;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t   sent = 0;\n    size_t sentBytesCounter = 0;\n    uint32_T elapsedTime = 0;\n    const uint8_T *dataPtr = NULL;\n    boolean_T done = false;\n\n    XCP_ERROR_IF(src == NULL, XCP_INV_ARG, \"xcpDrvSend: invalid src buffer\\n\");\n    XCP_ERROR_IF(size == 0, XCP_INV_ARG, \"xcpDrvSend: invalid size\\n\");\n    XCP_ERROR_IF(drvID == INVALID_DRV_ID, XCP_NOT_INITIALIZED, \"xcpDrvSend: XCP driver not initialized\\n\");\n\n    while (!done) {\n        dataPtr = (const uint8_T *)src + sentBytesCounter;\n        ret = rtIOStreamSend(drvID, dataPtr, (size - sentBytesCounter), &sent);\n\n        if (ret == RTIOSTREAM_NO_ERROR) {\n            if ((sent == 0) && (sentBytesCounter == 0) && !forceBlocking) {\n                /* This will only happen if the rtIOStreamSend function\n                   is non-blocking and we haven't started sending data yet */\n                errorCode = XCP_BUSY;\n            } else {\n                /* Send packet in progress, we need to complete it */\n                sentBytesCounter += sent;\n\n                done = (sentBytesCounter >= size) ;\n\n                if (!done) {\n                    if (elapsedTime >= XCP_SEND_PACKET_TIMEOUT_IN_MICROSECONDS) {\n                        errorCode = XCP_PKT_TX_TIMEOUT_ERROR;\n                    } else {\n                        XCP_SLEEP(0, XCP_SEND_RETRY_TIME_IN_MICROSECONDS);\n                        elapsedTime += XCP_SEND_RETRY_TIME_IN_MICROSECONDS;\n                    }\n                }\n            }\n        } else {\n            errorCode = XCP_ERROR;\n        }\n\n        done = done || (errorCode == XCP_BUSY) || (errorCode == XCP_ERROR) ||\n               (errorCode == XCP_PKT_TX_TIMEOUT_ERROR);\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpDrvRecv(void *dst, size_t size)\n{\n    int ret = RTIOSTREAM_NO_ERROR;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t receivedBytesCounter = 0;\n    size_t received = 0;\n    uint32_T elapsedTime = 0;\n    uint8_T *dataPtr = NULL;\n    boolean_T done = false;\n\n    XCP_ERROR_IF(dst == NULL, XCP_INV_ARG, \"xcpDrvRecv: invalid src buffer\\n\");\n    XCP_ERROR_IF(size == 0, XCP_INV_ARG, \"xcpDrvRecv: invalid size\\n\");\n    XCP_ERROR_IF(drvID == INVALID_DRV_ID, XCP_NOT_INITIALIZED, \"xcpDrvRecv: XCP driver not initialized\\n\");\n\n    while (!done) {\n        dataPtr = (uint8_T *)dst + receivedBytesCounter;\n\n        ret = rtIOStreamRecv(drvID, dataPtr, (size - receivedBytesCounter), &received);\n        if (ret == RTIOSTREAM_NO_ERROR) {\n            if ((received == 0) && (receivedBytesCounter == 0) && !forceBlocking) {\n                /* This will only happen if the rtIOStreamRecv function\n                   is non-blocking and we haven't started receiving data yet */\n                errorCode = XCP_EMPTY;\n            } else {\n                /* Receive packet in progress, we need to complete it */\n                receivedBytesCounter += received;\n                done = (receivedBytesCounter >= size);\n\n                if (!done) {\n                    if (elapsedTime >= XCP_RECEIVE_PACKET_TIMEOUT_IN_MICROSECONDS) {\n                        errorCode = XCP_PKT_RX_TIMEOUT_ERROR;\n                    } else {\n                        XCP_SLEEP(0, XCP_RECEIVE_RETRY_TIME_IN_MICROSECONDS);\n                        elapsedTime += XCP_RECEIVE_RETRY_TIME_IN_MICROSECONDS;\n                    }\n                }\n            }\n        }\n        else {\n            errorCode = XCP_ERROR;\n        }\n        \n        done = done || (errorCode == XCP_EMPTY) || (errorCode == XCP_ERROR) ||\n               (errorCode ==  XCP_PKT_RX_TIMEOUT_ERROR);\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpDrvRecvUnknownSize(void *dst, size_t *size, size_t maxSize)\n{\n    int ret = RTIOSTREAM_NO_ERROR;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t receivedBytes = 0;\n    uint8_T *dataPtr = NULL;\n\n    XCP_ERROR_IF(dst == NULL, XCP_INV_ARG, \"xcpDrvRecvUnknownSize: invalid dst buffer\\n\");\n    XCP_ERROR_IF(size == NULL, XCP_INV_ARG, \"xcpDrvRecvUnknownSize: invalid size pointer\\n\");\n    XCP_ERROR_IF(maxSize == 0, XCP_INV_ARG, \"xcpDrvRecvUnknownSize: invalid maxSize\\n\");\n    XCP_ERROR_IF(drvID == INVALID_DRV_ID, XCP_NOT_INITIALIZED, \"xcpDrvRecvUnknownSize: XCP driver not initialized\\n\");\n\n    dataPtr = (uint8_T *)dst;\n\n    ret = rtIOStreamRecv(drvID, dataPtr, maxSize, &receivedBytes);\n    if (ret == RTIOSTREAM_NO_ERROR) {\n        if (receivedBytes == 0) {\n            /* This will only happen if we haven't yet started receiving data */\n            errorCode = XCP_EMPTY;\n        }\n        else if (receivedBytes <= maxSize) {\n            /* Packet received. Hence, update the actual size */\n            *size = receivedBytes;\n            errorCode = XCP_SUCCESS;\n        }\n        else {\n            errorCode = XCP_ERROR;\n        }\n    }\n    else {\n        errorCode = XCP_ERROR;\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpDrvClose(void)\n{\n    int ret = RTIOSTREAM_NO_ERROR;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    if (drvID == INVALID_DRV_ID) {\n        XCP_PRINTF(\"xcpDrvClose: XCP driver already closed\\n\");\n        return XCP_SUCCESS; /* Nothing to do: just printing out a warning message*/\n    }\n\n    ret = rtIOStreamClose(drvID);\n\n    if (ret == RTIOSTREAM_NO_ERROR) {\n        drvID = INVALID_DRV_ID;\n        errorCode = XCP_SUCCESS;\n    }\n    else {\n        errorCode = XCP_ERROR;\n    }\n\n    return errorCode;\n}\n\n"},{"name":"xcp_ext_classic_trigger.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2025b/toolbox/coder/xcp/src/target/ext_mode/src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2020-2024 The MathWorks, Inc.\n *\n * File: xcp_ext_classic_trigger.c\n *\n * Abstract:\n *  This file contains the implementation of the External Mode\n *  \"Classic Trigger\" logic.\n *\n */\n\n#include \"xcp_ext_classic_trigger.h\"\n#include \"xcp_ext_common.h\"\n\n#define EXTMODE_TRIG_BASE_RATE_EVENT_ID EXTMODE_BASE_RATE_EVENT_ID\n\n#define DEFAULT_XCP_CLASSIC_TRIGGER_DURATION 1000\n\n\n/* Global variables directly accessible by the XCP Client */\nextmodeEventId_T volatile xcpClassicTriggerEventId = 0;\n\nuint32_T volatile xcpClassicTriggerSignalAddress = 0;\nuint8_T volatile  xcpClassicTriggerSignalAddressExtension = 0;\n\nextmodeClassicTriggerSignal_T volatile xcpClassicTriggerLevel = 0;\n\nuint32_T volatile xcpClassicTriggerDuration = DEFAULT_XCP_CLASSIC_TRIGGER_DURATION;\nuint32_T volatile xcpClassicTriggerHoldOff  = 0;\nint32_T  volatile xcpClassicTriggerDelay    = 0;\n\nXcpClassicTriggerDirection volatile xcpClassicTriggerDirection = XCP_EXTMODE_TRIGGER_RISING;\n\n#if defined(EXTMODE_TRIG_ARMED_ON_START) && EXTMODE_TRIG_ARMED_ON_START == 0\nboolean_T volatile xcpClassicTriggerArmRequest = false;\n#else\n/* Classic Trigger is armed by default */\nboolean_T volatile xcpClassicTriggerArmRequest = true;\n#endif\n\nboolean_T volatile xcpClassicTriggerCancelRequest = false;\n\nXcpClassicTriggerSource volatile xcpClassicTriggerSource = XCP_EXTMODE_TRIGGER_MANUAL;\n\nXcpClassicTriggerMode volatile xcpClassicTriggerMode = XCP_EXTMODE_TRIGGER_NORMAL;\n\nXcpClassicTriggerStatus volatile xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_UNARMED;\n\n\nXCP_STATIC extmodeClassicTriggerSignal_T xcpOldSignalValue = 0;\nXCP_STATIC boolean_T                     xcpOldSignalValueAvailable = false;\n\nXCP_STATIC XcpClassicTriggerSource       xcpOldClassicTriggerSource = XCP_EXTMODE_TRIGGER_MANUAL;\n\nXCP_STATIC boolean_T                     xcpTriggerEnabled = false;\nXCP_STATIC boolean_T                     xcpSignalTriggerFired = false;\nXCP_STATIC uint32_T                      xcpTriggerCount = 0;\n\nXCP_STATIC boolean_T                     xcpForcedTriggerEnabled = false;\nXCP_STATIC boolean_T                     xcpForceTriggerEnableRequest = false;\n\n/** The function is responsible for sampling the signal trigger value\n    and setting the xcpSignalTriggerFired boolean to true if\n    the trigger signal has the expected transition across the xcpClassicTriggerLevel.\n    The boolean will always be restored back to false by the base rate\n    when the event is acknowledged and the state transition completed.\n    The function is also setting xcpTriggerEnabled to true if no Delay is required. */\nstatic void sampleSignalTrigger(void)\n{\n    extmodeClassicTriggerSignal_T const* signal = (extmodeClassicTriggerSignal_T const*)\n                                            XCP_ADDRESS_GET_READ(xcpClassicTriggerSignalAddressExtension,\n                                                            xcpClassicTriggerSignalAddress);\n    if ((signal != NULL) &&\n       ((xcpClassicTriggerSignalAddressExtension != 0) ||\n        (xcpClassicTriggerSignalAddress != 0))) {\n        if ((xcpClassicTriggerStatus ==\tXCP_EXTMODE_TRIGGER_ARMED) &&\n            !xcpSignalTriggerFired) {\n            /* Read the new signal value */\n            extmodeClassicTriggerSignal_T signalValue = *signal;\n\n            if (xcpOldSignalValueAvailable) {\n                /* If the trigger is armed and not already fired,\n                   check for the expected transition */\n                boolean_T checkForRising =  (xcpClassicTriggerDirection == XCP_EXTMODE_TRIGGER_RISING) ||\n                                            (xcpClassicTriggerDirection == XCP_EXTMODE_TRIGGER_RISING_OR_FALLING);\n\n                boolean_T checkForFalling = (xcpClassicTriggerDirection == XCP_EXTMODE_TRIGGER_FALLING) ||\n                                            (xcpClassicTriggerDirection == XCP_EXTMODE_TRIGGER_RISING_OR_FALLING);\n\n                if (checkForRising &&\n                   (((signalValue >= xcpClassicTriggerLevel) && (xcpOldSignalValue <  xcpClassicTriggerLevel)) ||\n                    ((signalValue >  xcpClassicTriggerLevel) && (xcpOldSignalValue == xcpClassicTriggerLevel)))) {\n\n                    if (xcpClassicTriggerDelay == 0) {\n                        /* fire the event immediately if needed no Delay is required */\n                        xcpTriggerEnabled = true;\n                    }\n                    xcpSignalTriggerFired   = true; /* the transition from ARMED to FIRING is updated in base rate */\n                }\n                if (checkForFalling &&\n                   (((signalValue < xcpClassicTriggerLevel)  && (xcpOldSignalValue >= xcpClassicTriggerLevel)) ||\n                    ((signalValue == xcpClassicTriggerLevel) && (xcpOldSignalValue >  xcpClassicTriggerLevel)))) {\n\n                    if (xcpClassicTriggerDelay == 0) {\n                        /* fire the event immediately if needed no Delay is required */\n                        xcpTriggerEnabled = true;\n                    }\n                    xcpSignalTriggerFired   = true; /* the transition from ARMED to FIRING is updated in base rate */\n                }\n            }\n\n            /* Update the old signal value. Note: if we just fired, the sampling will start\n               next time the trigger is armed and therefore we reset xcpOldSignalValueAvailable */\n            xcpOldSignalValueAvailable = !xcpSignalTriggerFired;\n            xcpOldSignalValue = signalValue;\n        }\n    }\n}\n\n\n/** The function is executed in the base rate and it is responsible\n    for the handling of the triggering status transitions */\nstatic void updateTriggerStatus(void)\n{\n    /* Process user Arm/Cancel requests common to all states\n       and update the triggerFired variable (depending on the\n       active triggering source) */\n    boolean_T triggerFired = false;\n\n    if (xcpClassicTriggerStatus == XCP_EXTMODE_TRIGGER_UNARMED) {\n        /* This case deserves a separate handling\n           because we would like the transition to the ARMED status\n           to occur in the same cycle.\n           Since we are already UNARMED, any request to cancel \n           the trigger can be ignored */\n        xcpClassicTriggerCancelRequest = false;\n        xcpSignalTriggerFired = false;\n\n        if (xcpClassicTriggerArmRequest) {\n            /* Process arm request */\n            xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_ARMED;\n            xcpClassicTriggerArmRequest = false;\n\n            /* If we are using MANUAL trigger, we want to start \n               firing the trigger event straightaway, e.g.\n               when the user selects ExtModeArmWhenConnect */\n            if (xcpClassicTriggerSource == XCP_EXTMODE_TRIGGER_MANUAL) {\n                triggerFired = true;\n            }\n        }\n    } else {\n        /* We are already armed, ignore any request to arm the trigger */\n        xcpClassicTriggerArmRequest = false;\n\n        if (xcpClassicTriggerCancelRequest) {\n            /* No matter what the Status is, a cancel request should\n               always bring the status to UNARMED.\n               We implement the transition here, to avoid code\n               duplication in the states. */\n            xcpTriggerEnabled = false;\n            xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_UNARMED;\n            xcpClassicTriggerCancelRequest = false;\n        } else {\n            if (xcpClassicTriggerSource == XCP_EXTMODE_TRIGGER_MANUAL) {\n                /* when manual triggering is selected, we assume that\n                   the trigger event has always been fired when armed */\n                triggerFired = true;\n            } else {\n                /* when signal triggering is selected, we check the status\n                   of the xcpSignalTriggerFired (updated by the\n                   sampleSignalTrigger() logic */\n                triggerFired = xcpSignalTriggerFired;\n                xcpSignalTriggerFired = false;\n            }\n        }\n    }\n\n    /* Handle the remaining state transitions */\n    switch (xcpClassicTriggerStatus) {\n    case XCP_EXTMODE_TRIGGER_UNARMED:\n        if (xcpClassicTriggerArmRequest) {\n            /* Process arm request */\n            xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_ARMED;\n            xcpClassicTriggerArmRequest = false;\n        }\n        break;\n\n    case XCP_EXTMODE_TRIGGER_ARMED:\n        if (triggerFired) {\n            if ((xcpClassicTriggerDelay > 0) &&\n                (xcpClassicTriggerSource == XCP_EXTMODE_TRIGGER_SIGNAL)) {\n                /* We need to postpone the enabling of the trigger\n                   by xcpClassicTriggerDelay base periods */\n                xcpTriggerCount = (uint32_T) xcpClassicTriggerDelay;\n                xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_DELAYED;\n            } else {\n                /* Negative xcpClassicTriggerDelay are ignored.\n                   The parameter is also ignored if the xcpClassicTriggerSource\n                   is XCP_EXTMODE_TRIGGER_MANUAL\n                   If xcpClassicTriggerDelay is 0 we enable the trigger straight away */\n                if (xcpClassicTriggerDuration > 0) {\n                    xcpTriggerEnabled = true;\n                    xcpTriggerCount = xcpClassicTriggerDuration;\n                    xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_FIRING;\n                } else {\n                    /* If duration is 0, we would never be able to send any data.\n                       This situation should be prevented on the host,\n                       we just handle it gracefully here, in case it happens */\n                    XCP_PRINTF(\"Invalid duration value (0) detected.\\n\");\n                    xcpTriggerEnabled = false;\n                    xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_UNARMED;\n                }\n            }\n        }\n        break;\n\n    case XCP_EXTMODE_TRIGGER_FIRING:\n        /* Update the base rate counter */\n        if (xcpTriggerCount > 0) {\n            xcpTriggerCount--;\n        }\n\n        if (xcpTriggerCount == 0) {\n            /* Duration has expired */\n            if (xcpClassicTriggerMode == XCP_EXTMODE_TRIGGER_ONESHOT) {\n                /* In the one-shot scenario we just disable the trigger */\n                xcpTriggerEnabled = false;\n                xcpClassicTriggerStatus  = XCP_EXTMODE_TRIGGER_UNARMED;\n            } else {\n                /* In normal mode, we might have to handle the HoldOff and\n                   pause the triggering  */\n                if (xcpClassicTriggerHoldOff > 0) {\n                    xcpTriggerEnabled = false;\n                    xcpTriggerCount = xcpClassicTriggerHoldOff;\n                    xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_HOLDING_OFF;\n                } else {\n                    if (triggerFired) {\n                        /* If the trigger has been fired, we start another duration\n                           straight away */\n                        xcpTriggerCount = xcpClassicTriggerDuration;\n                        xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_FIRING;\n                    } else {\n                        /* We wait for the next trigger to be fired */\n                        xcpTriggerEnabled = false;\n                        xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_ARMED;\n                    }\n                }\n            }\n        }\n        break;\n\n    case XCP_EXTMODE_TRIGGER_DELAYED:\n        /* Update the base rate counter */\n        if (xcpTriggerCount > 0) {\n            xcpTriggerCount--;\n        }\n\n        if (xcpTriggerCount == 0) {\n            /* Delay is over, we can enable the trigger now */\n            if (xcpClassicTriggerDuration > 0) {\n                xcpTriggerEnabled = true;\n                xcpTriggerCount = xcpClassicTriggerDuration;\n                xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_FIRING;\n            } else {\n                /* If duration is 0, we would never be able to send any data.\n                   This situation should be prevented on the host,\n                   we just handle it gracefully here, in case it happens */\n                XCP_PRINTF(\"Invalid duration value (0) detected.\\n\");\n                xcpTriggerEnabled = false;\n                xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_UNARMED;\n            }\n        }\n        break;\n\n    case XCP_EXTMODE_TRIGGER_HOLDING_OFF:\n        /* Update the base rate counter */\n        if (xcpTriggerCount > 0) {\n            xcpTriggerCount--;\n        }\n\n        if (xcpTriggerCount == 0) {\n            /* HoldOff time has expired */\n            if (triggerFired) {\n                /* If the trigger has been fired, we start another duration\n                   straight away */\n                if (xcpClassicTriggerDuration > 0) {\n                    xcpTriggerEnabled = true;\n                    xcpTriggerCount = xcpClassicTriggerDuration;\n                    xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_FIRING;\n                } else {\n                    /* If duration is 0, we would never be able to send any data.\n                       This situation should be prevented on the host,\n                       we just handle it gracefully here, in case it happens */\n                    XCP_PRINTF(\"Invalid duration value (0) detected.\\n\");\n                    xcpTriggerEnabled = false;\n                    xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_UNARMED;\n                }\n            } else {\n                /* We wait for the next trigger to be fired */\n                xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_ARMED;\n            }\n        }\n        break;\n\n    default:\n        XCP_PRINTF(\"Invalid Trigger Status %u detected\\n\", xcpClassicTriggerStatus);\n        xcpTriggerEnabled = false;\n        xcpSignalTriggerFired = false;\n        xcpClassicTriggerCancelRequest = false;\n        xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_UNARMED;\n    }\n}\n\n\n\nXcpErrorCode xcpExtModeClassicTriggerInit(void)\n{\n    xcpOldSignalValue = 0;\n    xcpOldSignalValueAvailable = false;\n\n    xcpOldClassicTriggerSource = xcpClassicTriggerSource;\n\n    xcpTriggerEnabled = false;\n    xcpSignalTriggerFired = false;\n    xcpTriggerCount = 0;\n\n    xcpClassicTriggerStatus  = XCP_EXTMODE_TRIGGER_UNARMED;\n\n    return XCP_SUCCESS;\n}\n\n\n/** The function returns true if the external mode event must be triggered */\nboolean_T xcpExtModeClassicTriggerEnabled(extmodeEventId_T eventId)\n{\n    if (eventId == EXTMODE_TRIG_BASE_RATE_EVENT_ID) {\n        /* Whenever a change of the xcpClassicTriggerSource is detected\n           the xcpClassicTriggerStatus is reset */\n        boolean_T triggerSrcChangeDetected = (xcpClassicTriggerSource != xcpOldClassicTriggerSource);\n        xcpOldClassicTriggerSource = xcpClassicTriggerSource;\n\n        if (triggerSrcChangeDetected) {\n            xcpTriggerEnabled     = false;\n            xcpSignalTriggerFired = false;\n            xcpTriggerCount       = 0;\n\n            xcpClassicTriggerStatus  = XCP_EXTMODE_TRIGGER_UNARMED;\n        }\n\n        /* If XCP_EXTMODE_TRIGGER_SIGNAL is selected we want to start\n           processing the Arm request (or the Hold-off expiration) \n           straightaway and carry out the state transition before \n           sampling for the first time */\n        if ((xcpClassicTriggerSource == XCP_EXTMODE_TRIGGER_SIGNAL)  &&\n            (((xcpClassicTriggerStatus == XCP_EXTMODE_TRIGGER_UNARMED) &&\n               xcpClassicTriggerArmRequest) ||\n             ((xcpClassicTriggerStatus == XCP_EXTMODE_TRIGGER_HOLDING_OFF) &&\n              (xcpTriggerCount == 1)))) {\n               xcpTriggerCount = 0;\n               xcpClassicTriggerArmRequest = false;\n               xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_ARMED;\n        }\n    }\n\n    if ((xcpClassicTriggerSource == XCP_EXTMODE_TRIGGER_SIGNAL) &&\n        (eventId == xcpClassicTriggerEventId))  {\n        /* Since we are running at the correct eventID, sample the\n           trigger signal value to determine if the trigger signal\n           needs to be enabled.\n           Note: this will update the boolean straight away and request\n           the state transition (updated at the next base rate) */\n        sampleSignalTrigger();\n    }\n\n    if (eventId == EXTMODE_TRIG_BASE_RATE_EVENT_ID) {\n        /* update trigger status to fulfill user requests */\n        updateTriggerStatus();\n\n        /* If the base rate task has run, then reset the\n         * xcpForceTriggerEnableRequest flag.  The state machine\n         * is up to date. */\n        xcpForceTriggerEnableRequest = false;\n    } else if (xcpForceTriggerEnableRequest) {\n        return xcpForcedTriggerEnabled;\n    }\n\n    return xcpTriggerEnabled;\n}\n\n\n/** Reset External Mode classic triggering logic, by restoring the default status */\nXcpErrorCode xcpExtModeClassicTriggerReset(void)\n{\n    xcpOldSignalValue = 0;\n    xcpOldSignalValueAvailable = false;\n\n    xcpClassicTriggerStatus  = XCP_EXTMODE_TRIGGER_UNARMED;\n    xcpOldClassicTriggerSource = XCP_EXTMODE_TRIGGER_MANUAL;\n    xcpClassicTriggerEventId = 0;\n    xcpTriggerEnabled = false;\n    xcpSignalTriggerFired = false;\n    xcpTriggerCount = 0;\n    xcpForcedTriggerEnabled = false;\n    xcpForceTriggerEnableRequest = false;\n\n    xcpClassicTriggerSignalAddress = 0;\n    xcpClassicTriggerSignalAddressExtension = 0;\n\n    xcpClassicTriggerLevel    = 0;\n    xcpClassicTriggerDuration = DEFAULT_XCP_CLASSIC_TRIGGER_DURATION;\n    xcpClassicTriggerHoldOff  = 0;\n    xcpClassicTriggerDelay    = 0;\n\n    xcpClassicTriggerDirection = XCP_EXTMODE_TRIGGER_RISING;\n\n#if defined(EXTMODE_TRIG_ARMED_ON_START) && EXTMODE_TRIG_ARMED_ON_START == 0\n    xcpClassicTriggerArmRequest = false;\n#else\n/* Classic Trigger is armed by default */\n    xcpClassicTriggerArmRequest = true;\n#endif\n\n    xcpClassicTriggerCancelRequest = false;\n\n    xcpClassicTriggerSource = XCP_EXTMODE_TRIGGER_MANUAL;\n    xcpClassicTriggerMode = XCP_EXTMODE_TRIGGER_NORMAL;\n\n    return XCP_SUCCESS;\n}\n\n\n/** When Manual triggering is enabled, force output of xcpExtModeClassicTriggerEnabled to\n *  match pending Arm or Cancel request for all non-base rate events until requests are \n *  processed at the next base rate event.\n * \n *  In the concurrent execution workflow, it is used to avoid omission\n *  of logging data points if a non-base rate task completes\n *  before the base rate at t = 0.\n * \n *  This is a NO-OP when XCP_EXTMODE_TRIGGER_SIGNAL is active.\n */\nvoid xcpExtModeClassicTriggerForceEnableStatusUpdate(void) {\n    if (xcpClassicTriggerSource == XCP_EXTMODE_TRIGGER_MANUAL) {\n        if (xcpClassicTriggerArmRequest && !xcpClassicTriggerCancelRequest) {\n            /* Force xcpExtModeClassicTriggerEnabled to return true\n            * until the next base rate event. */\n            xcpForcedTriggerEnabled = true;\n            xcpForceTriggerEnableRequest = true;\n        } else if (xcpClassicTriggerCancelRequest && !xcpClassicTriggerArmRequest) {\n            xcpForcedTriggerEnabled = false;\n            xcpForceTriggerEnableRequest = true;\n        } else {\n            xcpForceTriggerEnableRequest = false;\n        }\n    }\n}\n"},{"name":"xcp_ext_common.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2025b/toolbox/coder/xcp/src/target/ext_mode/src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2018-2023 The MathWorks, Inc.\n *\n * File: xcp_ext_common.c\n *\n * Abstract:\n *  This file contains the implementation of the common functionalities\n *  used within the XCP External Mode Platform Abstraction layer.\n *\n *  This includes the handling of absolute simulation time and the global\n *  variables to control the execution of the model on the target\n *  (and accessed remotely via XCP communication protocol).\n */\n#if !defined(INTEGER_CODE) || INTEGER_CODE == 0\n#include <float.h>         /* for DBL_EPSILON */\n#include <math.h>\n#endif\n\n#include \"xcp_ext_common.h\"\n#include \"xcp_ext_param.h\"\n#include \"xcp.h\"\n#include \"xcp_internal.h\"\n#include \"xcp_transport.h\"\n#include \"xcp_cfg.h\"\n\n#include \"rtw_extmode.h\"\n\n#ifdef XCP_CUSTOM_ADDRESS_TRANSLATION\nvoid xcpInitCustomAddressGet(void);\n#endif\n\n#ifndef EXTMODE_FLUSH_ALL_DATA_DELAY_TIME_IN_MICROSECONDS\n/* Dummy delay, that forces the background task to pause the execution\n   and reduces the packets transmission rate. \n   This is useful for host-based targets to prevent the saturation\n   of transmission buffers */\n#define EXTMODE_FLUSH_ALL_DATA_DELAY_TIME_IN_MICROSECONDS  10L  /* 10us */\n#endif\n\n\n/* XCP Client can 'directly' access these global variables, in order to control\n   the model state machine */\n\n#if defined(ON_TARGET_WAIT_FOR_START) && ON_TARGET_WAIT_FOR_START == 1\nboolean_T volatile xcpModelStartRequest = false;\n#else\nboolean_T volatile xcpModelStartRequest = true;\n#endif\nboolean_T volatile xcpModelStopRequest = false;\nXcpExtModeStatus volatile xcpModelStatus = XCP_EXTMODE_STATUS_RESET;\n\nuint32_T volatile xcpModelChecksum0   = 0;\nuint32_T volatile xcpModelChecksum1   = 0;\nuint32_T volatile xcpModelChecksum2   = 0;\nuint32_T volatile xcpModelChecksum3   = 0;\nuint32_T volatile xcpModelIntegerCode = 0;\n\n/* Global variable defined when a non-BYTE addressable target is\n   being emulated as a BYTE addressable target. Currently defined \n   only for WORD addressable targets (Eg.:C2000). But, can be\n   extended to DWORD addressable targets */\n#ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\nuint8_T volatile xcpEmulateWordTargetAsByteTarget = 1;\n#endif\n\n#if defined(INTEGER_CODE) && INTEGER_CODE == 1\nextmodeSimulationTime_T volatile xcpExtmodeFinalSimulationTime = EXTMODE_SIMULATION_RUN_FOREVER;\n#else\nextmodeSimulationTime_T volatile xcpExtmodeFinalSimulationTime = EXTMODE_SIMULATION_TIME_NOT_INITIALIZED;\n#endif\n\nboolean_T               volatile xcpExtmodeSimulationComplete  = false;\n\n#if !defined(INTEGER_CODE) || INTEGER_CODE == 0\n/* Dummy double variable, required to obtain the size of double data type on the target \n   using the symbols parser. */\nextmodeDouble_T volatile xcpDummyDoubleVariable = (extmodeDouble_T) 0;\n#endif\n\n#ifdef MAX_uint64_T\n/* Dummy uint64_T variable, required to obtain the size of uint64_T data type\n   on the target  using the symbols parser. */\nuint64_T volatile xcpDummyUint64Variable = (uint64_T) 0;\n#endif\n\n/* Definition of a dummy printf function */\nvoid xcp_void_printf(const char_T *fmt,...){UNUSED_PARAMETER(fmt);}\n\n\n#if (defined(INTEGER_CODE) && INTEGER_CODE == 1) || defined(XCP_EXTMODE_SIMULATION_TIME_IN_TICKS)\n\n/* The mutex is used to protect against the concurrent access to the global\n   variables (related to the simulation time) when xcpExtModeUpdateTime()\n   is executed by different threads.\n   In particular it guarantees that the state of the variables is updated\n   atomically and it is always consistent when the function is executed */\nstatic XCP_MUTEX_DEFINE(xcpExtModeLock);\n\n\nuint32_T xcpCurrentSimulationTimeInTicks[2] = {0};\n\n/* The variable contains the last value of model simulation time \n   received via extmodeEvent() for the Base Rate thread.\n   In particular, the extmodeSimulationTime_T represents absolute time \n   (in baserate ticks)\n   Note: xcpBaseRateSimulationTime is assumed to be monotonically increasing, \n         but a counter overflow could occur */\nXCP_STATIC extmodeSimulationTime_T xcpBaseRateSimulationTime = 0;\n\n/* When LifeSpan is short, the xcpBaseRateSimulationTime variable could \n  \"overflow earlier than expected\", as the generated code may use only \n  a 16bit counter to store the baserate ticks.\n\n  The purpose of xcpTicksCounterL is to convert the xcpBaseRateSimulationTime \n  into a \"normal\" 32bit variable (and it relies on the EXTMODE_MAX_BASE_RATE_SIMULATION_TIME\n  value to understand when the overflow is supposed to occur).\n\n  xcpTicksCounterL and xcpTicksCounterH are then used to obtain \n  the xcpCurrentSimulationTimeInTicks global tick counter */\nXCP_STATIC uint32_T xcpTicksCounterL = 0;\nXCP_STATIC uint32_T xcpTicksCounterH = 0;\n\n/* The variable contains the last value of simulation time converted into a 32 bit\n   value with XCP_TIMESTAMP_UNIT resolution. This variable is only updated when\n   base rate is executed */\nXCP_STATIC uint32_T xcpBaseRateSimulationTimestamp = 0;\n\n#else /* INTEGER_CODE == 0 */\n\nuint32_T xcpCurrentSimulationTimeInMs[2] = {0};\nXCP_STATIC extmodeSimulationTime_T xcpBaseRateSimulationTime = 0;\n\n#endif\n\n#ifndef XCP_BIG_ENDIAN\n\nXCP_STATIC void xcpCopyTimeValue(volatile uint32_T *dst, uint32_T lsb, uint32_T msb)\n{\n    dst[0] = lsb;\n    dst[1] = msb;\n}\n\n#else /* BIG ENDIAN*/\n\n#define XCP_BYTES_SWAP(value)    ((((value) >> 24) & 0x000000ff)| \\\n                                  (((value) >> 8)  & 0x0000ff00)| \\\n                                  (((value) << 8)  & 0x00ff0000)| \\\n                                  (((value) << 24) & 0xff000000))\n\nXCP_STATIC void xcpCopyTimeValue(volatile uint32_T *dst, uint32_T lsb, uint32_T msb)\n{\n    dst[0] = XCP_BYTES_SWAP(lsb);\n    dst[1] = XCP_BYTES_SWAP(msb);\n}\n\n#endif /* BIG ENDIAN*/\n\n\n#if (defined(INTEGER_CODE) && INTEGER_CODE == 1) || defined(XCP_EXTMODE_SIMULATION_TIME_IN_TICKS)\n\n/* Define the XCP_TIMESTAMP_UNITS_PER_MICROSECOND value based on the\n   selected XCP_TIMESTAMP_UNIT */\n#if (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1US)\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND     1\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10US)\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND     10\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100US)\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND     100\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1MS)\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND     1000\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10MS)\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND     10000\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100MS)\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND     100000\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1S)\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND     1000000\n#else\n#error \"Invalid XCP_TIMESTAMP_UNIT value. When Purely Integer code is selected, it must be greater than or equal to XCP_TIMESTAMP_UNIT_1US.\"\n#endif\n\n\nstatic extmodeSimulationTime_T xcpExtModeMaxBaseRateSimulationTime = EXTMODE_MAX_BASE_RATE_SIMULATION_TIME;\n\n\n/* Internal function that updates absolute simulation time variables:\n   - xcpCurrentSimulationTimeInTicks \n   - xcpBaseRateSimulationTime\n   - xcpBaseRateSimulationTimestamp\n   and detect if the simulation is actually complete\n   (by updating xcpExtmodeSimulationComplete variable)\n \n   The function returns the 32bit XCP Timestamp counter value \n   (in XCP_TIMESTAMP_UNITs) corresponding to the given newTime\n \n   Note: the newTime input represents the model simulation time in base rate ticks */\nstatic uint32_T updateTime(extmodeSimulationTime_T newTime, extmodeEventId_T eventId)\n{\n    uint32_T timestamp = 0;\n\n    XCP_MUTEX_LOCK(xcpExtModeLock);\n    \n    if (eventId == EXTMODE_BASE_RATE_EVENT_ID) {\n        /* Absolute time variables are only updated when \n           base rate thread is executed */\n        extmodeSimulationTime_T ticksIncrement;\n        extmodeSimulationTime_T newCounterTicks;\n\n        /* Detect increment (in ticks) */\n        if (newTime >= xcpBaseRateSimulationTime) {\n            ticksIncrement = newTime - xcpBaseRateSimulationTime;\n        } else {\n            ticksIncrement = newTime + EXTMODE_MAX_BASE_RATE_SIMULATION_TIME - xcpBaseRateSimulationTime + 1;\n        }\n    \n        /* Update xcpTicksCounterL and xcpTicksCounterH tick counters */\n        newCounterTicks = xcpTicksCounterL + ticksIncrement;\n    \n        if (newCounterTicks < xcpTicksCounterL) {\n            xcpTicksCounterH++;\n        }\n        xcpTicksCounterL = newCounterTicks;\n\n        /* Update absolute simulation time values */\n        xcpCopyTimeValue(xcpCurrentSimulationTimeInTicks, xcpTicksCounterL, xcpTicksCounterH);\n\n        /* Save last received base rate simulation time */\n        xcpBaseRateSimulationTime = newTime;\n    \n        /* Update the 32bit XCP Timestamp counter for the base rate, using 32bit unsigned integer arithmetic */\n        xcpBaseRateSimulationTimestamp += ticksIncrement * EXTMODE_STEP_SIZE_IN_MICROSECONDS * XCP_TIMESTAMP_UNITS_PER_MICROSECOND;\n\n        timestamp = xcpBaseRateSimulationTimestamp;\n        \n        /* Check if simulation is complete */\n        if ((xcpExtmodeFinalSimulationTime != EXTMODE_SIMULATION_RUN_FOREVER) &&\n            (xcpExtmodeFinalSimulationTime != EXTMODE_SIMULATION_TIME_NOT_INITIALIZED)) {\n            /* By default, assuming EXTMODE_SIMULATION_RUN_FOREVER */\n            xcpExtmodeSimulationComplete = (xcpTicksCounterL >= xcpExtmodeFinalSimulationTime);\n        }\n    } else {\n        /* For threads different from the base rate, if the execution is\n           really concurrent, the simulationTime value might be different \n           from xcpBaseRateSimulationTime (ahead or behind).\n           The resulting timestamp value is calculated starting from \n           xcpBaseRateSimulationTimestamp and adding/subtracting the \n           difference */\n        extmodeSimulationTime_T ticksIncrement = 0;\n        extmodeSimulationTime_T ticksDecrement = 0;\n        \n        if (xcpExtModeMaxBaseRateSimulationTime < MAX_extmodeSimulationTime_T) {\n            /* If the size of extmodeSimulationTime_T data type allows\n               the representation of numbers bigger than EXTMODE_MAX_BASE_RATE_SIMULATION_TIME\n               then the newTime value needs to be \"converted\" to just use the same\n               amount of bits as the Base Rate (ClockTick0)\n               Note: this happens for example when ClockTicks are uint16_T and\n               extmodeSimulationTime_T is uint32_T. If the first subrate is half\n               of the base rate then\n                   newTime = ClockTick1 * 2\n               and this time would end up being bigger than EXTMODE_MAX_BASE_RATE_SIMULATION_TIME */\n            newTime = newTime % (xcpExtModeMaxBaseRateSimulationTime + 1);\n        }\n\n        if (newTime >= xcpBaseRateSimulationTime) {\n            /* We need to identify one of the two cases:\n               - newTime is ahead of xcpBaseRateSimulationTime\n               - newTime is behind but an overflow occurred\n             */\n            ticksIncrement = newTime - xcpBaseRateSimulationTime;\n            ticksDecrement = xcpBaseRateSimulationTime + EXTMODE_MAX_BASE_RATE_SIMULATION_TIME - newTime + 1;\n\n            if (ticksDecrement <= ticksIncrement) {\n                /* Assuming that newTime is behind and an overflow has occurred */\n                ticksIncrement = 0;\n            } else {\n            \t/* assuming that newTime is ahead */\n                ticksDecrement = 0;\n            }\n        } else {\n            /* We need to identify one of the two cases:\n               - newTime is behind of xcpBaseRateSimulationTime\n               - newTime is ahead but an overflow occurred\n             */\n            ticksIncrement = newTime + EXTMODE_MAX_BASE_RATE_SIMULATION_TIME - xcpBaseRateSimulationTime + 1;\n            ticksDecrement = xcpBaseRateSimulationTime - newTime;\n\n            if (ticksDecrement <= ticksIncrement) {\n                /* Assuming that newTime is behind, as more likely */\n                ticksIncrement = 0;\n            } else {\n            \t/* assuming that newTime is ahead and an overflow has occurred */\n                ticksDecrement = 0;\n            }\n        }\n\n        if (ticksIncrement > 0) {\n            timestamp = xcpBaseRateSimulationTimestamp +\n                        (ticksIncrement * EXTMODE_STEP_SIZE_IN_MICROSECONDS * XCP_TIMESTAMP_UNITS_PER_MICROSECOND);\n        } else {\n            timestamp = xcpBaseRateSimulationTimestamp -\n                        (ticksDecrement * EXTMODE_STEP_SIZE_IN_MICROSECONDS * XCP_TIMESTAMP_UNITS_PER_MICROSECOND);\n        }\n    }\n\n    XCP_MUTEX_UNLOCK(xcpExtModeLock);\n    \n    return timestamp;\n}\n\n/* Update absolute simulation time variables\n   and detect if the simulation is actually complete\n\n   Note: the newTime input represents the current model simulation time */\nvoid xcpExtModeUpdateTime(extmodeSimulationTime_T newTime, extmodeEventId_T eventId)\n{\n    updateTime(newTime, eventId);\n}\n\n/* In addition to updating absolute simulation time variables\n   and detecting if the simulation is actually complete, \n   the function returns the 32bit XCP Timestamp counter value\n   (in XCP_TIMESTAMP_UNITs) corresponding to the given newTime\n\n   Note: the newTime input represents the model simulation time */\nuint32_T xcpExtModeGetUpdatedTimestamp(extmodeSimulationTime_T newTime, extmodeEventId_T eventId)\n{\n    return updateTime(newTime, eventId);\n}\n\n\n#ifdef XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME\n\n/* Return value in XCP_TIMESTAMP_UNITs, based on the current model simulation time */\nuint32_T xcpGetTimestamp(void)\n{\n    uint32_T timestamp;\n\n    /* @note: theoretically the base thread could pre-preempt any thread during the\n       read operation. Since the read of a 32bit value may not be atomic\n       in some architectures we have to protect it with a mutex.\n       We may be able to remove this lock if we extend the Platform Abstraction Layer\n       to include atomic read operations */\n    XCP_MUTEX_LOCK(xcpExtModeLock);\n\n    timestamp = xcpBaseRateSimulationTimestamp;\n\n    XCP_MUTEX_UNLOCK(xcpExtModeLock);\n\n    return timestamp;\n}\n\n#endif /* XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME */\n\n#else /* INTEGER_CODE == 0 */\n\n/* Define the XCP_TIMESTAMP_UNITS_PER_SECOND value based on the\n   selected XCP_TIMESTAMP_UNIT */\n#if (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1NS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e9\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10NS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e8\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100NS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e7\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1US)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e6\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10US)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e5\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100US)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e4\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1MS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e3\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10MS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e2\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100MS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e1\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1S)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND            1\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1PS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND         1e12\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10PS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND         1e11\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100PS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND         1e10\n#else\n#error \"invalid XCP_TIMESTAMP_UNIT value\"\n#endif\n\n\n/* Update absolute simulation time variable xcpCurrentSimulationTimeInMs\n   and detect if the simulation is actually complete\n   (by updating xcpExtmodeSimulationComplete variable)\n\n   The function returns the 32bit XCP Timestamp counter value\n   (in XCP_TIMESTAMP_UNITs) corresponding to the given newTime\n\n   Note: the newTime input represents the model simulation time in seconds */\nvoid xcpExtModeUpdateTime(extmodeSimulationTime_T newTime, extmodeEventId_T eventId)\n{\n    if (eventId == EXTMODE_BASE_RATE_EVENT_ID) {\n        /* Absolute time variables are only updated when base rate\n           thread is executed, no need to use any lock */\n        real_T   timeInMs = newTime * 1000.0;\n        uint32_T timeInMsL = (uint32_T)fmod(timeInMs, (extmodeSimulationTime_T) XCP_UINT32_MAX + 1);\n        uint32_T timeInMsH = 0;\n\n        if (timeInMs > XCP_UINT32_MAX) {\n            /* cast truncates, rounding to zero */\n            timeInMsH = (uint32_T)(timeInMs / XCP_UINT32_MAX);\n        }\n\n        /* Update absolute simulation time variables */\n        xcpCopyTimeValue(xcpCurrentSimulationTimeInMs, timeInMsL, timeInMsH);\n\n        /* Check if simulation is complete */\n        if ((xcpExtmodeFinalSimulationTime != EXTMODE_SIMULATION_RUN_FOREVER) &&\n            (xcpExtmodeFinalSimulationTime != EXTMODE_SIMULATION_TIME_NOT_INITIALIZED)) {\n            /* By default, assuming EXTMODE_SIMULATION_RUN_FOREVER */\n           xcpExtmodeSimulationComplete = (xcpExtmodeFinalSimulationTime - newTime) <\n                                          (newTime * (DBL_EPSILON));\n        }\n\n        /* Update the current simulation time */\n        xcpBaseRateSimulationTime = newTime;\n    }\n}\n\n/* In addition to updating absolute simulation time variables\n   and detecting if the simulation is actually complete, \n   the function returns the 32bit XCP Timestamp counter value\n   (in XCP_TIMESTAMP_UNITs) corresponding to the given newTime\n\n   Note: the newTime input represents the model simulation time */\nuint32_T xcpExtModeGetUpdatedTimestamp(extmodeSimulationTime_T newTime, extmodeEventId_T eventId)\n{\n    uint32_T timestamp = 0;\n\n    xcpExtModeUpdateTime(newTime, eventId);\n\n    /* Convert the newTime into the 32 bits XCP Timestamp counter, based on XCP configuration */\n    timestamp = (uint32_T)fmod(newTime * (extmodeSimulationTime_T) XCP_TIMESTAMP_UNITS_PER_SECOND + 0.5, \n                              (extmodeSimulationTime_T)XCP_UINT32_MAX + 1);\n\n    return timestamp;\n}\n\n\n#ifdef XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME\n\n/* This function is supposed to return the value of the XCP Timestamp in XCP_TIMESTAMP_UNITs.\n   Specifically it is invoked within the xcpEvent().\n   When XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME is defined, both extmodeEvent() and \n   rtExtModeUpload() use xcpEventExternalTimestamp() instead, so we should never hit this function.\n   However we need to provide a dummy implementation as the function is required by the \n   Platform Abstraction Layer. */\nuint32_T xcpGetTimestamp(void)\n{\n    return 0;\n}\n\n#endif /* XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME */\n\n#endif /* INTEGER_CODE == 1 */\n\n\nuint32_T xcpExtModeGetSimulationTime(void)\n{  \n#ifdef XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME\n    /* Even if not thread-safe, this implementation has been added for backward compatibility \n       as Code Execution Profiling was invoking the xcpEvent() API directly */\n    return xcpExtModeGetUpdatedTimestamp(xcpBaseRateSimulationTime, EXTMODE_BASE_RATE_EVENT_ID);\n#else\n    return 0;\n#endif\n}\n\n\nXcpErrorCode xcpExtModeInit(void)\n{\n    int_T parNumber = 0;\n    void **parList = NULL;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    \n#if !defined(INTEGER_CODE) || INTEGER_CODE == 0\n    /* Use dummy variable to prevent optimization in some compilers */\n    xcpDummyDoubleVariable = (extmodeDouble_T) 0;\n#endif\n\n#ifdef MAX_uint64_T\n    xcpDummyUint64Variable = (uint64_T) 0;\n#endif\n\n#if defined(INTEGER_CODE) && INTEGER_CODE == 1\n    XCP_MUTEX_INIT(xcpExtModeLock);\n#endif\n\n#ifdef XCP_CUSTOM_ADDRESS_TRANSLATION\n    xcpInitCustomAddressGet();\n#endif\n\n    /* Retrieve XCP Transport Layer initialization parameters */\n    xcpTransportGetInitParameters(&parNumber, &parList);\n\n    /* Initialize XCP Transport Layer */\n    errorCode = xcpTransportInit(parNumber, parList);\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpExtModeInit: xcpTransportInit error\\n\");\n        return errorCode;\n    }\n\n    /* Retrieve XCP Protocol Layer initialization parameters */\n    xcpGetInitParameters(&parNumber, &parList);\n\n    /* Initialize XCP Protocol layer */\n    errorCode = xcpInit(parNumber, parList);\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpExtModeInit: xcpInit error: code %d\\n\", errorCode);\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpExtModeRunBackground(boolean_T flushAllData)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    boolean_T done = false;\n\n    /* Add a dummy delay, that forces the task to pause the execution\n       (leaving the 'running' state). This gives Simulink the opportunity\n       to run when connecting to host-based targets in External Mode */\n    XCP_SLEEP(0, 0);\n\n    do {\n        boolean_T dataAvailable = false;\n\n        /* Retrieve a new Rx packet from interface */\n        errorCode = xcpTransportRx();\n\n        if ((errorCode != XCP_SUCCESS) && (errorCode != XCP_EMPTY)) {\n            XCP_PRINTF(\"xcpExtModeRunBackground: xcpTransportRx error, code %d\\n\", errorCode);\n            done = true;\n        } else {\n            dataAvailable = dataAvailable || (errorCode != XCP_EMPTY);\n        }\n\n        if (!done) {\n            /* Process it within the protocol layer.\n               By checking the return code value, diagnostic info on\n               XCP packet processing can be collected.\n               Every run corresponds to the processing of one single XCP packet */\n            errorCode = xcpRun();\n\n            if ((errorCode != XCP_SUCCESS) && (errorCode != XCP_EMPTY)) {\n                XCP_PRINTF(\"xcpExtModeRunBackground: xcpRun error, code %d\\n\", errorCode);\n                done = true;\n            } else {\n                dataAvailable = dataAvailable || (errorCode != XCP_EMPTY);\n            }\n        }\n\n        if (!done) {\n            /* Send one of the pending Tx packets over the network */\n            errorCode = xcpTransportTx();\n            if ((errorCode != XCP_SUCCESS) && (errorCode != XCP_EMPTY)) {\n                XCP_PRINTF(\"xcpExtModeRunBackground: xcpTransportTx error, code %d\\n\", errorCode);\n                done = true;\n            } else {\n                dataAvailable = dataAvailable || (errorCode != XCP_EMPTY);\n            }\n        }\n\n        if (flushAllData) {\n#if EXTMODE_FLUSH_ALL_DATA_DELAY_TIME_IN_MICROSECONDS > 0\n            /* Dummy delay, that forces the background task to pause the execution\n               and reduces the packets transmission rate, for host-based targets. */\n            XCP_SLEEP(0, EXTMODE_FLUSH_ALL_DATA_DELAY_TIME_IN_MICROSECONDS);\n#endif\n            /* The xcpExtModeRunBackground will continue to process packets until\n               the TX and RX queues are empty or an error occurred. */\n            done = done || !dataAvailable;\n        } else {\n            /* The xcpExtModeRunBackground will only carry out one iteration and then return.\n               The remaining packets will be processed at the next round. */\n            done = true;\n        }\n    } while (!done);\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpExtModeReset(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    extmodeRealTime_T elapsedTime;\n    XcpStatus status;\n\n    if (xcpExtmodeSimulationComplete) {\n        /* When DAQ Packed Mode is enabled, if we reached the nominal end of the\n           simulation we trigger the transmission of a packet containing the samples \n           received so far. The trailing '0's will be removed and not displayed\n           in the output of the simulation */\n        xcpPackedModeEventsFlush(0);\n    }\n\n    /* Wait for the XCP client to complete the clean disconnection procedure */\n    status = xcpGetStatus();\n\n    elapsedTime = 0;\n    while ((elapsedTime < EXTMODE_SHUTDOWN_TIMEOUT_IN_MICROSECONDS) &&\n           (status != XCP_DISCONNECTED)) {\n\n        XCP_SLEEP(0, EXTMODE_RETRY_TIME_IN_MICROSECONDS);\n        elapsedTime += EXTMODE_RETRY_TIME_IN_MICROSECONDS;\n\n        /* Run the XCP Stack to keep the communication 'alive',\n           forcing the flush of all data */\n        xcpExtModeRunBackground(true);\n\n        /* Check the XCP stack status again */\n        status = xcpGetStatus();\n    }\n\n    /* Reset XCP Protocol Layer */\n    errorCode = xcpReset();\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpReset error: code %d\\n\", errorCode);\n    }\n\n    /* Reset XCP Transport Layer */\n    errorCode = xcpTransportReset();\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportReset error: code %d\\n\", errorCode);\n    }\n\n    /* Restore the global variables to the default value */\n#if defined(ON_TARGET_WAIT_FOR_START) && ON_TARGET_WAIT_FOR_START == 1\n    xcpModelStartRequest = false;\n#else\n    xcpModelStartRequest = true;\n#endif\n\n    xcpModelStopRequest = false;\n\n    xcpModelChecksum0   = 0;\n    xcpModelChecksum1   = 0;\n    xcpModelChecksum2   = 0;\n    xcpModelChecksum3   = 0;\n    xcpModelIntegerCode = 0;\n\n#if defined(INTEGER_CODE) && INTEGER_CODE == 1\n    xcpExtmodeFinalSimulationTime = EXTMODE_SIMULATION_RUN_FOREVER;\n\n    xcpBaseRateSimulationTime = 0;\n\n    xcpTicksCounterL = 0;\n    xcpTicksCounterH = 0;\n\n    xcpBaseRateSimulationTimestamp = 0;\n#else\n    xcpExtmodeFinalSimulationTime = EXTMODE_SIMULATION_TIME_NOT_INITIALIZED;\n#endif\n\n    xcpExtmodeSimulationComplete  = false;\n\n#if (defined(INTEGER_CODE) && INTEGER_CODE == 1) || defined(XCP_EXTMODE_SIMULATION_TIME_IN_TICKS)\n    XCP_MEMSET(xcpCurrentSimulationTimeInTicks, 0, sizeof(xcpCurrentSimulationTimeInTicks));\n\n    xcpBaseRateSimulationTime = 0;\n\n    xcpTicksCounterL = 0;\n    xcpTicksCounterH = 0;\n\n    xcpBaseRateSimulationTimestamp = 0;\n#else\n    XCP_MEMSET(xcpCurrentSimulationTimeInMs, 0, sizeof(xcpCurrentSimulationTimeInMs));\n    xcpBaseRateSimulationTime = 0;\n#endif\n\n    return errorCode;\n}\n"},{"name":"xcp_ext_mode.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2025b/toolbox/coder/xcp/src/target/ext_mode/src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2017-2024 The MathWorks, Inc.\n *\n * File: xcp_ext_mode.c\n *\n * Abstract:\n *  The file provides the implementation of the ext_mode.h interface\n *  based on XCP communication protocol\n */\n\n#if !defined(EXTMODE_DISABLE_ARGS_PROCESSING)\n#include <stdio.h>\n#endif\n\n#include <string.h>        /* optional for strcmp */\n\n#include \"xcp_ext_common.h\"\n#include \"xcp_ext_param.h\"\n#include \"xcp_internal.h\"\n#include \"ext_mode.h\"\n\n\n#ifdef EXTMODE_XCP_TRIGGER_SUPPORT\n\n#include \"xcp_ext_classic_trigger.h\"\n\n#ifndef EXTMODE_XCP_MAX_TRIGGER_NUMBER\n#if defined(XCP_MEM_DAQ_RESERVED_POOLS_NUMBER) && (XCP_MEM_DAQ_RESERVED_POOLS_NUMBER > 0)\n/* If XCP_MEM_DAQ_RESERVED_POOLS_NUMBER is defined, the value of this macro should be at least\n   equal to the number of sample times in the model. This can be one more than the number of DAQ\n   lists that use reserved pools if Tid 0 and 1 are mapped to the same DAQ list. */\n#define EXTMODE_XCP_MAX_TRIGGER_NUMBER XCP_MEM_DAQ_RESERVED_POOLS_NUMBER + 1\n#else\n#define EXTMODE_XCP_MAX_TRIGGER_NUMBER EXTMODE_MAX_EVENT_ID\n#endif\n#endif /* EXTMODE_XCP_MAX_TRIGGER_NUMBER */\n\n#if (EXTMODE_XCP_MAX_TRIGGER_NUMBER > EXTMODE_MAX_EVENT_ID) || (EXTMODE_XCP_MAX_TRIGGER_NUMBER < 1)\n#error Invalid EXTMODE_XCP_MAX_TRIGGER_NUMBER value.\n#endif\n\nstatic extmodeEventTriggerEnable xcpCustomTriggerFunction[EXTMODE_XCP_MAX_TRIGGER_NUMBER];\n\n#endif\n\n\nextmodeErrorCode_T extmodeParseArgs(int_T   argc,\n                                    const char_T *argv[])\n{\n    extmodeErrorCode_T errorCode = EXTMODE_SUCCESS;\n\n#ifdef  EXTMODE_DISABLE_ARGS_PROCESSING\n    /* Some targets do not support command line args */\n    UNUSED_PARAMETER(argc);\n    UNUSED_PARAMETER(argv);\n#else\n    boolean_T  parseError = false;\n    int_T  count = 1;\n\n    if (argc < 0) {\n        XCP_PRINTF(\"extmodeParseArgs: argc must be a positive number\\n\");\n        return EXTMODE_INV_ARG;\n    }\n\n    if ((argc > 0) && (argv == NULL)) {\n        XCP_PRINTF(\"extmodeParseArgs: invalid argv value\\n\");\n        return EXTMODE_INV_ARG;\n    }\n\n    /*\n     * Parse the External Mode Platform-independent Abstraction Layer parameters.\n     * Let all unrecognized parameters pass through to the XCP External Mode \n     * Platform-specific Abstraction Layer.\n     * NULL out all args handled so that they can ignored by the lower layer.\n     */\n    while (count < argc) {\n        const char_T *option = argv[count++];\n\n        if (option != NULL) {\n            /* final time */\n            if ((strcmp(option, \"-tf\") == 0) && (count != argc)) {\n                const char_T *timeValueString = argv[count++];\n                extmodeSimulationTime_T  timeValue = 0;\n                char_T        stringBuffer[201];\n\n                XCP_MEMSET(stringBuffer, 0, sizeof(stringBuffer));\n\n                sscanf(timeValueString, \"%200s\", stringBuffer);\n                if (strcmp(stringBuffer, \"inf\") == 0) {\n                    timeValue = EXTMODE_SIMULATION_RUN_FOREVER;\n                }\n                else {\n                    char_T tmpString[2];\n\n#if (defined(INTEGER_CODE) && INTEGER_CODE == 1) || defined(XCP_EXTMODE_SIMULATION_TIME_IN_TICKS)\n                    int tmpValue;\n\n                    if ((sscanf(stringBuffer, \"%d%1s\", &tmpValue, tmpString) != 1) ||\n                        (tmpValue < 0)) {\n                        XCP_PRINTF(\"External mode final simulation time must be a positive, integer value or inf\\n\");\n                        parseError = true;\n                        break;\n                    }\n                    timeValue = (extmodeSimulationTime_T) tmpValue;\n#else\n                    if ((sscanf(stringBuffer, \"%lf%1s\", &timeValue, tmpString) != 1) ||\n                        (timeValue < (extmodeSimulationTime_T)0)) {\n                        XCP_PRINTF(\"External mode final simulation time must be a positive, real value or inf\\n\");\n                        parseError = true;\n                        break;\n                    }\n#endif\n                }\n                xcpExtmodeFinalSimulationTime = timeValue;\n\n                argv[count - 2] = NULL;\n                argv[count - 1] = NULL;\n            }\n            /* -w (wait for packet from host) option */\n            else if (strcmp(option, \"-w\") == 0) {\n                xcpModelStartRequest = false;\n                argv[count - 1] = NULL;\n            }\n        }\n    }\n\n    if (parseError) {\n        XCP_PRINTF(\"\\nUsage: model_name -option1 val1 -option2 val2 -option3 \"\n            \"...\\n\\n\");\n\n#if (defined(INTEGER_CODE) && INTEGER_CODE == 1) || defined(XCP_EXTMODE_SIMULATION_TIME_IN_TICKS)\n        XCP_PRINTF(\"\\t-tf 20 - sets final time to 20 ticks\\n\");\n#else\n        XCP_PRINTF(\"\\t-tf 20 - sets final time to 20 seconds\\n\");\n#endif\n\n        return EXTMODE_INV_ARG;\n    }\n\n    /* Extract XCP specific initialization parameters, by invoking the \n       XCP External Mode Platform-specific Abstraction Layer API */\n    xcpExtModeParseArgs(argc, argv);\n\n    /*\n     * Check for unprocessed (\"unhandled\") args.\n     */\n    {\n        int i;\n        for (i = 1; i<argc; i++) {\n            if (argv[i] != NULL) {\n                XCP_PRINTF(\"Unexpected command line argument: %s\\n\", argv[i]);\n                return EXTMODE_INV_ARG;\n            }\n        }\n    }\n\n#endif /* EXTMODE_DISABLE_ARGS_PROCESSING */\n\n    return errorCode;\n}\n\n\nextmodeErrorCode_T extmodeInit(RTWExtModeInfo *extmodeInfo, extmodeSimulationTime_T *finalTime)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    if (extmodeInfo == NULL) {\n        XCP_PRINTF(\"extmodeInit: invalid extmodeInfo\\n\");\n        return EXTMODE_INV_ARG;\n    }\n\n    if (finalTime == NULL) {\n        XCP_PRINTF(\"extmodeInit: invalid finalTime variable\\n\");\n        return EXTMODE_INV_ARG;\n    }\n\n    if (xcpExtmodeFinalSimulationTime == EXTMODE_SIMULATION_TIME_NOT_INITIALIZED) {\n#if (defined(INTEGER_CODE) && INTEGER_CODE == 1)\n        /* If the model final simulation time in External Mode has NOT been initialized,\n           then EXTMODE_SIMULATION_RUN_FOREVER is assumed, as the Real-time Model\n           structure doesn't contain any final time information when PurelyIntegerCode\n           is selected */\n        xcpExtmodeFinalSimulationTime = EXTMODE_SIMULATION_RUN_FOREVER;\n#else\n        /* If the model final simulation time in External Mode has NOT been initialized,\n           then the finalTime argument is considered an INPUT */\n        xcpExtmodeFinalSimulationTime = *finalTime;\n#endif\n    }\n    else {\n        /* If the model final simulation time in External Mode has been initialized\n           (e.g. via '-tf ' parameter detected by extmodeParseArgs() or\n            via explicit call of extmodeSetFinalSimulationTime())\n           then the finalTime argument is considered an OUTPUT */\n        *finalTime = xcpExtmodeFinalSimulationTime;\n    }\n\n    if (xcpExtmodeFinalSimulationTime == EXTMODE_SIMULATION_RUN_FOREVER) {\n        XCP_PRINTF(\"\\n**warning: the simulation will run with no stop time due \"\n            \"to external mode infinite final simulation time.\\n\");\n    }\n\n    /* Initialize the model checksum information */\n    xcpModelChecksum0 = rteiGetChecksum0(extmodeInfo);\n    xcpModelChecksum1 = rteiGetChecksum1(extmodeInfo);\n    xcpModelChecksum2 = rteiGetChecksum2(extmodeInfo);\n    xcpModelChecksum3 = rteiGetChecksum3(extmodeInfo);\n\n#if defined(INTEGER_CODE) && INTEGER_CODE == 1\n    xcpModelIntegerCode = 1;\n#else\n    xcpModelIntegerCode = 0;\n#endif\n\n#ifdef EXTMODE_XCP_TRIGGER_SUPPORT\n    xcpExtModeClassicTriggerInit();\n\n    /* By default, use Classic Triggering */\n    {\n        unsigned i = 0;\n        for (i = 0; i < EXTMODE_XCP_MAX_TRIGGER_NUMBER; i++) {\n            xcpCustomTriggerFunction[i] = xcpExtModeClassicTriggerEnabled;\n        }\n    }\n#endif\n\n    /* Initialize the platform abstraction layer common services */\n    errorCode = xcpExtModeInit();\n    \n    if (errorCode == XCP_SUCCESS) {\n        xcpModelStatus = XCP_EXTMODE_STATUS_INITIALIZED;\n    }\n\n    return XCP_TO_EXTMODE_ERROR_CODE(errorCode);\n}\n\n\nextmodeErrorCode_T extmodeWaitForHostRequest(extmodeRealTime_T timeoutInMicroseconds)\n{\n    extmodeErrorCode_T errorCode = EXTMODE_SUCCESS;\n    extmodeRealTime_T elapsedTime = 0;\n    boolean_T timeoutExpired = false;\n    boolean_T waitForHostRequest = !xcpModelStartRequest;\n    xcpModelStatus = XCP_EXTMODE_STATUS_WAITING_TO_START;\n\n    timeoutExpired = (timeoutInMicroseconds == 0) && !xcpModelStartRequest && !xcpModelStopRequest;\n\n    /*\n     * Pause until the XCP client modifies the xcpModelStartRequest value\n     * or a stop request has been issued\n     */\n    while (!xcpModelStartRequest && !xcpModelStopRequest && !timeoutExpired) {\n        XCP_SLEEP(0L, EXTMODE_RETRY_TIME_IN_MICROSECONDS);\n        elapsedTime += EXTMODE_RETRY_TIME_IN_MICROSECONDS;\n\n        timeoutExpired = (timeoutInMicroseconds != EXTMODE_WAIT_FOREVER) &&\n                         (elapsedTime > timeoutInMicroseconds);\n\n        xcpExtModeRunBackground(DEFAULT_XCP_EXTMODE_RUN_BACKGROUND_FLUSH);\n    }\n\n    xcpModelStatus = XCP_EXTMODE_STATUS_READY_TO_RUN;\n\n    if (timeoutExpired) {\n        errorCode = EXTMODE_TIMEOUT_ERROR;\n    }\n\n#ifdef EXTMODE_XCP_TRIGGER_SUPPORT\n    /* Avoid missing logged data points at t = 0 in concurrent execution workflows. */\n    if (waitForHostRequest) {\n        xcpExtModeClassicTriggerForceEnableStatusUpdate();\n    }\n#endif\n    return errorCode;\n}\n\n\nextmodeErrorCode_T extmodeEvent(extmodeEventId_T eventId, extmodeSimulationTime_T simulationTime)\n{\n    XcpErrorCode errorCode  = XCP_SUCCESS;\n    boolean_T triggerEnable = true;\n\n#if (!defined(INTEGER_CODE) || (INTEGER_CODE == 0)) && (!defined(XCP_EXTMODE_SIMULATION_TIME_IN_TICKS))\n    if (simulationTime < 0) {\n        XCP_PRINTF(\"extmodeEvent error: invalid simulationTime, must be non-negative\\n\");\n        return EXTMODE_INV_ARG;\n    }\n#endif\n\n    if (eventId > EXTMODE_MAX_EVENT_ID) {\n        XCP_PRINTF(\"extmodeEvent error: invalid eventId (%d), must be less than %d\\n\", eventId, EXTMODE_MAX_EVENT_ID);\n        return EXTMODE_INV_ARG;\n    }\n    \n    if ((xcpModelStatus == XCP_EXTMODE_STATUS_READY_TO_RUN) ||\n        (xcpModelStatus == XCP_EXTMODE_STATUS_INITIALIZED)) {\n        /* Update model status, as soon as the extmodeEvent() gets invoked */\n        xcpModelStatus = XCP_EXTMODE_STATUS_RUNNING;\n    }\n\n#ifdef EXTMODE_XCP_TRIGGER_SUPPORT\n    if ((eventId < EXTMODE_XCP_MAX_TRIGGER_NUMBER) &&\n        (xcpCustomTriggerFunction[eventId] != NULL)) {\n        /* Trigger logic should be applied only when the synchronous\n           data transfer is active */\n        XcpStatus xcpStatus = xcpGetStatus();\n        if (xcpStatus == XCP_SYNC_DATA_TRANSFER) {\n            triggerEnable = xcpCustomTriggerFunction[eventId](eventId);\n        }\n    }\n#endif\n    {\n        XcpEventIdType xcpEventId = (XcpEventIdType) eventId;\n\n#ifdef XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME\n        /* Update local absolute time variables*/\n        uint32_T timestampBasedOnSimTime = xcpExtModeGetUpdatedTimestamp(simulationTime, eventId);\n#else\n        /* Update local absolute time variables*/\n        xcpExtModeUpdateTime(simulationTime, eventId);\n#endif\n\n        if (triggerEnable) {\n#ifdef XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME\n            /* Notify XCP Stack about the eventId */\n            errorCode = xcpEventExternalTimestamp(xcpEventId, timestampBasedOnSimTime);\n#else\n            /* Notify XCP Stack about the eventId, using the timestamp read\n               from the HW timer supported by XCP Platform Abstraction layer */\n            errorCode = xcpEvent(xcpEventId);\n#endif\n        } else {\n            /* reset pending packed DAQ lists if the trigger did not fire so that we do not send\n               packets with non-consecutive samples */\n            xcpPackedModeEventReset(xcpEventId);\n        }\n    }\n\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"extmodeEvent error: code %d\\n\", errorCode);\n    }\n\n    return XCP_TO_EXTMODE_ERROR_CODE(errorCode);\n}\n\n\nextmodeErrorCode_T extmodeBackgroundRun(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    errorCode = xcpExtModeRunBackground(DEFAULT_XCP_EXTMODE_RUN_BACKGROUND_FLUSH);\n\n    return XCP_TO_EXTMODE_ERROR_CODE(errorCode);\n}\n\n\nextmodeErrorCode_T extmodeReset(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    xcpModelStatus = XCP_EXTMODE_STATUS_RESETTING;\n    \n    errorCode = xcpExtModeReset();\n\n#ifdef EXTMODE_XCP_TRIGGER_SUPPORT\n    XCP_MEMSET(xcpCustomTriggerFunction, 0, sizeof(xcpCustomTriggerFunction));\n\n    xcpExtModeClassicTriggerReset();\n#endif\n\n    xcpModelStatus = XCP_EXTMODE_STATUS_RESET;\n    \n    return XCP_TO_EXTMODE_ERROR_CODE(errorCode);\n}\n\nboolean_T extmodeStopRequested(void)\n{\n    return xcpModelStopRequest;\n}\n\nboolean_T extmodeStartRequested(void)\n{\n    return xcpModelStartRequest;\n}\n\n\nboolean_T extmodeSimulationComplete(void)\n{\n    return xcpExtmodeSimulationComplete;\n}\n\nextmodeErrorCode_T extmodeGetFinalSimulationTime(extmodeSimulationTime_T *finalTime)\n{\n    if (finalTime == NULL) {\n        XCP_PRINTF(\"extmodeGetFinalSimulationTime: invalid finalTime variable\\n\");\n        return EXTMODE_INV_ARG;\n    }\n\n    if (xcpExtmodeFinalSimulationTime == EXTMODE_SIMULATION_TIME_NOT_INITIALIZED) {\n        XCP_PRINTF(\"extmodeGetFinalSimulationTime: finalTime not initialized\\n\");\n        return EXTMODE_NOT_INITIALIZED;\n    }\n\n    *finalTime = xcpExtmodeFinalSimulationTime;\n\n    return EXTMODE_SUCCESS;\n}\n\nextmodeErrorCode_T extmodeSetFinalSimulationTime(extmodeSimulationTime_T finalTime)\n{\n#if (!defined(INTEGER_CODE) || (INTEGER_CODE == 0)) && (!defined(XCP_EXTMODE_SIMULATION_TIME_IN_TICKS))\n    if ((finalTime < 0) && (finalTime != EXTMODE_SIMULATION_RUN_FOREVER)) {\n        XCP_PRINTF(\"extmodeSetFinalSimulationTime: invalid finalTime value\\n\");\n        return EXTMODE_INV_ARG;\n    }\n#endif\n\n    xcpExtmodeFinalSimulationTime = finalTime;\n\n    return EXTMODE_SUCCESS;\n}\n\n#ifdef EXTMODE_XCP_TRIGGER_SUPPORT\n\nextmodeErrorCode_T extmodeGetEventTriggerEnable(extmodeEventId_T eventId, extmodeEventTriggerEnable *triggerEnable)\n{\n    if (eventId >= EXTMODE_XCP_MAX_TRIGGER_NUMBER) {\n        XCP_PRINTF(\"extmodeGetEventTriggerEnable: invalid eventId value\\n\");\n        return EXTMODE_INV_ARG;\n    }\n\n    if (triggerEnable == NULL) {\n        XCP_PRINTF(\"extmodeGetEventTriggerEnable: invalid triggerEnabled value\\n\");\n        return EXTMODE_INV_ARG;\n    }\n\n    *triggerEnable = xcpCustomTriggerFunction[eventId];\n\n    return EXTMODE_SUCCESS;\n}\n\nextmodeErrorCode_T extmodeSetEventTriggerEnable(extmodeEventId_T eventId, extmodeEventTriggerEnable triggerEnable)\n{\n    if (eventId >= EXTMODE_XCP_MAX_TRIGGER_NUMBER) {\n        XCP_PRINTF(\"extmodeSetEventTriggerEnable: invalid eventId value\\n\");\n        return EXTMODE_INV_ARG;\n    }\n\n    xcpCustomTriggerFunction[eventId] = triggerEnable;\n    return EXTMODE_SUCCESS;\n}\n\n#else\n\nextmodeErrorCode_T extmodeGetEventTriggerEnable(extmodeEventId_T eventId, extmodeEventTriggerEnable *triggerEnable)\n{\n    UNUSED_PARAMETER(eventId);\n\n    if (triggerEnable != NULL) {\n        *triggerEnable = NULL;\n    }\n\n    return EXTMODE_SUCCESS;\n}\n\nextmodeErrorCode_T extmodeSetEventTriggerEnable(extmodeEventId_T eventId, extmodeEventTriggerEnable triggerEnable)\n{\n    UNUSED_PARAMETER(eventId);\n    UNUSED_PARAMETER(triggerEnable);\n\n    return EXTMODE_SUCCESS;\n}\n\n#endif\n"},{"name":"xcp_ext_param_default_serial.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2025b/toolbox/coder/xcp/src/target/ext_mode/src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2017-2022 The MathWorks, Inc.\n *\n * File: xcp_ext_param_default_serial.c     \n *\n * Abstract:\n *  The file provides the implementation of the xcp_ext_param.h \n *  interface specific for the XCP Default Platform Abstraction Layer\n *  for the Serial transport layer.\n */\n\n#include \"rtwtypes.h\"\n\n#include \"rtw_extmode.h\"\n\n#include \"xcp_common.h\"\n#include \"xcp_ext_param.h\"\n\n#ifndef EXTMODE_DISABLE_ARGS_PROCESSING\n\n /** Transport Layer initialization parameters \n     @note the default values can be overwritten when parsing the\n           External Mode command line arguments */\nstatic const void* xcpTransportLayerParams[] =\n{\n    \"-port\", \"1\",\n    \"-baud\", \"57600\",\n    \"-verbose\", \"0\",\n};\n\n#endif /* EXTMODE_DISABLE_ARGS_PROCESSING */\n\nvoid xcpExtModeParseArgs(int_T argc, const char_T *argv[])\n{\n#ifdef  EXTMODE_DISABLE_ARGS_PROCESSING\n    /* Some targets do not support command line args */\n    UNUSED_PARAMETER(argc);\n    UNUSED_PARAMETER(argv);\n#else\n    if ((argv != NULL) && (argc > 0)) {\n        int_T optionId = 1;\n        uint_T idx;\n\n        while (optionId < argc) {\n            const char_T *option = argv[optionId];\n\n            optionId++;\n\n            if ((option != NULL) && (optionId != argc)) {\n                boolean_T isXcpOption = false;\n\n                for (idx = 0; idx < sizeof(xcpTransportLayerParams)/sizeof(xcpTransportLayerParams[0]); idx = idx + 2){\n                    if (strcmp(option, xcpTransportLayerParams[idx]) == 0) {\n                        xcpTransportLayerParams[idx+1] = argv[optionId];\n                        isXcpOption = true;\n                        break;\n                    }\n                }\n\n                if (isXcpOption) {\n                    /* Mark arguments as \"processed\" */\n                    argv[optionId - 1] = NULL;\n                    argv[optionId] = NULL;\n                }\n                \n                optionId++;\n            }\n        }\n    }\n#endif\n}\n\nvoid xcpTransportGetInitParameters(int_T *parNumber, void **parList[])\n{\n#ifdef  EXTMODE_DISABLE_ARGS_PROCESSING\n    if ((parNumber != NULL) && (parList != NULL)) {\n        /* No Transport Layer parameters defined (assuming rtiostream default) */\n        *parNumber = 0;\n        *parList = NULL;\n    }\n#else    \n    if ((parNumber != NULL) && (parList != NULL)) {\n        *parNumber = XCP_ELEMENTS_NUMBER(xcpTransportLayerParams);\n        *parList = (void **) &xcpTransportLayerParams;\n    }\n#endif\n}\n\nvoid xcpGetInitParameters(int_T *parNumber, void **parList[])\n{\n    if ((parNumber != NULL) && (parList != NULL)) {\n        /* No Protocol Layer parameters available at the moment */\n        *parNumber = 0;\n        *parList = NULL;\n    }\n}\n\n\n"},{"name":"xcp_fifo.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2025b/toolbox/coder/xcp/src/target/server/transport/src","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2020 The MathWorks, Inc.\n*\n* File: xcp_fifo.c\n*\n* Abstract:\n*  Implementation of FIFO data structure based on single linked list\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp_fifo.h\"\n\n\nvoid xcpFifoInit(struct xcpFifo * fifo)\n{\n    fifo->first = NULL;\n    fifo->last = &(fifo)->first;\n}\n\n\nvoid xcpFifoEnqueue(struct xcpFifo *fifo, struct xcpFifoEntry *element)\n{\n    element->next = NULL;\n    *(fifo)->last = element;\n    fifo->last = &(element->next);\n}\n\n\nvoid xcpFifoDequeue(struct xcpFifo *fifo, struct xcpFifoEntry **element)\n{\n    *element = fifo->first;\n\n    if (fifo->first != NULL) {\n        fifo->first = fifo->first->next;\n\n        if (fifo->first == NULL)\n            fifo->last = &(fifo)->first;\n    }\n}\n\n\nvoid xcpFifoEnqueueHead(struct xcpFifo *fifo, struct xcpFifoEntry *element)\n{\n    element->next = (fifo)->first;\n\n    if ((fifo)->first == NULL) {\n        (fifo)->last = &(element->next);\n    }\n\n    (fifo)->first = element;\n}\n\n\nvoid xcpFifoSpliceHead(struct xcpFifo *dstFifo, struct xcpFifo *srcFifo)\n{\n    if (srcFifo->first != NULL) {\n        *(srcFifo->last) = dstFifo->first;\n        dstFifo->first = srcFifo->first;\n         \n        srcFifo->first = NULL;\n        srcFifo->last = &(srcFifo)->first;\n    }\n}\n\n\nboolean_T xcpFifoEmpty(struct xcpFifo *fifo)\n{\n    return ((fifo)->first == NULL);\n}\n\n\nvoid xcpFifoReset(struct xcpFifo * fifo)\n{\n    xcpFifoInit(fifo);\n}\n"},{"name":"xcp_frame_serial.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2025b/toolbox/coder/xcp/src/target/server/transport/src","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2024 The MathWorks, Inc.\n*\n* File: xcp_frame_serial.c\n*\n* Abstract:\n*  XCP Frame Handler implementation for the Serial transport layer.\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp.h\"\n#include \"xcp_frame.h\"\n#include \"xcp_frame_serial.h\"\n#include \"xcp_drv.h\"\n#include \"xcp_mem.h\"\n#include \"xcp_types.h\"\n\n\n/* Frame Handler internal counters */\n#if XCP_SERIAL_USES_CTR\nstatic uintCTR_T txCounter = 0;\nstatic uintCTR_T rxCounter = 0;\nstatic int       firstRxCounterReceived = 0;\n#endif\n\n/* true if the Frame Handler has been successfully initialized */\nstatic boolean_T initialized = false;\n\n/* ID for of the memory pool reserved for the allocation of\n    CTO XCP Packets */\nstatic xcpPoolId_T xcpCtoReservedMemPoolId = -1;\n\n\nuint16_T xcpSxiHtons(uint16_T hostShort)\n{\n#ifndef XCP_BIG_ENDIAN\n    return hostShort;\n#else\n    return ((hostShort & 0xFF00) >> 8) | ((hostShort & 0x00FF) << 8);\n#endif\n}\n\n\nuint16_T xcpSxiNtohs(uint16_T networkShort)\n{\n    return xcpSxiHtons(networkShort);\n}\n\n#if XCP_SERIAL_USES_CS\n /*\n  * Checksum is calculated for all octets in a target memory location.\n  * length : number of target memory locations.\n  */\n#if XCP_ADDRESS_GRANULARITY == XCP_ADDRESS_GRANULARITY_BYTE\n    uintCS_T xcpSxiChecksum(const void *buffer, uintLEN_T length){\n        const uint8_T *buf = buffer;\n        uintCS_T checkSum = 0;\n        while (length-- > 0) {\n            /* buf is a uint8_T* so endian transformation is not required. */\n            checkSum += *buf++;\n        }\n        return checkSum;\n    }\n#elif XCP_ADDRESS_GRANULARITY == XCP_ADDRESS_GRANULARITY_WORD\n    uintCS_T xcpSxiChecksum(const void *buffer, uintLEN_T length){\n        const uint16_T *buf = buffer;\n        uintCS_T checkSum = 0;\n        while (length-- > 0){\n            checkSum += *buf & 0x00FF;\n            checkSum += (*buf++) >> 8;\n        }\n        return checkSum;\n    }\n#endif\n\n#endif\n\nXcpErrorCode xcpFrameInit(\n    int   argc,   /**< [in] number of init parameters              */\n    void *argv[]  /**< [in] array of parameters values (C strings) */\n    )\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    XCP_ERROR_IF(initialized, XCP_ERROR, \"xcpFrameInit: frame handler already initialized\\n\");\n\n    /* Open the XCP driver */\n    errorCode = xcpDrvOpen(argc, argv);\n    if (errorCode == XCP_SUCCESS) {\n#if XCP_SERIAL_USES_CTR\n        txCounter = 0;\n        rxCounter = 0;\n        firstRxCounterReceived = 0;\n#endif\n        initialized = true;\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpFrameMsgSend(\n    void    *msgBuffer,  /**< [in] pointer to the base address of the buffer where the message is stored */\n    size_t   msgOffset,  /**< [in] offset (from base address in AG units) where the XCP message frame is stored */\n    size_t   msgSize     /**< [in] size (in AG units) of XCP message frame */\n    )\n{\n    /* This function works properly only if the XCP_SERIAL_HEADER_FORMAT is LEN_WORD_CTR_WORD and\n     * XCP_SERIAL_TAIL_FORMAT is CHECKSUM_WORD.\n     */\n    uint8_T *bufferPtr = NULL;\n    struct XcpHeader *header = NULL;\n    uintLEN_T lengthInBytes = 0;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n#if XCP_SERIAL_USES_CS\n    uintCS_T checksum;\n    char *tail = NULL;\n#endif\n\n    XCP_ERROR_IF(msgBuffer == NULL, XCP_INV_ARG, \"xcpFrameMsgSend: invalid msgBuffer\\n\");\n    XCP_ERROR_IF(msgSize < sizeof(struct XcpHeader) + XCP_IN_AG(XCP_SERIAL_TAIL_SIZE), XCP_INV_ARG, \"xcpFrameMsgSend: invalid msgSize\\n\");\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpFrameMsgSend: frame handler not initialized\\n\");\n\n    bufferPtr = (uint8_T *) msgBuffer + msgOffset;\n\n    header = (struct XcpHeader *) bufferPtr;\n    lengthInBytes = LenSxiNtoH(header->length);\n\n    if ( ( lengthInBytes == 0 ) ||\n         ( msgSize < ( sizeof(struct XcpHeader) + XCP_IN_AG(XCP_SERIAL_TAIL_SIZE) + XCP_IN_AG(lengthInBytes) ) )\n       ) {\n        XCP_PRINTF(\"xcpFrameMsgSend: invalid message format detected\\n\");\n        return XCP_INV_MSG_FORMAT;\n    }\n\n#if XCP_SERIAL_USES_CTR\n    /* Set the value of the transport layer txCounter immediately before\n     * sending the message so that it reflects the correct order for the\n     * sequence of frames that are sent rather than the sequence in which\n     * they are constructed (which could be different in the case where\n     * there are multiple prioritized queues). */\n    header->counter = CtrSxiHtoN(txCounter);\n#endif\n\n#if XCP_SERIAL_USES_CS\n    /* Using char* instead of XcpTail* (for tail) prevents compilers from\n     * generating multi-BYTE non-aligned load instructions for XCP_MEMCPY.\n     */\n    tail = (char *) header + sizeof(struct XcpHeader) + XCP_IN_AG(lengthInBytes);\n    checksum = CsSxiHtoN(xcpSxiChecksum(header, sizeof(struct XcpHeader) + XCP_IN_AG(lengthInBytes)));\n    XCP_MEMCPY(tail, &checksum, sizeof(uintCS_T));\n#endif\n\n    /* Send the XCP Frame Header\n     * If the xcpDrvSend() is blocking, the return code should be XCP_SUCCESS\n     * If the xcpDrvSend() is non-blocking, the return code could be XCP_SUCCESS or XCP_BUSY.\n     * If something went wrong we should get XCP_ERROR or XCP_PKT_TX_TIMEOUT_ERROR */\n    errorCode = xcpDrvSend(bufferPtr, XCP_SERIAL_HEADER_SIZE);\n    if(errorCode != XCP_SUCCESS){\n        return errorCode;\n    }\n    bufferPtr += XCP_IN_AG(XCP_SERIAL_HEADER_SIZE);\n\n    /* Since have already started sending the packet, we should wait until\n     * the remaining part is sent, or a XCP_PKT_TX_TIMEOUT_ERROR has occurred.\n     * For this reason we force the subsequent xcpDrvRecv to be blocking */\n    xcpDrvIoctl(XCP_DRV_FORCE_BLOCKING);\n\n    /* Send the XCP Packet */\n    errorCode = xcpDrvSend(bufferPtr, lengthInBytes);\n    if(errorCode != XCP_SUCCESS){\n        goto txError;\n    }\n    bufferPtr += XCP_IN_AG(lengthInBytes);\n\n    /* Send the XCP Frame Tail */\n    errorCode = xcpDrvSend(bufferPtr, XCP_SERIAL_TAIL_SIZE);\n    if (errorCode != XCP_SUCCESS){\n        goto txError;\n    }\n\n    /* If successfully sent, the buffer can be freed */\n    if (errorCode == XCP_SUCCESS) {\n        xcpMemFree(msgBuffer);\n    }\n\n#if XCP_SERIAL_USES_CTR\n    /* Don't increment the counter if the transfer of the packet is delayed\n       due to the transport layer being busy. */\n    if (errorCode != XCP_BUSY) {\n        txCounter++;\n    }\n#endif\n\ntxError:\n    /* The packet has been sent, or an error occurred. In any case\n     * we can restore the default blocking/non-blocking behavior */\n    xcpDrvIoctl(XCP_DRV_RESTORE_DEFAULT_BLOCKING_SETUP);\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpFrameMsgRecv(\n    void  **msgBuffer,  /**< [out] pointer to the base address of the buffer where the message is stored */\n    size_t  msgOffset,  /**< [in] offset (from base address in AG units) where the XCP message frame is stored */\n    size_t *msgSize     /**< [out] size (in AG units) of the XCP message frame that has been received */\n    )\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    struct XcpHeader rxHeader;\n    uintLEN_T lengthInBytes = 0;\n    uint8_T *buffer;\n    uint8_T *bufferPtr;\n\n    XCP_ERROR_IF(msgBuffer == NULL, XCP_INV_ARG, \"xcpFrameMsgRecv: invalid msgBuffer pointer\\n\");\n    XCP_ERROR_IF(msgSize == NULL, XCP_INV_ARG, \"xcpFrameMsgRecv: invalid msgSize pointer\\n\");\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpFrameMsgRecv: frame handler not initialized\\n\");\n\n    /* Receive message header first.\n     * If the xcpDrvRecv() is blocking, the return code should be XCP_SUCCESS\n     * If the xcpDrvRecv() is non-blocking, the return code could be XCP_SUCCESS or XCP_EMPTY\n     * If something went wrong we should get XCP_ERROR or XCP_PKT_RX_TIMEOUT_ERROR */\n    errorCode = xcpDrvRecv(&rxHeader, XCP_SERIAL_HEADER_SIZE);\n    if (errorCode != XCP_SUCCESS) {\n        return errorCode;\n    }\n\n    /* Infer the number of BYTES in the XCP Packet from the received header.\n     * This may not be a multiple of XCP_ADDRESS_GRANULARITY */\n    lengthInBytes = LenSxiNtoH(rxHeader.length);\n    if (lengthInBytes == 0) {\n        XCP_PRINTF(\"xcpFrameMsgRecv: invalid message format detected\\n\");\n        errorCode = XCP_INV_MSG_FORMAT;\n        return errorCode;\n    }\n\n    /* Request to the XCP allocator the memory for the message to be received.\n     * STIM packets are not supported at the moment. For this reason\n     * the XCP Server can only receive CTOs */\n    buffer = xcpMemAllocFromPool(xcpCtoReservedMemPoolId,\n                msgOffset\n                + XCP_IN_AG(XCP_SERIAL_HEADER_SIZE)\n                + XCP_IN_AG(lengthInBytes)\n                + XCP_IN_AG(XCP_SERIAL_TAIL_SIZE) );\n\n    if (buffer == NULL) {\n        errorCode = XCP_NO_MEMORY;\n        return errorCode;\n    }\n\n    bufferPtr = buffer;\n\n    /* Initialize the header part */\n    XCP_MEMSET(bufferPtr, 0, msgOffset);\n    bufferPtr += msgOffset;\n\n    XCP_MEMCPY(bufferPtr, &rxHeader, sizeof(rxHeader));\n    bufferPtr += sizeof(rxHeader);\n\n    /* Since have already started receiving the packet, we should wait until\n     * the remaining part is received, or a XCP_PKT_RX_TIMEOUT_ERROR has occurred.\n     * For this reason we force the subsequent xcpDrvRecv to be blocking */\n    xcpDrvIoctl(XCP_DRV_FORCE_BLOCKING);\n\n    /* Receive the XCP packet */\n    errorCode = xcpDrvRecv(bufferPtr, lengthInBytes);\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpFrameMsgRecv: received XCP header, but XCP packet is not available or packet size is incorrect\\n\");\n        errorCode = XCP_INV_MSG_FORMAT;\n        goto rxError;\n    }\n\n    bufferPtr  += XCP_IN_AG(lengthInBytes);\n\n    /* Receive the XCP packet */\n    errorCode = xcpDrvRecv(bufferPtr, XCP_SERIAL_TAIL_SIZE);\n\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpFrameMsgRecv: received XCP header and XCP packet, but XCP tail is not available or packet size is incorrect\\n\");\n        errorCode = XCP_INV_MSG_FORMAT;\n        goto rxError;\n    }\n\n    /* The packet has been received, so we can restore\n     * the default blocking/non-blocking behavior */\n    xcpDrvIoctl(XCP_DRV_RESTORE_DEFAULT_BLOCKING_SETUP);\n\n    *msgBuffer = buffer;\n    *msgSize = sizeof(rxHeader) + XCP_IN_AG(lengthInBytes) + XCP_IN_AG(XCP_SERIAL_TAIL_SIZE);\n\n    return errorCode;\n\nrxError:\n    /* An error occurred while receiving a packet, so we can restore\n     * the default blocking/non-blocking behavior */\n    xcpDrvIoctl(XCP_DRV_RESTORE_DEFAULT_BLOCKING_SETUP);\n\n    *msgBuffer = NULL;\n    *msgSize = 0;\n    xcpMemFree(buffer);\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpFrameCreateMsg(\n    void        *msgFrame,           /**< [out] pointer to the buffer containing the full message frame */\n    size_t       msgFrameBufferSize, /**< [in]  max size (in AG units) of the buffer where the message frame is copied */\n    size_t      *msgFrameSize,       /**< [out] size (in AG units) of the generated msg frame */\n    size_t       xcpPacketSize       /**< [in]  size (in BYTEs) of the XCP packet. */\n    )\n{\n    struct XcpHeader *header = (struct XcpHeader *) msgFrame;\n\n    /* Input parameters validation */\n    XCP_ERROR_IF(msgFrame == NULL, XCP_INV_ARG, \"xcpFrameCreateMsg: invalid msgFrame buffer\\n\");\n    XCP_ERROR_IF(msgFrameSize == NULL, XCP_INV_ARG, \"xcpFrameCreateMsg: invalid msgFrameSize pointer\\n\");\n    XCP_ERROR_IF(xcpPacketSize == 0, XCP_INV_ARG, \"xcpFrameCreateMsg: invalid xcpPacketSize\\n\");\n    XCP_ERROR_IF(msgFrameBufferSize < (XCP_IN_AG(xcpPacketSize) + sizeof(struct XcpHeader) + XCP_IN_AG(XCP_SERIAL_TAIL_SIZE)), XCP_INV_ARG, \"xcpFrameCreateMsg: invalid msgFrameBufferSize\\n\");\n\n    /* update XCP header */\n    /* header->length = number of BYTES in the XCP Packet */\n    header->length = LenSxiHtoN((uint16_T)xcpPacketSize);\n\n    *msgFrameSize = XCP_IN_AG(xcpPacketSize) + sizeof(struct XcpHeader) + XCP_IN_AG(XCP_SERIAL_TAIL_SIZE);\n\n    return XCP_SUCCESS;\n}\n\n\nXcpErrorCode xcpFrameExtractPacket(\n    const void  *msgFrame,      /**< [in]  pointer to the buffer containing full message frame content */\n    size_t       msgFrameSize,  /**< [in]  size (in AG units) of the full message frame */\n    size_t      *xcpPacketSize  /**< [out] size (in BYTEs) of the XCP packet that has been processed */\n    )\n{\n    const struct XcpHeader *header = (const struct XcpHeader *) msgFrame;\n    uintLEN_T length = 0;\n#if XCP_SERIAL_USES_CTR\n    uintCTR_T counter = 0;\n#endif\n#if XCP_SERIAL_USES_CS\n    const char *tail = NULL;\n    uintCS_T checksum = 0;\n#endif\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    /* Input parameters validation */\n    XCP_ERROR_IF(msgFrame == NULL, XCP_INV_ARG, \"xcpFrameExtractPacket: invalid msgFrame\\n\");\n    XCP_ERROR_IF(xcpPacketSize == NULL, XCP_INV_ARG, \"xcpFrameExtractPacket: invalid xcpPacketSize pointer\\n\");\n    XCP_ERROR_IF(msgFrameSize <= sizeof(struct XcpHeader), XCP_INV_ARG, \"xcpFrameExtractPacket: invalid msgFrameSize\\n\");\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpFrameExtractPacket: frame handler not initialized\\n\");\n\n    /* Extract info from the received message */\n    length = LenSxiNtoH(header->length);\n#if XCP_SERIAL_USES_CTR\n    counter = CtrSxiNtoH(header->counter);\n#endif\n\n    /* Check message length */\n    if (msgFrameSize != (XCP_IN_AG(length) + XCP_IN_AG(XCP_SERIAL_HEADER_SIZE) + XCP_IN_AG(XCP_SERIAL_TAIL_SIZE))) {\n        XCP_PRINTF(\"xcpFrameExtractPacket: Xcp packet has an invalid size\\n\");\n        return XCP_INV_MSG_FORMAT;\n    }\n\n#if XCP_SERIAL_USES_CTR\n    /* Check message counter */\n    if (!firstRxCounterReceived) {\n        /* No checks can be carried out the first time */\n        firstRxCounterReceived = 1;\n    }\n    else {\n        if (counter < (rxCounter + 1)) {\n            errorCode = XCP_PKT_OUT_OF_SEQUENCE;\n        }\n        else if (counter >(rxCounter + 1)) {\n            errorCode = XCP_PKT_LOST;\n        }\n    }\n    rxCounter = counter;\n#endif\n\n    /* Verify the checksum */\n#if XCP_SERIAL_USES_CS\n    /* Using char* instead of XcpTail* (for tail) prevents compilers from\n     * generating multi-BYTE non-aligned load instructions for XCP_MEMCPY.\n     */\n    tail = (const char *) msgFrame + sizeof(struct XcpHeader) + XCP_IN_AG(length);\n    XCP_MEMCPY(&checksum, tail, sizeof(checksum));\n    checksum = CsSxiNtoH(checksum);\n    XCP_ERROR_IF(checksum != xcpSxiChecksum(header, sizeof(struct XcpHeader) + XCP_IN_AG(length)), XCP_PKT_CHECKSUM_ERROR, \"xcpFrameExtractPacket: invalid checksum\\n\");\n#endif\n    *xcpPacketSize = length;\n\n    return errorCode;\n}\n\n/* Returns the number of BYTEs in an XCP Frame Header */\nsize_t xcpFrameHeaderSize(void)\n{\n    return XCP_SERIAL_HEADER_SIZE;\n}\n\n/* Returns the number of BYTEs in an XCP Tail */\nsize_t xcpFrameTailSize(void)\n{\n    return XCP_SERIAL_TAIL_SIZE;\n}\n\n\nsize_t xcpFrameMaxDtoSize(void)\n{\n    return XCP_MAX_DTO_SIZE;\n}\n\n\nsize_t xcpFrameMaxCtoSize(void)\n{\n    return XCP_MAX_CTO_SIZE;\n}\n\n\nXcpErrorCode xcpFrameRestart(void)\n{\n#if XCP_SERIAL_USES_CTR\n    txCounter = 0;\n    rxCounter = 0;\n    firstRxCounterReceived = 0;\n#endif\n\n    return XCP_SUCCESS;\n}\n\n\nvoid xcpFrameSetCtoReservedMemPoolId(xcpPoolId_T poolId)\n{\n    xcpCtoReservedMemPoolId = poolId;\n}\n\n\nXcpErrorCode xcpFrameReset(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    if (!initialized) {\n        XCP_PRINTF(\"xcpFrameReset: frame handler already reset\\n\");\n        return XCP_SUCCESS; /* Nothing to do: just printing out a warning message*/\n    }\n\n    /* Close the actual communication channel */\n    errorCode = xcpDrvClose();\n    if (errorCode == XCP_SUCCESS) {\n#if XCP_SERIAL_USES_CTR\n        txCounter = 0;\n        rxCounter = 0;\n        firstRxCounterReceived = 0;\n#endif\n        initialized = false;\n    } else {\n        XCP_PRINTF(\"xcpFrameReset: xcpDrvClose error\\n\");\n    }\n\n    return errorCode;\n}\n"},{"name":"xcp_mem_default.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2025b/toolbox/coder/xcp/src/target/server/platform/default","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2023 The MathWorks, Inc.\n*\n* File: xcp_mem_default.c\n*\n* Abstract:\n*  Implementation of default XCP Server memory allocator\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp_mem.h\"\n#include \"xcp_mem_default.h\"\n#include \"xcp_utils.h\"\n\n#define PADDING (XCP_MEM_ALIGNMENT-1)\n\n/* Array of XcpMemPoolDescriptor for each block size to allow freeing and\n   allocating blocks.\n\n   @note this includes both the Main Memory area and the Reserved Pools\n         Memory Area */\nstatic XcpMemPoolDescriptor xcpMemPoolDescriptors[XCP_MEM_MAIN_RESERVED_POOL_NUMBER];\n\n/* xcpMemCustomPoolDescriptor stores the custom memory functions to allocate and\n   free memory for a specific memory pool */\nstatic XcpMemCustomPoolDescriptor xcpMemCustomPoolDescriptors[XCP_MEM_CUSTOM_POOL_MAX_NUMBER];\n\n\n/* Main memory chunk from which blocks are allocated using the xcpMemAlloc\n * This may not be aligned to XCP_MEM_ALIGNMENT depending on the compiler \n * and/or build flags.\n * Add padding bytes to the end to enable aligning blocks in xcpMemMainChunk\n * to aligned addresses if needed.\n */\nXCP_MEM_DATA_SECTION_BEGIN\nstatic uint8_T xcpMemMainChunk[XCP_MEM_MAIN_TOTAL_SIZE + PADDING];\nXCP_MEM_DATA_SECTION_END\n\n\n/* Reserved pools memory chunk from which pool blocks are allocated using the\n * xcpMemAllocFromPool()\n * Also refer to comments in xcpMemMainChunk\n */\nXCP_MEM_DATA_SECTION_BEGIN\nstatic uint8_T xcpMemReservedPoolsChunk[XCP_MEM_RESERVED_POOLS_TOTAL_SIZE + PADDING];\nXCP_MEM_DATA_SECTION_END\n\nstatic size_t  xcpMemReservedPoolsChunkUsedBytes;\n\n/* Mutex to prevent concurrent access to xcpMemPoolDescriptors, xcpMemMainChunk\n   and xcpMemReservedPoolsChunk\n   @note: the insertion/removal of blocks within each reserved pool is protected by a dedicated\n          lock, to reduce the interference between threads in multi-core applications */\nstatic XCP_MUTEX_DEFINE(xcpMemLock);\n\n\n/* Initialize pool's memory chunk, by creating the pool's memory blocks and as a linked list */\nstatic void xcpInitializePoolMemoryArea(uint8_T *memoryPtr, size_t blockSize, size_t blocksNumber)\n{\n    if (memoryPtr != NULL) {\n        XcpMemHeader *p, *prev = NULL;\n        size_t i;\n        /* Initialize memory to zero */\n        size_t totSize = XCP_MEM_BLOCK_SIZE_WITH_OVERHEAD(blockSize) * blocksNumber;\n        XCP_MEMSET(memoryPtr,  0, totSize);\n\n        for(i = 0 ; i < blocksNumber; ++i) {\n            p = (XcpMemHeader*) memoryPtr;\n            p -> next = NULL;\n            p -> poolId = XCP_FREE_POOL_ID;\n            if (prev) {\n                prev -> next = p;\n            }\n            memoryPtr += XCP_MEM_BLOCK_SIZE_WITH_OVERHEAD(blockSize);\n            prev = p;\n        }\n    }\n}\n\nXcpErrorCode xcpMemInit(void)\n{\n    uint8_T poolIdx;\n    uint8_T *memoryPtr = (uint8_T *)XCP_ALIGNED(xcpMemMainChunk);\n\n    XCP_MUTEX_INIT(xcpMemLock);\n\n\n#ifndef XCP_NO_MAIN_MEM_ALLOCATED\n    /* Sort main memory block */\n    xcpSortArray(xcpMemMainBlockSizes, xcpMemMainBlocksNumber, (size_t)XCP_MEM_MAIN_POOLS_NUMBER);\n\n    /* Initialize Main memory */\n    for(poolIdx = 0; poolIdx < XCP_MEM_MAIN_POOLS_NUMBER; ++poolIdx) {\n        size_t blocksCount = xcpMemMainBlocksNumber[poolIdx];\n        size_t blockSize = xcpMemMainBlockSizes[poolIdx];\n\n        xcpMemPoolDescriptors[poolIdx].head = (XcpMemHeader*) memoryPtr;\n        xcpMemPoolDescriptors[poolIdx].totalBlocksCount = blocksCount;\n        xcpMemPoolDescriptors[poolIdx].freeBlocksCount = blocksCount;\n        xcpMemPoolDescriptors[poolIdx].blockSize = blockSize;\n        xcpMemPoolDescriptors[poolIdx].poolSize =\n            blocksCount * XCP_MEM_BLOCK_SIZE_WITH_OVERHEAD(blockSize);\n#ifdef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n        xcpMemPoolDescriptors[poolIdx].deferredFreeHead = NULL;\n        xcpMemPoolDescriptors[poolIdx].deferredFreeTail = NULL;\n        xcpMemPoolDescriptors[poolIdx].deferredFreeBlocksCount = 0;\n#else\n        XCP_MUTEX_INIT(xcpMemPoolDescriptors[poolIdx].lock);\n#endif\n\n        xcpInitializePoolMemoryArea(memoryPtr, blockSize, blocksCount);\n        memoryPtr += xcpMemPoolDescriptors[poolIdx].poolSize;\n    }\n#else\n    (void)memoryPtr;\n#endif\n\n    /* Initialize Reserved pools memory\n       @note since the allocation of the memory pools is dynamic,\n             the creation of the blocks for each pool is deferred\n             and carried out within the xcpMemReservedPoolCreate() */\n    XCP_MEMSET(xcpMemReservedPoolsChunk, 0, sizeof(xcpMemReservedPoolsChunk));\n    xcpMemReservedPoolsChunkUsedBytes = 0;\n\n    for(poolIdx = XCP_MEM_MAIN_POOLS_NUMBER; poolIdx < XCP_MEM_MAIN_RESERVED_POOL_NUMBER; ++poolIdx) {\n        xcpMemPoolDescriptors[poolIdx].head = XCP_FREE_POOL;\n        xcpMemPoolDescriptors[poolIdx].totalBlocksCount = 0;\n        xcpMemPoolDescriptors[poolIdx].freeBlocksCount = 0;\n        xcpMemPoolDescriptors[poolIdx].blockSize = 0;\n        xcpMemPoolDescriptors[poolIdx].poolSize = 0;\n#ifdef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n        xcpMemPoolDescriptors[poolIdx].deferredFreeHead = NULL;\n        xcpMemPoolDescriptors[poolIdx].deferredFreeTail = NULL;\n        xcpMemPoolDescriptors[poolIdx].deferredFreeBlocksCount = 0;\n#else\n        XCP_MUTEX_INIT(xcpMemPoolDescriptors[poolIdx].lock);\n#endif\n    }\n\n    for(poolIdx = 0; poolIdx < XCP_MEM_CUSTOM_POOL_MAX_NUMBER; poolIdx++) {\n        xcpMemCustomPoolDescriptors[poolIdx].allocHandler = NULL;\n        xcpMemCustomPoolDescriptors[poolIdx].freeHandler = NULL;\n    }\n\n    return XCP_SUCCESS;\n}\n\n\nvoid* xcpMemAlloc(size_t size)\n{\n\n#ifndef XCP_NO_MAIN_MEM_ALLOCATED\n\n    uint8_T poolIdx;\n    size_t blockSize = 0;\n    XcpMemHeader *poolHead = NULL;\n\n    /* a size of 0 is considered an invalid argument */\n    if (size == 0) {\n        return NULL;\n    }\n\n    XCP_MUTEX_LOCK(xcpMemLock);\n\n    /* find the first large enough pool */\n    for(poolIdx = 0; poolIdx <  XCP_MEM_MAIN_POOLS_NUMBER; ++poolIdx) {\n        blockSize = xcpMemMainBlockSizes[poolIdx];\n        if ((size <= blockSize) && (xcpMemPoolDescriptors[poolIdx].freeBlocksCount > 0)) {\n            poolHead = xcpMemPoolDescriptors[poolIdx].head;\n            break;\n        }\n    }\n\n    if (!poolHead) { /* size is too large, or there are no more free blocks */\n       XCP_MUTEX_UNLOCK(xcpMemLock);\n       return NULL;\n    }\n\n    xcpMemPoolDescriptors[poolIdx].head = poolHead->next;\n    (xcpMemPoolDescriptors[poolIdx].freeBlocksCount)--;\n    poolHead->poolId = poolIdx;\n\n    XCP_MUTEX_UNLOCK(xcpMemLock);\n\n    /* return a pointer past just the poolId */\n    return ((uint8_T*) poolHead) + XCP_MEM_POOLID_SIZE;\n\n#else\n\n    (void)size;\n    return NULL;\n\n#endif\n\n}\n\n\nvoid xcpMemFree(void *ptr)\n{\n    if (ptr) {\n        /* the XcpMemHeader cell is 'behind' the user's pointer */\n        XcpMemHeader *hd = (XcpMemHeader*) ((uint8_T*)ptr - XCP_MEM_POOLID_SIZE);\n        uint8_T poolIdx = hd -> poolId;\n\n        if (poolIdx >= XCP_MEM_CUSTOM_POOLS_OFFSET && poolIdx < XCP_MEM_CUSTOM_POOLS_UPPER_BOUND) {\n            poolIdx = poolIdx - XCP_MEM_CUSTOM_POOLS_OFFSET;\n            if (xcpMemCustomPoolDescriptors[poolIdx].freeHandler) {\n                /* For custom memory pools, protection against concurrent\n                   exclusion must be guaranteed within the custom free method */\n                xcpMemCustomPoolDescriptors[poolIdx].freeHandler((uint8_T*)ptr - XCP_MEM_POOLID_SIZE);\n            }\n            return;\n        }\n\n        if ((poolIdx == XCP_FREE_POOL_ID) || (poolIdx >= XCP_MEM_MAIN_RESERVED_POOL_NUMBER)){\n            /* ill-formed block or already freed pointer */\n            XCP_PRINTF(\"xcpMemFree: invalid or double-freed pointer %p\\n\", ptr);\n            return;\n        }\n\n#ifndef XCP_NO_MAIN_MEM_ALLOCATED\n        /* insert the new free block in the front of the pool */\n        if (poolIdx < XCP_MEM_MAIN_POOLS_NUMBER) {\n            XCP_MUTEX_LOCK(xcpMemLock);\n\n            hd -> poolId = XCP_FREE_POOL_ID;\n            hd -> next = xcpMemPoolDescriptors[poolIdx].head;\n\n            xcpMemPoolDescriptors[poolIdx].head = hd;\n            ++(xcpMemPoolDescriptors[poolIdx].freeBlocksCount);\n\n            XCP_MUTEX_UNLOCK(xcpMemLock);\n        }\n        else\n#endif\n        {\n        #ifdef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n            /* If lockless support is enabled, the freed memory block is\n               not immediately available for subsequent allocations,\n               until xcpMemReservedPoolFlushFreeMem is invoked */\n            hd -> poolId = XCP_FREE_POOL_ID;\n            hd -> next = xcpMemPoolDescriptors[poolIdx].deferredFreeHead;\n\n            if (xcpMemPoolDescriptors[poolIdx].deferredFreeTail == NULL) {\n                /* Let's save a reference to the first block in the pool\n                   that has been freed */\n                xcpMemPoolDescriptors[poolIdx].deferredFreeTail = hd;\n            }\n\n            xcpMemPoolDescriptors[poolIdx].deferredFreeHead = hd;\n            ++(xcpMemPoolDescriptors[poolIdx].deferredFreeBlocksCount);\n        #else\n            XCP_MUTEX_LOCK(xcpMemPoolDescriptors[poolIdx].lock);\n\n            hd -> poolId = XCP_FREE_POOL_ID;\n            hd -> next = xcpMemPoolDescriptors[poolIdx].head;\n\n            xcpMemPoolDescriptors[poolIdx].head = hd;\n            ++(xcpMemPoolDescriptors[poolIdx].freeBlocksCount);\n            XCP_MUTEX_UNLOCK(xcpMemPoolDescriptors[poolIdx].lock);\n        #endif\n        }\n    }\n}\n\n\nXcpErrorCode xcpMemReservedPoolCreate(size_t blockSize, size_t blocksNumber, xcpPoolId_T* poolId)\n{\n    uint8_T poolIdx;\n    uint8_T *currentHead = (uint8_T *) XCP_ALIGNED(xcpMemReservedPoolsChunk);\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    xcpPoolId_T pool = XCP_INVALID_POOL_ID;\n    size_t requestedPoolSize;\n\n    if ((poolId == NULL) || (blockSize == 0) || (blocksNumber == 0)) {\n        XCP_PRINTF(\"xcpMemReservedPoolCreate: invalid input parameter\\n\");\n        return XCP_INV_ARG;\n    }\n\n    /* blockSize needs to be a multiple of XCP_MEM_ALIGNMENT in order to align blocks to aligned addresses.\n     * If the size is not a multiple, adjustment is done here.\n     */\n    blockSize = (size_t) XCP_ALIGNED(blockSize);\n\n    requestedPoolSize = blocksNumber * XCP_MEM_BLOCK_SIZE_WITH_OVERHEAD(blockSize);\n\n    XCP_MUTEX_LOCK(xcpMemLock);\n\n    for(poolIdx = XCP_MEM_MAIN_POOLS_NUMBER; poolIdx < XCP_MEM_MAIN_RESERVED_POOL_NUMBER; ++poolIdx) {\n        if (xcpMemPoolDescriptors[poolIdx].head == XCP_FREE_POOL) {\n            /* The pool is free, let's check if it is big enough */\n            if ((xcpMemPoolDescriptors[poolIdx].poolSize) == 0) {\n                /* The pool has never been allocated before, so this must be the last\n                   usable pool in the list */\n                if (requestedPoolSize <= (XCP_MEM_RESERVED_POOLS_TOTAL_SIZE - xcpMemReservedPoolsChunkUsedBytes)) {\n                    /* It is big enough, so let's mark it as allocated */\n                    xcpMemPoolDescriptors[poolIdx].head = (XcpMemHeader*) currentHead;\n                    xcpMemPoolDescriptors[poolIdx].totalBlocksCount = blocksNumber;\n                    xcpMemPoolDescriptors[poolIdx].freeBlocksCount = blocksNumber;\n                    xcpMemPoolDescriptors[poolIdx].blockSize = blockSize;\n                    xcpMemPoolDescriptors[poolIdx].poolSize = requestedPoolSize;\n                #ifdef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n                    xcpMemPoolDescriptors[poolIdx].deferredFreeHead = NULL;\n                    xcpMemPoolDescriptors[poolIdx].deferredFreeTail = NULL;\n                    xcpMemPoolDescriptors[poolIdx].deferredFreeBlocksCount = 0;\n                #endif\n\n                    xcpInitializePoolMemoryArea(currentHead, blockSize, blocksNumber);\n                    xcpMemReservedPoolsChunkUsedBytes += requestedPoolSize;\n\n                    pool = poolIdx;\n                }\n                break; /* No more pools to process, exit from the loop */\n            } else {\n                /* The pool has already been allocated so it can't be re-sized */\n                if (requestedPoolSize <= xcpMemPoolDescriptors[poolIdx].poolSize) {\n                    /* It is big enough, so let's mark it as allocated */\n                    xcpMemPoolDescriptors[poolIdx].head = (XcpMemHeader*) currentHead;\n                    xcpMemPoolDescriptors[poolIdx].totalBlocksCount = blocksNumber;\n                    xcpMemPoolDescriptors[poolIdx].freeBlocksCount = blocksNumber;\n                    xcpMemPoolDescriptors[poolIdx].blockSize = blockSize;\n                #ifdef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n                    xcpMemPoolDescriptors[poolIdx].deferredFreeHead = NULL;\n                    xcpMemPoolDescriptors[poolIdx].deferredFreeTail = NULL;\n                    xcpMemPoolDescriptors[poolIdx].deferredFreeBlocksCount = 0;\n                #endif\n\n                    xcpInitializePoolMemoryArea(currentHead, blockSize, blocksNumber);\n                    pool = poolIdx;\n                    break; /* We found what we were looking for, exit from the loop */\n                }\n            }\n        }\n\n        /* Let's continue to see if there are bigger memory areas available */\n        currentHead += xcpMemPoolDescriptors[poolIdx].poolSize;\n    }\n\n    XCP_MUTEX_UNLOCK(xcpMemLock);\n\n    if (pool == XCP_INVALID_POOL_ID) {\n        errorCode = XCP_NO_MEMORY;\n    }\n\n    *poolId = pool;\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpMemReservedPoolDestroy(xcpPoolId_T poolId)\n{\n    uint8_T poolIdx;\n    boolean_T isLastPool = true;\n\n    if ((poolId < XCP_MEM_MAIN_POOLS_NUMBER) || (poolId >= XCP_MEM_MAIN_RESERVED_POOL_NUMBER)) {\n        XCP_PRINTF(\"xcpMemReservedPoolDestroy: invalid input parameter\\n\");\n        return XCP_INV_ARG;\n    }\n\n    XCP_MUTEX_LOCK(xcpMemLock);\n\n    /* Check if the pool is the last one (i.e. the used pool with the highest id) */\n    for(poolIdx = (XCP_MEM_MAIN_RESERVED_POOL_NUMBER - 1); poolIdx > poolId; --poolIdx) {\n        if ((xcpMemPoolDescriptors[poolIdx].head != XCP_FREE_POOL) ||\n            (xcpMemPoolDescriptors[poolIdx].poolSize != 0)) {\n            isLastPool = false;\n            break; /* the pool is not the last, exit from the loop */\n        }\n    }\n\n    xcpMemPoolDescriptors[poolId].head = XCP_FREE_POOL;\n    xcpMemPoolDescriptors[poolId].totalBlocksCount = 0;\n    xcpMemPoolDescriptors[poolId].freeBlocksCount = 0;\n    xcpMemPoolDescriptors[poolId].blockSize = 0;\n\n#ifdef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n    xcpMemPoolDescriptors[poolId].deferredFreeHead = NULL;\n    xcpMemPoolDescriptors[poolId].deferredFreeTail = NULL;\n    xcpMemPoolDescriptors[poolId].deferredFreeBlocksCount = 0;\n#endif\n\n    if (isLastPool) {\n        /* If it's the last pool we can de-allocate the memory, taking into account this pool\n           as well as the previous ones that have already been deallocated (out of order) */\n        for(poolIdx = XCP_MEM_MAIN_POOLS_NUMBER; poolIdx < XCP_MEM_MAIN_RESERVED_POOL_NUMBER; ++poolIdx) {\n            if ((xcpMemPoolDescriptors[poolIdx].head == XCP_FREE_POOL) &&\n                (xcpMemPoolDescriptors[poolIdx].poolSize != 0)) {\n                xcpMemReservedPoolsChunkUsedBytes -= xcpMemPoolDescriptors[poolIdx].poolSize;\n                xcpMemPoolDescriptors[poolIdx].poolSize = 0;\n            }\n        }\n    }\n\n    XCP_MUTEX_UNLOCK(xcpMemLock);\n\n    return XCP_SUCCESS;\n}\n\n\nXcpErrorCode xcpMemCustomPoolCreate(XcpCustomAllocHandler allocHandler, XcpCustomFreeHandler freeHandler, xcpPoolId_T* poolId)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    uint8_T poolIdx;\n\n    xcpPoolId_T pool = XCP_INVALID_POOL_ID;\n\n    if ((poolId == NULL) || (allocHandler == NULL) || (freeHandler == NULL)) {\n        XCP_PRINTF(\"xcpMemCustomPoolCreate: invalid input parameter\\n\");\n        return XCP_INV_ARG;\n    }\n\n    XCP_MUTEX_LOCK(xcpMemLock);\n\n    for (poolIdx = 0; poolIdx < XCP_MEM_CUSTOM_POOL_MAX_NUMBER; poolIdx++) {\n        if (xcpMemCustomPoolDescriptors[poolIdx].allocHandler == NULL && xcpMemCustomPoolDescriptors[poolIdx].freeHandler == NULL) {\n            pool = poolIdx + XCP_MEM_CUSTOM_POOLS_OFFSET;\n            xcpMemCustomPoolDescriptors[poolIdx].allocHandler = allocHandler;\n            xcpMemCustomPoolDescriptors[poolIdx].freeHandler = freeHandler;\n            break;\n        }\n    }\n\n    XCP_MUTEX_UNLOCK(xcpMemLock);\n\n    if (pool == XCP_INVALID_POOL_ID) {\n        errorCode = XCP_NO_MEMORY;\n    }\n\n    *poolId = pool;\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpMemCustomPoolDestroy(xcpPoolId_T poolId)\n{\n    if (poolId < XCP_MEM_CUSTOM_POOLS_OFFSET || poolId >= XCP_MEM_CUSTOM_POOLS_UPPER_BOUND) {\n        XCP_PRINTF(\"xcpMemCustomPoolDestroy: invalid poolId\\n\");\n        return XCP_INV_ARG;\n    }\n\n    XCP_MUTEX_LOCK(xcpMemLock);\n\n    xcpMemCustomPoolDescriptors[poolId - XCP_MEM_CUSTOM_POOLS_OFFSET].allocHandler = NULL;\n    xcpMemCustomPoolDescriptors[poolId - XCP_MEM_CUSTOM_POOLS_OFFSET].freeHandler = NULL;\n\n    XCP_MUTEX_UNLOCK(xcpMemLock);\n\n    return XCP_SUCCESS;\n}\n\n\nvoid* xcpMemAllocFromPool(xcpPoolId_T poolId, size_t size)\n{\n    XcpMemHeader *poolHead = NULL;\n\n    /* a size of 0 is considered an invalid argument */\n    if (size == 0) {\n        return NULL;\n    }\n\n    /* Check if memory allocation is delegated to a custom handler.\n       For custom memory pools, protection against concurrent execution must be\n       implemented withing the allocation method */\n    if (poolId >= XCP_MEM_CUSTOM_POOLS_OFFSET && poolId < XCP_MEM_CUSTOM_POOLS_UPPER_BOUND) {\n        if (xcpMemCustomPoolDescriptors[poolId - XCP_MEM_CUSTOM_POOLS_OFFSET].allocHandler) {\n            /* Memory must be added explicitly to store the pool ID */\n            poolHead = (XcpMemHeader *) xcpMemCustomPoolDescriptors[poolId - XCP_MEM_CUSTOM_POOLS_OFFSET].allocHandler(size + XCP_MEM_POOLID_SIZE);\n            if (!poolHead) {\n                return NULL;\n            }\n            poolHead->poolId = (uint8_T) poolId;\n            return ((uint8_T*) poolHead) + XCP_MEM_POOLID_SIZE;\n        }\n        return NULL;\n    }\n    \n    if ((poolId < XCP_MEM_MAIN_POOLS_NUMBER) || (poolId >= XCP_MEM_MAIN_RESERVED_POOL_NUMBER) ||\n        (xcpMemPoolDescriptors[poolId].head == XCP_FREE_POOL) ||\n        (xcpMemPoolDescriptors[poolId].blockSize < size)) {\n        /* No memory block of the given size is available from this pool */\n        return NULL;\n    }\n\n#ifndef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n    XCP_MUTEX_LOCK(xcpMemPoolDescriptors[poolId].lock);\n#endif\n\n    if (xcpMemPoolDescriptors[poolId].freeBlocksCount > 0) {\n        poolHead = xcpMemPoolDescriptors[poolId].head;\n    }\n\n    if (!poolHead){ /* there are no more free blocks */\n#ifndef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n       XCP_MUTEX_UNLOCK(xcpMemPoolDescriptors[poolId].lock);\n#endif\n       return NULL;\n    }\n\n    xcpMemPoolDescriptors[poolId].head = poolHead->next;\n    (xcpMemPoolDescriptors[poolId].freeBlocksCount)--;\n    poolHead->poolId = (uint8_T) poolId;\n\n#ifndef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n    XCP_MUTEX_UNLOCK(xcpMemPoolDescriptors[poolId].lock);\n#endif\n\n    /* return a pointer past just the poolId */\n    return ((uint8_T*) poolHead) + XCP_MEM_POOLID_SIZE;\n\n}\n\n\n#ifdef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\nvoid xcpMemReservedPoolFlushFreeMem(xcpPoolId_T poolId)\n{\n    if ((poolId >= XCP_MEM_MAIN_POOLS_NUMBER) &&\n        (poolId < XCP_MEM_MAIN_RESERVED_POOL_NUMBER) &&\n        (xcpMemPoolDescriptors[poolId].deferredFreeTail != NULL)) {\n        /* Let's move the deferred free blocks to the list of free blocks\n           available for subsequent allocations */\n        xcpMemPoolDescriptors[poolId].deferredFreeTail->next = xcpMemPoolDescriptors[poolId].head;\n        xcpMemPoolDescriptors[poolId].head = xcpMemPoolDescriptors[poolId].deferredFreeHead;\n        xcpMemPoolDescriptors[poolId].freeBlocksCount += xcpMemPoolDescriptors[poolId].deferredFreeBlocksCount;\n        xcpMemPoolDescriptors[poolId].deferredFreeBlocksCount = 0;\n        xcpMemPoolDescriptors[poolId].deferredFreeTail = NULL;\n    }\n}\n#endif\n\n\nXcpErrorCode xcpMemReset(void){\n    XCP_MEMSET(xcpMemMainChunk,          0, sizeof(xcpMemMainChunk));\n    XCP_MEMSET(xcpMemReservedPoolsChunk, 0, sizeof(xcpMemReservedPoolsChunk));\n    xcpMemReservedPoolsChunkUsedBytes = 0;\n\n    XCP_MEMSET(xcpMemPoolDescriptors,    0, sizeof(xcpMemPoolDescriptors));\n\n    XCP_MEMSET(xcpMemCustomPoolDescriptors, 0, sizeof(xcpMemCustomPoolDescriptors));\n\n    return XCP_SUCCESS;\n}\n\n#ifdef XCP_DEBUG_SUPPORT\n\nvoid xcpMemPrintDiagnostics(void)\n{\n    uint8_T poolIdx;\n    XCP_PRINTF(\"#############################\\n\");\n    XCP_PRINTF(\"             Header size: %7zu B\\n\", XCP_MEM_HEADER_SIZE);\n    XCP_PRINTF(\"             Offset size: %7zu B\\n\", XCP_MEM_POOLID_SIZE);\n    XCP_PRINTF(\"      Main System memory: %7zu B\\n\", XCP_MEM_MAIN_SYSTEM_SIZE);\n    XCP_PRINTF(\"        Main User memory: %7zu B\\n\", XCP_MEM_MAIN_USER_SIZE);\n    XCP_PRINTF(\"       Main Total memory: %7zu B\\n\", XCP_MEM_MAIN_TOTAL_SIZE);\n\n    for(poolIdx = 0 ; poolIdx < XCP_MEM_MAIN_POOLS_NUMBER ; ++poolIdx) {\n        size_t bsThisPool = xcpMemMainBlockSizes[poolIdx];\n        size_t nbBlocksThisPool = xcpMemPoolDescriptors[poolIdx].totalBlocksCount;\n        size_t nbFreeBlocksThisPool = xcpMemPoolDescriptors[poolIdx].freeBlocksCount;\n        XCP_PRINTF(\"%6zu B blocks: %4zu/%-4zu\\n\", bsThisPool, nbFreeBlocksThisPool, nbBlocksThisPool);\n    }\n    XCP_PRINTF(\"               (free)/(total)\\n\");\n    XCP_PRINTF(\"#############################\\n\");\n\n    XCP_PRINTF(\"        Res Pools Number: %7d   \\n\", XCP_MEM_RESERVED_POOLS_NUMBER);\n    XCP_PRINTF(\"  Res Pools Total memory: %7zu B\\n\", (size_t)XCP_MEM_RESERVED_POOLS_TOTAL_SIZE);\n    XCP_PRINTF(\"   Res Pools Used memory: %7zu B\\n\", xcpMemReservedPoolsChunkUsedBytes);\n\n    for(poolIdx = XCP_MEM_MAIN_POOLS_NUMBER ; poolIdx < XCP_MEM_MAIN_RESERVED_POOL_NUMBER ; ++poolIdx) {\n        size_t nbBlocksThisPool = xcpMemPoolDescriptors[poolIdx].totalBlocksCount;\n        size_t nbFreeBlocksThisPool = xcpMemPoolDescriptors[poolIdx].freeBlocksCount;\n        size_t sizeBlocksThisPool = xcpMemPoolDescriptors[poolIdx].blockSize;\n        XCP_PRINTF(\"Pool %3d blocks: %4zu/%-4zu of size %7zu\\n\", poolIdx, nbFreeBlocksThisPool, nbBlocksThisPool, sizeBlocksThisPool);\n    }\n    XCP_PRINTF(\"               (free)/(total)\\n\");\n}\n\n#endif\n\n#ifdef XCP_MEM_BYTE_COPY_SUPPORT\n/* xcpMemcpyByte() currently supports byte-wise copy on WORD (HW_AG=2) addressable targets only */\nvoid xcpMemcpyByte(void *pDst, uint8_T dstOffsetBytes, void const* pSrc, uint8_T srcOffsetBytes, size_t numOfBytes)\n{\n    uint16_T *dst = (uint16_T *)pDst;\n    uint16_T const* src = (uint16_T const*)pSrc;\n\n    if (numOfBytes >= 1) {\n        size_t numOfAGUnits = ((numOfBytes + 1) >> 1);\n        \n        if ((dstOffsetBytes == 0) && (srcOffsetBytes == 0)){\n            if (numOfBytes % 2){\n                numOfAGUnits--;\n                XCP_MEMCPY(dst, src, numOfAGUnits);\n                dst[numOfAGUnits] &= 0xff00;\n                dst[numOfAGUnits] |= (src[numOfAGUnits] & 0x00ff);\n            }\n            else {\n                XCP_MEMCPY(dst, src, numOfAGUnits);\n            }\n        }\n        else if ((dstOffsetBytes == 1) && (srcOffsetBytes == 0)){\n            uint32_T i = 0;\n            dst[0] &= 0x00ff;\n            dst[0] |= ((src[0] & 0x00ff) << 8);\n            for (i = 1; i < numOfAGUnits; i++){\n                dst[i]  = ((src[i-1] & 0xff00) >> 8);\n                dst[i] |= ((src[i] & 0x00ff) << 8);\n            }\n            if ((numOfBytes % 2) == 0){\n                dst[i] &= 0xff00;\n                dst[i] |= ((src[i-1] & 0xff00) >> 8);\n            }\n        }\n        else if ((dstOffsetBytes == 0) && (srcOffsetBytes == 1)){\n            uint32_T i = 0;\n            dst[0] = ((src[0] & 0xff00) >> 8);\n            if (numOfBytes >= 2) {\n                dst[0] |= ((src[1] & 0x00ff) << 8);\n                for (i = 1; i < numOfAGUnits-1; i++){\n                    dst[i]  = ((src[i] & 0xff00) >> 8);\n                    dst[i] |= ((src[i+1] & 0x00ff) << 8);\n                }\n                if (numOfBytes % 2){\n                    dst[i] &= 0xff00;\n                    dst[i] |= ((src[i] & 0xff00) >> 8);\n                }\n            }\n        }\n        else if ((dstOffsetBytes == 1) && (srcOffsetBytes == 1)){\n            dst[0] &= 0x00ff;\n            dst[0] |= (src[0] & 0xff00);\n            numOfBytes--;\n            numOfAGUnits--;\n            dst++;\n            src++;\n            XCP_MEMCPY(dst, src, numOfAGUnits);\n            if ((numOfBytes % 2) != 0){\n                dst[numOfAGUnits] &= 0xff00;\n                dst[numOfAGUnits] |= (src[numOfAGUnits] & 0x00ff);\n            }\n        }\n    }\n}\n\n#endif\n"},{"name":"xcp_standard.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2025b/toolbox/coder/xcp/src/target/server/protocol/src","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2022 The MathWorks, Inc.\n*\n* File: xcp_standard.c\n*\n* Abstract:\n*  Implementation of XCP Protocol Layer standard commands\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp.h\"\n#include \"xcp_cfg.h\"\n#include \"xcp_types.h\"\n#include \"xcp_transport_internal.h\"\n#include \"xcp_daq.h\"\n#include \"xcp_standard.h\"\n#include \"xcp_standard_ext.h\"\n#include \"xcp_standard_types.h\"\n\n\n/*****************************************************************************\n    Internal Variables\n******************************************************************************/\nstatic XcpAddress xcpMta = {0,0};   /* MTA and MTA extension in same format as in SET_MTA packet, used by (SHORT)_UPLOAD, (SHORT)_DOWNLOAD */\nstatic uint8_T xcpUploadSize = 0;\n\n\n/*****************************************************************************\n    Internal Utility Functions\n******************************************************************************/\nstatic boolean_T isValidUploadSize(uint8_T size)\n{\n    size_t addressGranularity = XCP_ADDRESS_GRANULARITY_BYTES_NUMBER;\n    size_t maxCtoSize = xcpTransportMaxCtoSize();\n\n    return (size < ((maxCtoSize) / addressGranularity));\n}\n\n/** memcpy function used to copy data from MTA address to the packet */\nstatic void xcpMemcpyFromMTA(uint8_T *pktData, uint8_T dstOffsetBytes)\n{\n    /* Retrieve memory address */\n    uint8_T *xcpMTARawPointer = xcpStandardGetAddressFromMta();\n\n    XCP_PRINTF(\"reading at address %p\\n\", xcpMTARawPointer);\n\n#ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n{\n    uint32_T address;\n    uint8_T addressExtension;\n    uint8_T srcOffsetBytes;\n    xcpStandardGetMta(&address, &addressExtension);\n    srcOffsetBytes = XCP_BYTE_OFFSET_GET(address);\n    if (dstOffsetBytes) { pktData--; }\n    xcpMemcpyByte(pktData, dstOffsetBytes, xcpMTARawPointer, srcOffsetBytes, xcpUploadSize);\n}\n#else\n    XCP_UNUSED_PARAM(dstOffsetBytes);\n    XCP_MEMCPY(pktData, xcpMTARawPointer, xcpUploadSize);\n#endif\n\n}\n\n/*****************************************************************************\n    XCP CONNECT\n******************************************************************************/\n#define XCP_NO_RESOURCES  0x00\n\nstatic const uint8_T xcpResourceValue = (\n    XCP_NO_RESOURCES\n#ifdef XCP_DAQ_SUPPORT\n    | XCP_RESOURCE_DAQ_MASK\n#endif\n#ifdef XCP_STIM_SUPPORT\n    | XCP_RESOURCE_STIM_MASK\n#endif\n#ifdef XCP_PGM_SUPPORT\n    | XCP_RESOURCE_PGM_MASK\n#endif\n#ifdef XCP_CALIBRATION_SUPPORT\n    | XCP_RESOURCE_CAL_PAG_MASK\n#endif\n    );\n\nstatic const uint8_T xcpCommModeBaseValue = (\n    (XCP_ADDRESS_GRANULARITY << XCP_COMM_MODE_ADDRESS_GRANULARITY_OFFSET)\n#if (XCP_BYTE_ORDER != 0)\n    | XCP_COMM_MODE_BYTE_ORDER_MASK\n#endif\n#ifdef XCP_BLOCK_MODE_SUPPORT\n    | XCP_COMM_MODE_SLAVE_BLOCK_MODE_MASK\n#endif\n#ifdef XCP_COMM_MODE_INFO_SUPPORT\n    | XCP_COMM_MODE_OPTIONAL_MASK\n#endif\n    );\n\nstatic XcpProtoErrorCode connectInputPacketHandler(void   *msgBuffer,\n                                                   size_t  xcpPacketOffset,\n                                                   size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpConnectCmdPacketFrame *frame = (XcpConnectCmdPacketFrame *) packet;\n    boolean_T ok = false;\n\n    /* If DAQ List support is enabled, reset the status of dynamic DAQ list data structures */\n    ok = xcpResetDaqListStatus();\n\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_BUSY,\n        (\"CONNECT: DAQ lists reset cannot be carried out, as an event was processed\\n\"));\n\n    /* Validate command inputs */\n    ok = (frame->mode == XCP_CONNECT_MODE_NORMAL) || (frame->mode == XCP_CONNECT_MODE_USER_DEFINED);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n                          (\"CONNECT: invalid mode detected %xH\\n\", frame->mode));\n\n    /* Everything is fine -> updating the Protocol Layer status */\n    XCP_PRINTF(\"CONNECT: entering XCP_CONNECTED status\\n\");\n    xcpStatusSet(XCP_CONNECTED);\n\n    protoErrorCode = XCP_PROTO_SUCCESS;\n    *outputPacketSize = XCP_CONNECT_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\nstatic void connectOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize)\n{\n    if (inputCode == XCP_PROTO_SUCCESS) {\n        /* Fill connect response */\n        XcpConnectResPacketFrame *frame = (XcpConnectResPacketFrame *)packet;\n        XCP_MEMSET(frame, 0, sizeof(*frame));\n\n        frame->PID = XCP_PID_RES;\n\n        /* Update resource field */\n        frame->resource = xcpResourceValue;\n\n        /* Update commModeBasic field */\n        frame->commModeBasic = xcpCommModeBaseValue;\n\n        /* Update Max CTO and DTO fields */\n        frame->maxCtoSize = (uint8_T)xcpTransportMaxCtoSize();\n        frame->maxDtoSize = (uint16_T)xcpTransportMaxDtoSize();\n\n        /* Update Protocol and Transport Version fields */\n        frame->xcpProtocolVersion  = XCP_MAJOR_NUMBER(XCP_PROTOCOL_LAYER_VERSION);\n        frame->xcpTransportVersion = XCP_MAJOR_NUMBER(XCP_TRANSPORT_LAYER_VERSION);\n\n        XCP_PRINTF(\"* Resource:          %xH\\n\", frame->resource);\n        XCP_PRINTF(\"* Comm Mode Basic:   %xH\\n\", frame->commModeBasic);\n        XCP_PRINTF(\"* Max CTO size:      %d\\n\",  frame->maxCtoSize);\n        XCP_PRINTF(\"* Max DTO size:      %d\\n\",  frame->maxDtoSize);\n        XCP_PRINTF(\"* Protocol Version:  %d\\n\",  frame->xcpProtocolVersion);\n        XCP_PRINTF(\"* Transport Version: %d\\n\",  frame->xcpTransportVersion);\n    }\n    else {\n        genericOutputPacketHandler(inputCode, packet, packetSize);\n    }\n}\n\n/*****************************************************************************\n    XCP DISCONNECT\n******************************************************************************/\nstatic XcpProtoErrorCode disconnectInputPacketHandler(void   *msgBuffer,\n                                                      size_t  xcpPacketOffset,\n                                                      size_t *outputPacketSize)\n{\n    boolean_T ok = true;\n\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    /* If DAQ List support is enabled, reset the status of dynamic DAQ list data structures */\n    ok = xcpResetDaqListStatus();\n\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_BUSY,\n        (\"DISCONNECT: DAQ lists reset cannot be carried out, as an event was processed\\n\"));\n\n    /* Everything is fine -> proceed with the status update */\n    XCP_PRINTF(\"DISCONNECT: entering XCP_DISCONNECTED status\\n\");\n    xcpStatusSet(XCP_DISCONNECTED);\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return XCP_PROTO_SUCCESS;\n}\n\n/*****************************************************************************\n    XCP GET_STATUS\n******************************************************************************/\nstatic XcpProtoErrorCode getStatusInputPacketHandler(void   *msgBuffer,\n                                                     size_t  xcpPacketOffset,\n                                                     size_t *outputPacketSize)\n{\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    XCP_PRINTF(\"GET STATUS\\n\");\n\n    *outputPacketSize = XCP_GET_STATUS_RES_PACKET_SIZE_IN_BYTES;\n\n    return XCP_PROTO_SUCCESS;\n}\n\nstatic void getStatusOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize)\n{\n    XcpGetStatusResPacketFrame *frame = (XcpGetStatusResPacketFrame *)packet;\n\n    XCP_UNUSED_PARAM(inputCode);\n    XCP_UNUSED_PARAM(packetSize);\n\n    /* Fill Get Status response */\n    XCP_MEMSET(frame, 0, sizeof(*frame));\n\n    frame->PID                      = XCP_PID_RES;\n    frame->sessionStatus            = xcpSessionStatusGet();\n    frame->resourceProtectionStatus = xcpResourceProtectionStatusGet();\n    frame->sessionConfigurationId   = xcpSessionConfigurationIdGet();\n\n    XCP_PRINTF(\"* Session Status:              %xH\\n\", frame->sessionStatus);\n    XCP_PRINTF(\"* Resource Protection Status:  %xH\\n\", frame->resourceProtectionStatus);\n    XCP_PRINTF(\"* Session Config Id:           %d\\n\", frame->sessionConfigurationId);\n}\n\n/*****************************************************************************\n    XCP SYNCH\n******************************************************************************/\n#define XCP_SYNC_RES_PACKET_SIZE_IN_BYTES 2\n\nstatic XcpProtoErrorCode synchInputPacketHandler(void   *msgBuffer,\n                                                 size_t  xcpPacketOffset,\n                                                 size_t *outputPacketSize)\n{\n    boolean_T locked = false;\n\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    XCP_PRINTF(\"SYNCH\\n\");\n\n    /* Make sure that no DAQ list is currently\n       in the process of sending packets */\n    locked = xcpDaqLock();\n\n    if (locked) {\n        /* Re-synchronizing the transport layer, by flushing the TX packets currently\n           in the TX FIFO and restarting the frame handler */\n        xcpTransportResynch();\n\n        xcpDaqUnlock();\n    }\n\n    *outputPacketSize = XCP_SYNC_RES_PACKET_SIZE_IN_BYTES;\n\n    return XCP_PROTO_SYNCH;\n}\n\n\n#if XCP_SET_MTA_ENABLE == 1\n/*****************************************************************************\n    XCP SET_MTA\n******************************************************************************/\n    static XcpProtoErrorCode setMTAInputPacketHandler(void  *msgBuffer, \n        size_t  xcpPacketOffset, \n        size_t *outputPacketSize) {\n\n        XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n        uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n        XcpSetMTACmdPacketFrame *frame = (XcpSetMTACmdPacketFrame *)packet;\n        boolean_T ok = false;\n\n        /* Check if the memory address is valid and set the MTA pointer */\n        ok = xcpStandardSetMta(frame->address, (uint8_T)frame->addressExtension);\n        XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_ACCESS_DENIED, (\"SET_MTA: invalid address\\n\"));\n        \n        XCP_PRINTF(\"SET_MTA: setting MTA value to %x and extension %x\\n\", frame->address, frame->addressExtension);    \n\n        *outputPacketSize = sizeof(XcpGenericResPacketFrame);\n\n        return protoErrorCode;\n    }\n\n/*****************************************************************************\n    XCP UPLOAD\n******************************************************************************/\n    static XcpProtoErrorCode uploadInputPacketHandler(void   *msgBuffer,\n        size_t  xcpPacketOffset,\n        size_t *outputPacketSize) {\n\n        XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n        uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n        XcpUploadCmdPacketFrame *frame = (XcpUploadCmdPacketFrame *)packet;\n        boolean_T ok = false;\n        uint8_T *xcpMTARawPointer = xcpStandardGetAddressFromMta();\n\n        /* Check if the number of data elements is valid */\n        ok = isValidUploadSize((uint8_T)frame->size);\n        XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n            (\"UPLOAD: invalid number of data elements (%d)\\n\", (uint8_T)frame->size));\n        \n        /* Check if a valid MTA address is available */\n        XCP_INPUT_PKT_ERROR_IF(xcpMTARawPointer == 0, XCP_PROTO_ACCESS_DENIED,\n            (\"UPLOAD: invalid address\\n\"));\n        \n        xcpUploadSize = (uint8_T)frame->size;\n        *outputPacketSize = XCP_UPLOAD_RES_PACKET_SIZE_IN_BYTES + XCP_IN_BYTES(xcpUploadSize);\n\n        return protoErrorCode;\n    }\n\n    \n    static void uploadOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize) {\n        \n        if (inputCode == XCP_PROTO_SUCCESS) {\n\n            /* Fill Upload response */\n            uint8_T *xcpMTARawPointer = xcpStandardGetAddressFromMta();\n            XcpUploadResPacketFrame *frame = (XcpUploadResPacketFrame *)packet;\n            XCP_MEMSET(frame, 0, sizeof(*frame));\n            frame->PID = XCP_PID_RES;\n\n            if ((xcpMTARawPointer != NULL) &&\n                (packetSize == (XCP_UPLOAD_RES_PACKET_SIZE_IN_BYTES + XCP_IN_BYTES(xcpUploadSize)))\n                ) {\n                uint8_T *pktData = (uint8_T *)packet + XCP_IN_AG(XCP_UPLOAD_RES_PACKET_SIZE_IN_BYTES);\n                uint8_T dstOffsetBytes = (XCP_UPLOAD_RES_PACKET_SIZE_IN_BYTES % XCP_HARDWARE_ADDRESS_GRANULARITY_BYTES_NUMBER);\n\n                XCP_PRINTF(\"UPLOAD: \");\n                \n                /* Copy the memory content to the packet data area */\n                xcpMemcpyFromMTA(pktData, dstOffsetBytes);\n\n                /* Post-increment MTA by the frame size in address granularity units */\n                xcpStandardIncrementMta(xcpUploadSize);\n                xcpUploadSize = 0;\n            }\n            else {\n                /* This is a software error and it should never happen */\n                XCP_PRINTF(\"UPLOAD: invalid data detected\\n\");\n            }\n        }\n        else {\n            genericOutputPacketHandler(inputCode, packet, packetSize);\n        }\n    }\n#endif  /* XCP_SET_MTA_ENABLE == 1  */\n\n\n/*****************************************************************************\n    XCP SHORT_UPLOAD\n******************************************************************************/\nstatic XcpProtoErrorCode shortUploadInputPacketHandler(void   *msgBuffer,\n    size_t  xcpPacketOffset,\n    size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpShortUploadCmdPacketFrame *frame = (XcpShortUploadCmdPacketFrame *)packet;\n    boolean_T ok = false;\n\n    /* Check if the number of data elements is valid */\n    ok = isValidUploadSize((uint8_T)frame->size);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"SHORT_UPLOAD: invalid number of data elements (%d)\\n\", (uint8_T)frame->size));\n\n    /* Check if the memory address is valid and set the MTA pointer */\n    ok = xcpStandardSetMta(frame->address, (uint8_T)frame->addressExtension);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_ACCESS_DENIED, (\"SHORT_UPLOAD: invalid address\\n\"));\n\n    xcpUploadSize = (uint8_T)frame->size;\n\n    *outputPacketSize = XCP_SHORT_UPLOAD_RES_PACKET_SIZE_IN_BYTES + XCP_IN_BYTES(xcpUploadSize);\n\n    return protoErrorCode;\n}\n\nstatic void shortUploadOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize)\n{    \n    if (inputCode == XCP_PROTO_SUCCESS) {\n\n        /* Fill Short Upload response */\n        uint8_T *xcpMTARawPointer = xcpStandardGetAddressFromMta();\n        XcpShortUploadResPacketFrame *frame = (XcpShortUploadResPacketFrame *)packet;\n        XCP_MEMSET(frame, 0, sizeof(*frame));\n\n        frame->PID = XCP_PID_RES;\n\n        if ((xcpMTARawPointer != NULL) &&\n            (packetSize == XCP_SHORT_UPLOAD_RES_PACKET_SIZE_IN_BYTES + XCP_IN_BYTES(xcpUploadSize) )\n           ) {\n            uint8_T *pktData = (uint8_T *)packet + XCP_IN_AG(XCP_SHORT_UPLOAD_RES_PACKET_SIZE_IN_BYTES);\n            uint8_T dstOffsetBytes = (XCP_SHORT_UPLOAD_RES_PACKET_SIZE_IN_BYTES % XCP_HARDWARE_ADDRESS_GRANULARITY_BYTES_NUMBER);\n\n            XCP_PRINTF(\"SHORT_UPLOAD: \");\n\n            /* Copy the memory content to the packet data area */\n            xcpMemcpyFromMTA(pktData, dstOffsetBytes);\n\n            /* Post-increment MTA by the frame size in address granularity units */\n            xcpStandardIncrementMta(xcpUploadSize);\n\n            xcpUploadSize = 0;\n        }\n        else {\n            /* This is a software error and it should never happen */\n            XCP_PRINTF(\"SHORT_UPLOAD: invalid data detected\\n\");\n        }\n    }\n    else {\n        genericOutputPacketHandler(inputCode, packet, packetSize);\n    }\n}\n\n\n/** This table contains the list of supported Rx packets and the corresponding handlers */\nstatic const XcpPacketHandlers standardSupportedRxPacket[] =\n{\n    { XCP_PID_CONNECT,      connectInputPacketHandler,     connectOutputPacketHandler },\n    { XCP_PID_DISCONNECT,   disconnectInputPacketHandler,  genericOutputPacketHandler },\n    { XCP_PID_GET_STATUS,   getStatusInputPacketHandler,   getStatusOutputPacketHandler },\n    { XCP_PID_SYNCH,        synchInputPacketHandler,       genericOutputPacketHandler },\n#if XCP_SET_MTA_ENABLE == 1  \n    { XCP_PID_SET_MTA,      setMTAInputPacketHandler,      genericOutputPacketHandler },\n    { XCP_PID_UPLOAD,       uploadInputPacketHandler,      uploadOutputPacketHandler},\n#endif\n    { XCP_PID_SHORT_UPLOAD, shortUploadInputPacketHandler, shortUploadOutputPacketHandler }\n};\n\n\n\n/*****************************************************************************\n    XCP Packet Lookup Function for basic standard commands\n******************************************************************************/\n\n/* Default Standard Packet Lookup function, supporting only basic commands\n   listed in the table above */\nstatic const XcpPacketHandlers* getPacket(XcpRxPidCode pid)\n{\n    return xcpFindPacket(pid, standardSupportedRxPacket,\n                         XCP_ELEMENTS_NUMBER(standardSupportedRxPacket));\n}\n\nstatic XcpPacketLookupFunction packetLookup = NULL;\n\n\n\n/*****************************************************************************\n    Public Functions (invoked within the Protocol Layer)\n******************************************************************************/\nvoid xcpStandardInit(void)\n{\n    /* Initialize the packet lookup function to support only basic\n       standard commands */\n    xcpStandardSetPacketLookup(getPacket);\n\n    /* Initialize support for the extended list of Standard commands\n       @note this may override the default Packet lookup function\n             by adding support for more (optional) commands */\n    xcpStandardExtendedInit();\n}\n\n\nXcpPacketLookupFunction xcpStandardGetPacketLookup(void)\n{\n    return packetLookup;\n}\n\n\nvoid xcpStandardSetPacketLookup(XcpPacketLookupFunction getPacketFcn)\n{\n    packetLookup = getPacketFcn;\n}\n\n\nvoid xcpStandardReset(void)\n{\n    /* reset support for the extended list of Standard commands */\n    xcpStandardExtendedReset();\n\n    /* Restore the original value for the lookup function */\n    xcpStandardSetPacketLookup(NULL);\n}\n\n\nuint8_T* xcpStandardGetAddressFromMta(void) {\n    return XCP_ADDRESS_GET_WRITE(xcpMta.addressExtension, xcpMta.address);\n}\n\n\nboolean_T xcpStandardSetMta(uint32_T address, uint8_T addressExtension) {\n    if ((addressExtension == 0) && (address == 0)) {\n        return false;\n    } else {\n        xcpMta.address = address;\n        xcpMta.addressExtension = addressExtension;\n        return true;\n    }\n}\n\n\nvoid xcpStandardGetMta(uint32_T *address, uint8_T *addressExtension) {\n    *address = xcpMta.address;\n    *addressExtension = xcpMta.addressExtension;\n}\n\n\nvoid xcpStandardIncrementMta(uint8_T incr) {\n    xcpMta.address += incr;\n}\n\n\n#ifndef XCP_STANDARD_EXTENDED_SUPPORT\n\nvoid xcpStandardExtendedInit(void) {}\nvoid xcpStandardExtendedReset(void) {}\n\n#endif\n"},{"name":"xcp_transport.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2025b/toolbox/coder/xcp/src/target/server/transport/src","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2021 The MathWorks, Inc.\n*\n* File: xcp_transport.c\n*\n* Abstract:\n*  Implementation of XCP Transport Layer.\n*  The file contains the common part that is responsible for the handling\n*  of Tx/Rx buffers and relies on the Xcp Driver and Xcp Frame Handler layers\n*  for sending and receiving data to/from the supported transport layer specification\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp.h\"\n#include \"xcp_transport.h\"\n#include \"xcp_transport_types.h\"\n#include \"xcp_transport_internal.h\"\n#include \"xcp_frame.h\"\n#include \"xcp_fifo.h\"\n#include \"xcp_mem.h\"\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n#include \"xcp_daq_types.h\"\n#endif\n\n/** Number of supported Tx queues */\n\n#define XCP_TRANSPORT_TX_QUEUES_TYPES_NUMBER     2\n\n/** Number of supported Rx queues */\n#define XCP_TRANSPORT_RX_QUEUES_TYPES_NUMBER  1\n\n\n/* In this Transport Layer implementation, the memory buffer associated with a generic\n   XCP message has the following format:\n\n   --------------      +---->  --------------\n  | xcpFifoEntry | ----+      | xcpFifoEntry |\n   --------------              --------------\n  | XCP Header   |            | XCP Header   |\n   --------------              --------------\n  | XCP Packet   |            | XCP Packet   |\n   --------------              --------------\n\n  xcpFifoEntry is an internal data structure used to implement a FIFO through a single linked list\n*/\n\n\n\n/* Transmit FIFOs */\nstatic struct xcpFifo txFifo[XCP_TRANSPORT_TX_QUEUES_TYPES_NUMBER];\n\nstatic XCP_MUTEX_DEFINE(txLock);\n\n/* Receive FIFOs */\nstatic struct xcpFifo rxFifo[XCP_TRANSPORT_RX_QUEUES_TYPES_NUMBER];\n\nstatic XCP_MUTEX_DEFINE(rxLock);\n\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n\n#if XCP_MEM_DAQ_RESERVED_POOLS_NUMBER <= 0\n#error  \"XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT requires a XCP_MEM_DAQ_RESERVED_POOLS_NUMBER value greater than 0\"\n#endif\n\nstatic struct xcpFifo daqDeferredTxFifo[XCP_MEM_DAQ_RESERVED_POOLS_NUMBER];\nstatic struct xcpFifo daqTxFifo[XCP_MEM_DAQ_RESERVED_POOLS_NUMBER];\nstatic boolean_T      daqTxRequest[XCP_MEM_DAQ_RESERVED_POOLS_NUMBER];\nstatic uint16_T       lastDaqIdTx = 0xFFFF;\n\n#endif\n\n\n/* true if the Transport Layer has been successfully initialized */\nstatic boolean_T  initialized = false;\n\n/* ID of the memory pool reserved for the allocation of\n    CTO XCP Packets */\nstatic xcpPoolId_T xcpCtoReservedMemPoolId = -1;\n\n\n#ifdef XCP_DEBUG_SUPPORT\nstatic const char *xcpTransportDiagDataString[XCP_TRANSPORT_COUNTERS_NUMBER] = {\n    \"XCP_TRANSPORT_INIT_COUNTER               \",\n    \"XCP_TRANSPORT_TX_COUNTER                 \",\n    \"XCP_TRANSPORT_TX_PACKET_SET_COUNTER      \",\n    \"XCP_TRANSPORT_RX_PACKET_GET_COUNTER      \",\n    \"XCP_TRANSPORT_RX_COUNTER                 \",\n    \"XCP_TRANSPORT_RESTART_COUNTER            \",\n    \"XCP_TRANSPORT_RESYNCH_COUNTER            \",\n    \"XCP_TRANSPORT_RESET_COUNTER              \",\n    \"XCP_TRANSPORT_MEM_INIT_ERROR             \",\n    \"XCP_TRANSPORT_MEM_RESET_ERROR            \",\n    \"XCP_TRANSPORT_FRAME_INIT_ERROR           \",\n    \"XCP_TRANSPORT_FRAME_CREATE_MSG_ERROR     \",\n    \"XCP_TRANSPORT_FRAME_SEND_ERROR           \",\n    \"XCP_TRANSPORT_FRAME_RECV_ERROR           \",\n    \"XCP_TRANSPORT_FRAME_EXTRACT_PACKET_ERROR \",\n    \"XCP_TRANSPORT_FRAME_RESTART_ERROR        \",\n    \"XCP_TRANSPORT_FRAME_RESET_ERROR          \",\n    \"XCP_TRANSPORT_TX_PACKET_IN_COUNTER       \",\n    \"XCP_TRANSPORT_TX_PACKET_OUT_COUNTER      \",\n    \"XCP_TRANSPORT_TX_PACKET_FREED_COUNTER    \",\n    \"XCP_TRANSPORT_TX_IS_EMPTY_COUNTER        \",\n    \"XCP_TRANSPORT_RX_PACKET_IN_COUNTER       \",\n    \"XCP_TRANSPORT_RX_PACKET_OUT_COUNTER      \",\n    \"XCP_TRANSPORT_RX_PACKET_FREED_COUNTER    \",\n    \"XCP_TRANSPORT_RX_IS_EMPTY_COUNTER        \"\n};\n\nstatic XcpTransportDiagnostic xcpTransportDiagnostic;\n\n\nvoid xcpTransportDiagnosticReset(void)\n{\n    XCP_MEMSET(&xcpTransportDiagnostic, 0, sizeof(xcpTransportDiagnostic));\n}\n\n\nvoid xcpTransportDiagnosticGet(XcpTransportDiagnostic *diag)\n{\n    XCP_MEMCPY(diag, &xcpTransportDiagnostic, sizeof(xcpTransportDiagnostic));\n}\n\n\nvoid xcpTransportDiagnosticPrint(const XcpTransportDiagnostic *diag)\n{\n    if (diag != NULL) {\n        int i = 0;\n        for (i = 0; i < XCP_TRANSPORT_COUNTERS_NUMBER; i++) {\n            XCP_PRINTF(\"%s = %lu\\n\", xcpTransportDiagDataString[i], (unsigned long) xcpTransportDiagnostic.data[i]);\n        }\n    }\n}\n\n#define XCP_DIAG_UPDATE(counterId)     xcpTransportDiagnostic.data[counterId]++\n\n#else\n\n#define XCP_DIAG_UPDATE(counterId) \n\n#endif\n\n/* Empty the TX FIFO by deleting the existing packets */\nstatic void xcpTransportEmptyTxFifo(void)\n{\n    struct xcpFifoEntry *msgBufferHeader = NULL;\n    uint16_T i = 0;\n\n    XCP_MUTEX_LOCK(txLock);\n\n    for (i = 0; i < XCP_TRANSPORT_TX_QUEUES_TYPES_NUMBER; i++) {\n        do {\n            xcpFifoDequeue(&txFifo[i], &msgBufferHeader);\n\n            if (msgBufferHeader != NULL) {\n                xcpMemFree(msgBufferHeader);\n                XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_PACKET_FREED_COUNTER);\n            }\n        } while (msgBufferHeader != NULL);\n    }\n\n    XCP_MUTEX_UNLOCK(txLock);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    for (i = 0; i < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER; i++) {\n        do {\n            xcpFifoDequeue(&daqTxFifo[i], &msgBufferHeader);\n\n            if (msgBufferHeader != NULL) {\n                xcpMemFree(msgBufferHeader);\n                XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_PACKET_FREED_COUNTER);\n            }\n        } while (msgBufferHeader != NULL);\n\n        do {\n            xcpFifoDequeue(&daqDeferredTxFifo[i], &msgBufferHeader);\n\n            if (msgBufferHeader != NULL) {\n                xcpMemFree(msgBufferHeader);\n                XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_PACKET_FREED_COUNTER);\n            }\n        } while (msgBufferHeader != NULL);\n\n        daqTxRequest[i] = false;\n    }\n    lastDaqIdTx = 0xFFFF;\n#endif\n}\n\n\n/* Empty the RX FIFO by deleting the existing packets */\nstatic void xcpTransportEmptyRxFifo(void)\n{\n    struct xcpFifoEntry *msgBufferHeader = NULL;\n    XcpTransportQueueType_T i = 0;\n\n    XCP_MUTEX_LOCK(rxLock);\n\n    for (i = 0; i < XCP_TRANSPORT_RX_QUEUES_TYPES_NUMBER; i++) {\n        do {\n            xcpFifoDequeue(&rxFifo[i], &msgBufferHeader);\n\n            if (msgBufferHeader != NULL) {\n                xcpMemFree(msgBufferHeader);\n                XCP_DIAG_UPDATE(XCP_TRANSPORT_RX_PACKET_FREED_COUNTER);\n            }\n        } while (msgBufferHeader != NULL);\n    }\n\n    XCP_MUTEX_UNLOCK(rxLock);\n}\n\n\nXcpErrorCode xcpTransportInit(int argc, void * argv[])\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    uint16_T i = 0;\n\n    XCP_ERROR_IF(initialized, XCP_ERROR, \"xcpTransportInit: transport layer already initialized\\n\");\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_INIT_COUNTER);\n\n    /* Initialize Tx and Rx data structures*/\n    for (i = 0; i < XCP_TRANSPORT_TX_QUEUES_TYPES_NUMBER; i++) {\n        xcpFifoInit(&txFifo[i]);\n    }\n    XCP_MUTEX_INIT(txLock);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    for (i = 0; i < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER; i++) {\n        xcpFifoInit(&daqTxFifo[i]);\n        xcpFifoInit(&daqDeferredTxFifo[i]);\n        daqTxRequest[i] = false;\n    }\n    lastDaqIdTx = 0xFFFF;\n#endif\n\n    for (i = 0; i < XCP_TRANSPORT_RX_QUEUES_TYPES_NUMBER; i++) {\n        xcpFifoInit(&rxFifo[i]);\n    }\n    XCP_MUTEX_INIT(rxLock);\n\n    /* Initialize XCP memory allocator */\n    errorCode = xcpMemInit();\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportInit: error (%d) detected during memory allocator initialization\\n\", errorCode);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_MEM_INIT_ERROR);\n        return errorCode;\n    }\n\n    {\n        /* Allocate the memory pool reserved for the allocation\n           of CTO, EV and SERV XCP Packets */\n        size_t maxCtoSize = xcpTransportMaxCtoSize();\n        size_t maxBufferSize = xcpTransportMsgBufferSize(maxCtoSize, XCP_CTO);\n\n        errorCode = xcpMemReservedPoolCreate(maxBufferSize, XCP_MEM_CTO_RESERVED_POOL_BLOCKS_NUMBER,\n                                             &xcpCtoReservedMemPoolId);\n\n        if (errorCode != XCP_SUCCESS) {\n            XCP_PRINTF(\"xcpTransportInit: error (%d) detected during allocation of reserved memory pool\\n\", errorCode);\n            XCP_DIAG_UPDATE(XCP_TRANSPORT_MEM_INIT_ERROR);\n            return errorCode;\n        }\n\n        xcpFrameSetCtoReservedMemPoolId(xcpCtoReservedMemPoolId);\n    }\n\n    /* Initialize XCP Frame handler */\n    errorCode = xcpFrameInit(argc, argv);\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportInit: error (%d) detected during frame handler initialization\\n\", errorCode);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_INIT_ERROR);\n        return errorCode;\n    }\n\n    initialized = true;\n\n    return errorCode;\n}\n\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n\nboolean_T xcpTransportTxReady(\n    XcpTransportQueueType_T queueType, /**< [in] type of the TX queue the packet has to be sent to */\n\tuint16_T daqId                     /**< [in] id of the DAQ list the packet refers to */\n)\n{\n    boolean_T ready = true;\n    /* In the lockless implementation we enqueue data only\n       if the previous transmission has been completed */\n    if ((queueType == XCP_TRANSPORT_TX_DEFAULT_QUEUE) &&\n        (daqId <  XCP_MEM_DAQ_RESERVED_POOLS_NUMBER)) {\n        ready = !daqTxRequest[daqId];\n    }\n\n    return ready;\n}\n\n\n/** If lockless streaming is enabled, trigger the transmission of\n    packets previously enqueued (by invoking xcpTransportTxPacketSet.\n    The function returns XCP_BUSY if the TX request is already\n    in progress */\nXcpErrorCode  xcpTransportTxTrigger(\n    XcpTransportQueueType_T queueType, /**< [in] type of the TX queue the packet has to be sent to */\n    uint16_T daqId                     /**< [in] id of the DAQ list the packet refers to */\n)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    if ((queueType != XCP_TRANSPORT_TX_DEFAULT_QUEUE) ||\n        (daqId >= XCP_MEM_DAQ_RESERVED_POOLS_NUMBER)) {\n        return XCP_INV_ARG;\n    }\n\n    if (!daqTxRequest[daqId]) {\n        if (!xcpFifoEmpty(daqDeferredTxFifo)) {\n            /* If the transmission of any packets was deferred \n               from previous run, we need to enqueue them at the\n               head of the daqTxFifo, as they need to be sent first */\n            xcpFifoSpliceHead(daqTxFifo, daqDeferredTxFifo);\n        }\n\n        XCP_MEM_BARRIER();\n        daqTxRequest[daqId] = true;\n    } else {\n        errorCode = XCP_BUSY;\n    }\n\n    return errorCode;\n}\n\n#else\n\nboolean_T xcpTransportTxReady(\n    XcpTransportQueueType_T queueType, /**< [in] type of the TX queue the packet has to be sent to */\n    uint16_T daqId                     /**< [in] id of the DAQ list the packet refers to */\n)\n{\n    XCP_UNUSED_PARAM(queueType);\n    XCP_UNUSED_PARAM(daqId);\n\n    /* In the standard (mutex-based) implementation we can always enqueue\n       new packets and therefore TX is always ready*/\n    return true;\n}\n\n\nXcpErrorCode  xcpTransportTxTrigger(\n    XcpTransportQueueType_T queueType, /**< [in] type of the TX queue the packet has to be sent to */\n    uint16_T daqId                     /**< [in] id of the DAQ list the packet refers to */\n)\n{\n    /* In the standard (mutex-based) implementation the transmission\n       is always in progress, as long as there are samples in the TX fifo.\n       For this reasons this method has no effect in this case */\n    XCP_UNUSED_PARAM(queueType);\n    XCP_UNUSED_PARAM(daqId);\n\n    return XCP_SUCCESS;\n}\n\n#endif\n\n\nXcpErrorCode xcpTransportTxPacketSet(\n    XcpTransportQueueType_T queueType, /**< [in] id of the TX queue the packet has to be sent to */\n    uint16_T daqId,       /**< [in] id of the DAQ list the packet refers to */\n    void  *msgBuffer,       /* [in] pointer to the buffer containing the full XCP message */\n    size_t msgBufferSize,   /* [in] size (in AG units) of the buffer */\n    size_t xcpPktOffset,    /* [in] offset (in AG units) where the actual XCP packet content has been copied (within xcpMsg buffer)  */\n    size_t xcpPktSize       /* [in] size (in BYTEs) of the XCP packet */\n    )\n{\n    struct xcpFifoEntry *msgBufferHeader = NULL;\n    uint8_T *msgFrame = NULL;\n    size_t msgFrameMaxSize = 0;\n    size_t msgFrameSize = 0;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    /* Lock must be excluded for DAQ lists associated to reserved memory pools */\n    boolean_T locklessTx = ((queueType == XCP_TRANSPORT_TX_DEFAULT_QUEUE)   ||\n                            (queueType == XCP_TRANSPORT_DEFERRED_TX_QUEUE)) &&\n                            (daqId < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER);\n#else\n    XCP_UNUSED_PARAM(daqId);\n#endif\n\n    /* Input parameters validation */\n    XCP_ERROR_IF((queueType != XCP_TRANSPORT_DEFERRED_TX_QUEUE) && \n                 ((queueType < 0) || (queueType >= XCP_TRANSPORT_TX_QUEUES_TYPES_NUMBER)), \n                 XCP_INV_ARG, \"xcpTransportTxPacketSet: invalid queueType\\n\");\n    XCP_ERROR_IF(msgBuffer == NULL, XCP_INV_ARG, \"xcpTransportTxPacketSet: invalid msgBuffer\\n\");\n    XCP_ERROR_IF(xcpPktOffset != xcpTransportPacketOffset(), XCP_INV_ARG, \"xcpTransportTxPacketSet: invalid packet offset\\n\");\n    XCP_ERROR_IF(xcpPktSize == 0, XCP_INV_ARG, \"xcpTransportTxPacketSet: invalid packet size\\n\");\n    XCP_ERROR_IF(msgBufferSize < (xcpPktOffset + XCP_IN_HW_AG(xcpPktSize)), XCP_INV_ARG, \"xcpTransportTxPacketSet: invalid msgBufferSize\\n\");\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpTransportTxPacketSet: transport layer not initialized\\n\");\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_PACKET_SET_COUNTER);\n\n    msgBufferHeader = (struct xcpFifoEntry *) msgBuffer;\n    msgFrame = (uint8_T *)msgBuffer + sizeof(struct xcpFifoEntry);\n    msgFrameMaxSize = msgBufferSize - sizeof(struct xcpFifoEntry);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    if (!locklessTx) {\n#endif\n    /* Now fill the XCP frame content \n       @note the lock is used to protect the txFifo data structures from concurrent execution */\n    XCP_MUTEX_LOCK(txLock);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    }\n#endif\n\n    errorCode = xcpFrameCreateMsg(msgFrame, msgFrameMaxSize, &msgFrameSize, xcpPktSize);\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportTxPacketSet: xcpFrameCreateMsg failure detected (%d)\\n\", errorCode);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_CREATE_MSG_ERROR);\n        goto error;\n    }\n\n    msgBufferHeader->msgFrameSize = msgFrameSize;\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    if (!locklessTx) {\n#endif\n        /* Now that the packet has been created, we can add it to the txFifo for transmission */\n        xcpFifoEnqueue(&txFifo[queueType], msgBufferHeader);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    } else {\n        if (queueType == XCP_TRANSPORT_DEFERRED_TX_QUEUE) {\n            xcpFifoEnqueue(&daqDeferredTxFifo[daqId], msgBufferHeader);\n        } else {\n         xcpFifoEnqueue(&daqTxFifo[daqId], msgBufferHeader);\n        }\n    }\n#endif\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_PACKET_IN_COUNTER);\n\nerror:\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    if (!locklessTx) {\n#endif\n    XCP_MUTEX_UNLOCK(txLock);\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    }\n#endif\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpTransportTx(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t msgFrameSize = 0;\n    struct xcpFifoEntry *msgBufferHeader = NULL;\n    XcpTransportQueueType_T queueType = XCP_TRANSPORT_TX_HIGHEST_PRIO_QUEUE;\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    /* Lock must be excluded for DAQ lists associated to reserved memory pools */\n    boolean_T locklessTx = false;\n#endif\n\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpTransportTx: transport layer not initialized\\n\");\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_COUNTER);\n\n    XCP_MUTEX_LOCK(txLock);\n    /* Extract the message from the Fifos, starting from the highest priority */\n    xcpFifoDequeue(&txFifo[queueType], &msgBufferHeader);\n\n    XCP_MUTEX_UNLOCK(txLock);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    if (msgBufferHeader == NULL) {\n        uint16_T i = 0;\n        /* If the highest priority is empty, check if one of the DAQ-specific ones\n           has a pending request */\n        for (i = 0; (i < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER) && !locklessTx; i++) {\n            lastDaqIdTx = (lastDaqIdTx + 1) %  XCP_MEM_DAQ_RESERVED_POOLS_NUMBER;\n            if (daqTxRequest[lastDaqIdTx]) {\n                xcpFifoDequeue(&daqTxFifo[lastDaqIdTx], &msgBufferHeader);\n                if (msgBufferHeader == NULL) {\n                    /* if no data are available, we can acknowledge the request\n                       straight away */\n                    daqTxRequest[lastDaqIdTx] = false;\n                } else {\n                    locklessTx = true;\n                }\n            }\n        }\n    }\n#endif\n    if (msgBufferHeader == NULL) {\n        /* If the highest priority is empty, and no DAQ packets are available\n           try the default queue */\n        XCP_MUTEX_LOCK(txLock);\n\n        queueType = XCP_TRANSPORT_TX_DEFAULT_QUEUE;\n        xcpFifoDequeue(&txFifo[queueType], &msgBufferHeader);\n        XCP_MUTEX_UNLOCK(txLock);\n    }\n\n    if (msgBufferHeader != NULL) {\n        msgFrameSize = msgBufferHeader->msgFrameSize;\n\n        /* Trying to send one XCP message via the frame handler\n           @note The frame handler will be responsible for releasing\n                 the message buffer if the data has been successfully sent\n                 (return code XCP_SUCCESS).\n                 If not, the memory area won't be freed and the message\n                 will need to go back to the FIFO. */\n        errorCode = xcpFrameMsgSend(msgBufferHeader, sizeof(struct xcpFifoEntry), msgFrameSize);\n\n        if (errorCode != XCP_SUCCESS) {\n            XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_SEND_ERROR);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n            if (!locklessTx) {\n#endif\n            XCP_MUTEX_LOCK(txLock);\n\n            xcpFifoEnqueueHead(&txFifo[queueType], msgBufferHeader);\n\n            XCP_MUTEX_UNLOCK(txLock);\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n            } else {\n                xcpFifoEnqueueHead(&daqTxFifo[lastDaqIdTx], msgBufferHeader);\n            }\n#endif\n        } else {\n            XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_PACKET_OUT_COUNTER);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n            if (locklessTx && xcpFifoEmpty(&daqTxFifo[lastDaqIdTx])) {\n                /* All packets in the queue have been sent,\n                   the request can be acknowledged */\n                XCP_MEM_BARRIER();\n                daqTxRequest[lastDaqIdTx] = false;\n            }\n#endif\n        }\n    } else {\n        errorCode = XCP_EMPTY;\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_IS_EMPTY_COUNTER);\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpTransportRx(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t msgFrameSize = 0;\n    struct xcpFifoEntry *msgBufferHeader = NULL;\n\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpTransportRx: transport layer not initialized\\n\");\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_RX_COUNTER);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    /* Make sure that the blocks associated to the CTO reserved memory\n       pool are made available for subsequent allocations */\n    xcpMemReservedPoolFlushFreeMem(xcpCtoReservedMemPoolId);\n#endif\n\n    /* Trying to receive one XCP message via the frame handler\n       @note The frame handler is also responsible for allocating the\n             memory area and it is no longer responsible for the ownership\n             of the memory if the function has been successfully executed\n             (error code XCP_SUCCESS)\n             If there are no messages available, the return code is XCP_EMPTY */\n    errorCode = xcpFrameMsgRecv((void**) &msgBufferHeader, sizeof(struct xcpFifoEntry), &msgFrameSize);\n\n    if (errorCode == XCP_SUCCESS) {\n        /* Add the message to the Fifo */\n        msgBufferHeader->msgFrameSize = msgFrameSize;\n\n        XCP_MUTEX_LOCK(rxLock);\n\n        /* Only one RX queue available */\n        xcpFifoEnqueue(&rxFifo[XCP_TRANSPORT_RX_DEFAULT_QUEUE], msgBufferHeader);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_RX_PACKET_IN_COUNTER);\n\n        XCP_MUTEX_UNLOCK(rxLock);\n    } else if (errorCode == XCP_EMPTY) {\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_RX_IS_EMPTY_COUNTER);\n    } else {\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_RECV_ERROR);\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpTransportRxPacketGet(\n    XcpTransportQueueType_T queueType, /**< [in] id of the RX queue the packet has to be received from */\n    void  **msgBuffer,     /* [out] pointer to the buffer containing the full XCP message that has been extracted */\n    size_t *msgBufferSize, /* [out] size (in AG units) of the buffer */\n    size_t *xcpPktOffset,  /* [out] offset (in AG units) of the XCP packet within the message buffer */\n    size_t *xcpPktSize     /* [out] size (in BYTEs) of the XCP packet */\n    )\n{\n    struct xcpFifoEntry *msgBufferHeader = NULL;\n    uint8_T *msgFrame = NULL;\n    size_t msgFrameSize = 0;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    /* Input parameters validation */\n    XCP_ERROR_IF((queueType < 0) || (queueType >= XCP_TRANSPORT_RX_QUEUES_TYPES_NUMBER), XCP_INV_ARG, \"xcpTransportRxPacketGet: invalid queueType\\n\");\n    XCP_ERROR_IF(msgBuffer == NULL, XCP_INV_ARG, \"xcpTransportRxPacketGet: invalid msgBuffer pointer\\n\");\n    XCP_ERROR_IF(msgBufferSize == NULL, XCP_INV_ARG, \"xcpTransportRxPacketGet: invalid msgBufferSize pointer\\n\");\n    XCP_ERROR_IF(xcpPktOffset == NULL, XCP_INV_ARG, \"xcpTransportRxPacketGet: invalid xcpPktOffset pointer\\n\");\n    XCP_ERROR_IF(xcpPktSize == NULL, XCP_INV_ARG, \"xcpTransportRxPacketGet: invalid xcpPktSize pointer\\n\");\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpTransportRxPacketGet: transport layer not initialized\\n\");\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_RX_PACKET_GET_COUNTER);\n\n    XCP_MUTEX_LOCK(rxLock);\n\n    xcpFifoDequeue(&rxFifo[queueType], &msgBufferHeader);\n\n    XCP_MUTEX_UNLOCK(rxLock);\n\n    if (msgBufferHeader == NULL) {\n        return XCP_EMPTY; /* No messages in the FIFO */\n    }\n    else {\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_RX_PACKET_OUT_COUNTER);\n    }\n\n    msgFrame = (uint8_T *) msgBufferHeader + sizeof(struct xcpFifoEntry);\n    msgFrameSize = msgBufferHeader->msgFrameSize;\n\n    /* Extract a new XCP packet from the XCP message, and carry out all the relevant checks in the frame format */\n    errorCode = xcpFrameExtractPacket(msgFrame, msgFrameSize, xcpPktSize);\n    if (errorCode != XCP_SUCCESS) {\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_EXTRACT_PACKET_ERROR);\n    }\n\n    *msgBuffer = msgBufferHeader;\n    *msgBufferSize = msgBufferHeader->msgFrameSize + sizeof(struct xcpFifoEntry);\n    *xcpPktOffset = xcpTransportPacketOffset();\n\n    return errorCode;\n}\n\n\nsize_t xcpTransportPacketOffset(void)\n{\n    size_t size = sizeof(struct xcpFifoEntry);\n\n    size += XCP_IN_HW_AG(xcpFrameHeaderSize());\n\n    return size;\n}\n\n/* xcpPacketSize is the number of octets in the XCP Packet\n * Return value the buffer size in terms of target memory granularity needed to contain this packet.\n * On 32-bit address granularity processor, a packet of 6 contiguous BYTEs, we require 2 memory\n *  locations to contain it.\n */\nsize_t xcpTransportMsgBufferSize(size_t xcpPacketSize, XcpPacketType pktType)\n{\n    size_t size = 0;\n    size_t maxPacketSize = 0;\n    \n    maxPacketSize = (pktType == XCP_CTO) ? xcpFrameMaxCtoSize() : xcpFrameMaxDtoSize();\n\n    if (xcpPacketSize > maxPacketSize) {\n        XCP_PRINTF(\"xcpTransportMsgSize: invalid xcpPacketSize\\n\");\n        return 0;\n    }\n\n    size = sizeof(struct xcpFifoEntry);\n\n    size += XCP_IN_HW_AG(xcpFrameHeaderSize());\n    size += XCP_IN_HW_AG(xcpPacketSize);\n    size += XCP_IN_HW_AG(xcpFrameTailSize());\n\n    return size;\n}\n\n\nsize_t xcpTransportMaxDtoSize(void)\n{\n    return xcpFrameMaxDtoSize();\n}\n\n\nsize_t xcpTransportMaxCtoSize(void)\n{\n    return xcpFrameMaxCtoSize();\n}\n\n\nXcpErrorCode xcpTransportRestart(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_RESTART_COUNTER);\n\n    /* Restart Frame Handler */\n    errorCode = xcpFrameRestart();\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportRestart: error (%d) detected during frame handler restart\\n\", errorCode);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_RESTART_ERROR);\n        return errorCode;\n    }\n\n    /* Empty TX and RX fifos */\n    xcpTransportEmptyTxFifo();\n    xcpTransportEmptyRxFifo();\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpTransportResynch(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_RESYNCH_COUNTER);\n\n    /* Restart Frame Handler */\n    errorCode = xcpFrameRestart();\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportRestart: error (%d) detected during frame handler restart\\n\", errorCode);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_RESTART_ERROR);\n        return errorCode;\n    }\n\n    /* Empty TX FIFO */\n    xcpTransportEmptyTxFifo();\n\n    return errorCode;\n}\n\n\nxcpPoolId_T xcpTransportCtoReservedMemPoolId(void)\n{\n    return xcpCtoReservedMemPoolId;\n}\n\n\nXcpErrorCode xcpTransportReset(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    XcpTransportQueueType_T i = 0;\n\n    if (!initialized) {\n        XCP_PRINTF(\"xcpTransportReset: transport layer already reset\\n\");\n        return XCP_SUCCESS; /* Nothing to do: just printing out a warning message*/\n    }\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_RESET_COUNTER);\n\n    /* Reset XCP Frame handler */\n    errorCode = xcpFrameReset();\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportReset: error (%d) detected during frame handler reset\\n\", errorCode);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_RESET_ERROR);\n        return errorCode;\n    }\n\n    /* Before resetting the txFifo and rxFifo, all the message buffers still enqueued need to be freed\n    as the ownership of the memory area was explicitly given to the Transport Layer */\n    xcpTransportEmptyTxFifo();\n    xcpTransportEmptyRxFifo();\n\n    /* Destroy the reserved memory pool */\n    xcpMemReservedPoolDestroy(xcpCtoReservedMemPoolId);\n\n    /* Reset XCP memory allocator */\n    errorCode = xcpMemReset();\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportReset: error (%d) detected during memory allocator reset\\n\", errorCode);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_MEM_RESET_ERROR);\n        return errorCode;\n    }\n\n    /* Now we can reset Tx and Rx Fifos */\n    /* Initialize Tx and Rx data structures*/\n    for (i = 0; i < XCP_TRANSPORT_TX_QUEUES_TYPES_NUMBER; i++) {\n        xcpFifoReset(&txFifo[i]);\n    }\n    for (i = 0; i < XCP_TRANSPORT_RX_QUEUES_TYPES_NUMBER; i++) {\n        xcpFifoReset(&rxFifo[i]);\n    }\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    for (i = 0; i < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER; i++) {\n        xcpFifoReset(&daqTxFifo[i]);\n        xcpFifoReset(&daqDeferredTxFifo[i]);\n        daqTxRequest[i] = false;\n    }\n    lastDaqIdTx = 0xFFFF;\n#endif\n\n    initialized = false;\n\n    return errorCode;\n}\n\n\n"},{"name":"xcp_utils.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2025b/toolbox/coder/xcp/src/target/server/common","tag":"","groupDisplay":"Other files","code":"/* Copyright 2022 The MathWorks, Inc. */\n\n#include \"xcp_utils.h\"\n\n/**\n * Sort elements in `toSort` in ascending order, keeping the correspondence with elements of\n * `toKeepAligned`.\n **/\nvoid xcpSortArray(size_t *toSort, size_t *toKeepAligned, size_t size)\n{\n    unsigned char sorted = size == 0; /* an empty array is already sorted */\n    size_t idx = 0;\n\n    while (!sorted) {\n        sorted = 1;\n        for (idx = 0; idx < size - 1; ++idx) {\n            if (toSort[idx + 1] < toSort[idx]) {\n                size_t tempToSort = toSort[idx];\n                size_t tempToKeepAligned = toKeepAligned[idx];\n\n                sorted = 0;\n\n                toKeepAligned[idx] = toKeepAligned[idx + 1];\n                toKeepAligned[idx + 1] = tempToKeepAligned;\n\n                toSort[idx] = toSort[idx + 1];\n                toSort[idx + 1] =  tempToSort;\n            }\n        }\n    }\n}\n"}],"trace":"{\"model\":\"LabB_CheckCommunications\",\"sources\":[\"LabB_CheckCommunications.c\",\"LabB_CheckCommunications.h\"],\"categoricalProps\":[\"ModelElemCategory\",\"StorageClass\"],\"categoricalValues\":[\"InternalData\",\"Default\",\"LocalParameters\"],\"sidPrefixes\":[\"LabB_CheckCommunications\",\"/home/emil/MATLAB Add-Ons/Collections/Rensselaer Arduino Support Package Library (RASPLib)/RASPlib/blocks/Encoder_arduino.m\",\"/home/emil/MATLAB Add-Ons/Collections/Rensselaer Arduino Support Package Library (RASPLib)/RASPlib/blocks/soMPU6050Accel.m\",\"/home/emil/MATLAB Add-Ons/Collections/Rensselaer Arduino Support Package Library (RASPLib)/RASPlib/blocks/soMPU6050Gyro.m\"],\"fileRecords\":{\"1\":{\"records\":[{\"tk\":[80,3,80,9],\"els\":[\"0:399:198\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[80,10,80,14],\"els\":[\"0:399:198\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[80,14,80,15],\"els\":[\"0:399:198\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[81,3,81,9],\"els\":[\"0:398:198\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[81,10,81,16],\"els\":[\"0:398:198\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[81,16,81,17],\"els\":[\"0:398:198\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[82,3,82,9],\"els\":[\"0:401\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[82,10,82,18],\"els\":[\"0:401\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[82,18,82,19],\"els\":[\"0:401\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[83,3,83,10],\"els\":[\"0:405\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[83,11,83,32],\"els\":[\"0:405\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[83,32,83,33],\"els\":[\"0:405\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[88,3,88,34],\"els\":[\"0:407\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[88,35,88,38],\"els\":[\"0:407\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[88,38,88,39],\"els\":[\"0:407\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[89,3,89,34],\"els\":[\"0:360\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[89,35,89,40],\"els\":[\"0:360\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[89,40,89,41],\"els\":[\"0:360\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[90,3,90,34],\"els\":[\"0:406\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[90,35,90,40],\"els\":[\"0:406\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[90,40,90,41],\"els\":[\"0:406\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[91,3,91,34],\"els\":[\"0:405\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[91,35,91,40],\"els\":[\"0:405\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[91,40,91,41],\"els\":[\"0:405\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[92,3,92,34],\"els\":[\"0:362\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[92,35,92,40],\"els\":[\"0:362\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[92,40,92,41],\"els\":[\"0:362\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[93,3,93,9],\"els\":[\"0:333\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[93,10,93,39],\"els\":[\"0:333\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[93,39,93,40],\"els\":[\"0:333\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[94,3,94,9],\"els\":[\"0:401\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[94,10,94,17],\"els\":[\"0:401\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[94,17,94,18],\"els\":[\"0:401\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[95,3,95,9],\"els\":[\"0:401\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[95,10,95,17],\"els\":[\"0:401\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[95,17,95,18],\"els\":[\"0:401\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[96,3,96,9],\"els\":[\"0:390\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[96,10,96,11],\"els\":[\"0:390\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[97,5,97,9],\"els\":[\"0:390\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[97,10,97,11],\"els\":[\"0:390\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[97,11,97,21],\"els\":[\"0:390\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[97,21,97,22],\"els\":[\"0:390\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[98,3,98,4],\"els\":[\"0:390\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[98,5,98,24],\"els\":[\"0:390\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[98,24,98,25],\"els\":[\"0:390\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[100,3,100,9],\"els\":[\"0:393\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[100,10,100,11],\"els\":[\"0:393\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[101,5,101,9],\"els\":[\"0:393\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[101,10,101,11],\"els\":[\"0:393\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[101,11,101,21],\"els\":[\"0:393\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[101,21,101,22],\"els\":[\"0:393\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[102,3,102,4],\"els\":[\"0:393\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[102,5,102,18],\"els\":[\"0:393\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[102,18,102,19],\"els\":[\"0:393\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[104,3,104,9],\"els\":[\"0:350\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[104,10,104,11],\"els\":[\"0:350\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[105,5,105,9],\"els\":[\"0:350\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[105,10,105,11],\"els\":[\"0:350\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[105,11,105,21],\"els\":[\"0:350\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[105,21,105,22],\"els\":[\"0:350\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[106,3,106,4],\"els\":[\"0:350\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[106,5,106,15],\"els\":[\"0:350\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[106,15,106,16],\"els\":[\"0:350\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[108,3,108,9],\"els\":[\"0:402\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[108,10,108,11],\"els\":[\"0:402\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[109,5,109,9],\"els\":[\"0:402\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[109,10,109,11],\"els\":[\"0:402\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[109,11,109,21],\"els\":[\"0:402\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[109,21,109,22],\"els\":[\"0:402\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[110,3,110,4],\"els\":[\"0:402\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[110,5,110,16],\"els\":[\"0:402\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[110,16,110,17],\"els\":[\"0:402\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[112,3,112,10],\"els\":[\"0:401\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[112,11,112,23],\"els\":[\"0:401\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[112,23,112,24],\"els\":[\"0:401\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[117,3,117,9],\"els\":[\"0:358\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[117,10,117,25],\"els\":[\"0:358\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[117,25,117,26],\"els\":[\"0:358\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[120,3,120,9],\"els\":[\"0:357\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[120,10,120,25],\"els\":[\"0:357\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[120,25,120,26],\"els\":[\"0:357\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[123,3,123,9],\"els\":[\"0:332\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[123,10,123,27],\"els\":[\"0:332\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[123,27,123,28],\"els\":[\"0:332\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[126,3,126,9],\"els\":[\"0:333\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[126,10,126,40],\"els\":[\"0:333\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[126,40,126,41],\"els\":[\"0:333\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[130,3,130,9],\"els\":[\"0:333\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[130,10,130,35],\"els\":[\"0:333\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[130,35,130,36],\"els\":[\"0:333\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[133,3,133,9],\"els\":[\"0:399:198\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[133,10,133,19],\"els\":[\"0:399:198\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[133,19,133,20],\"els\":[\"0:399:198\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[136,3,136,9],\"els\":[\"0:341\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[136,10,136,36],\"els\":[\"0:341\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[136,36,136,37],\"els\":[\"0:341\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[139,3,139,9],\"els\":[\"0:343\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[139,10,139,36],\"els\":[\"0:343\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[139,36,139,37],\"els\":[\"0:343\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[142,3,142,9],\"els\":[\"0:397\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[142,10,142,38],\"els\":[\"0:397\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[142,38,142,39],\"els\":[\"0:397\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[145,3,145,9],\"els\":[\"0:398:198\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[145,10,145,21],\"els\":[\"0:398:198\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[145,21,145,22],\"els\":[\"0:398:198\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[148,3,148,9],\"els\":[\"0:401\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[148,10,148,22],\"els\":[\"0:401\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[148,22,148,23],\"els\":[\"0:401\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[151,3,151,9],\"els\":[\"0:401\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[151,10,151,23],\"els\":[\"0:401\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[151,23,151,24],\"els\":[\"0:401\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[154,3,154,9],\"els\":[\"0:401\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[154,10,154,23],\"els\":[\"0:401\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[154,23,154,24],\"els\":[\"0:401\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[157,3,157,9],\"els\":[\"0:401\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[157,10,157,24],\"els\":[\"0:401\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[157,24,157,25],\"els\":[\"0:401\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[160,3,160,9],\"els\":[\"0:401\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[160,10,160,23],\"els\":[\"0:401\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[160,23,160,24],\"els\":[\"0:401\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[163,3,163,9],\"els\":[\"0:401\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[163,10,163,23],\"els\":[\"0:401\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[163,23,163,24],\"els\":[\"0:401\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[166,3,166,9],\"els\":[\"0:401\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[166,10,166,23],\"els\":[\"0:401\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[166,23,166,24],\"els\":[\"0:401\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[169,3,169,9],\"els\":[\"0:401\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[169,10,169,23],\"els\":[\"0:401\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[169,23,169,24],\"els\":[\"0:401\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[172,3,172,9],\"els\":[\"0:339\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[172,10,172,35],\"els\":[\"0:339\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[172,35,172,36],\"els\":[\"0:339\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[175,3,175,9],\"els\":[\"0:391:180\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[175,10,175,20],\"els\":[\"0:391:180\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[175,20,175,21],\"els\":[\"0:391:180\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[178,3,178,9],\"els\":[\"0:394\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[178,10,178,32],\"els\":[\"0:394\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[178,32,178,33],\"els\":[\"0:394\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[181,3,181,9],\"els\":[\"0:365\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[181,10,181,41],\"els\":[\"0:365\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[181,41,181,42],\"els\":[\"0:365\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[184,3,184,9],\"els\":[\"0:359\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[184,10,184,25],\"els\":[\"0:359\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[184,25,184,26],\"els\":[\"0:359\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[187,3,187,9],\"els\":[\"0:363\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[187,10,187,35],\"els\":[\"0:363\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[187,35,187,36],\"els\":[\"0:363\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[190,3,190,9],\"els\":[\"0:363\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[190,10,190,35],\"els\":[\"0:363\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[190,35,190,36],\"els\":[\"0:363\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[193,3,193,9],\"els\":[\"0:361\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[193,10,193,22],\"els\":[\"0:361\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[193,22,193,23],\"els\":[\"0:361\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[196,3,196,10],\"els\":[\"0:364\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[196,11,196,27],\"els\":[\"0:364\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[196,27,196,28],\"els\":[\"0:364\"],\"ct\":{\"0\":2,\"1\":1}}]},\"0\":{\"records\":[{\"tk\":[109,3,109,29],\"els\":[\"0:405#out:1\"]},{\"tk\":[109,30,109,51],\"els\":[\"0:405#out:1\"]},{\"tk\":[109,52,109,53],\"els\":[\"0:405#out:1\",\"0:405\",\"1:4576-4618,#206\"]},{\"tk\":[109,54,109,64],\"els\":[\"1:4580-4618,#206\",\"0:405\"]},{\"tk\":[109,65,109,68],\"els\":[\"1:4606-4617,#206\",\"0:405\"]},{\"tk\":[117,3,117,29],\"els\":[\"0:399:198#out:1\"]},{\"tk\":[117,30,117,34],\"els\":[\"0:399:198#out:1\"]},{\"tk\":[117,35,117,36],\"els\":[\"0:399:198#out:1\",\"0:399:198\"]},{\"tk\":[118,7,118,33],\"els\":[\"0:332\"]},{\"tk\":[118,34,118,51],\"els\":[\"0:332\"]},{\"tk\":[118,52,118,53],\"els\":[\"0:330\"]},{\"tk\":[119,7,119,37],\"els\":[\"0:333\"]},{\"tk\":[119,38,119,67],\"els\":[\"0:333\"]},{\"tk\":[119,69,119,70],\"els\":[\"0:400\"]},{\"tk\":[120,6,120,32],\"els\":[\"0:332\"]},{\"tk\":[120,33,120,50],\"els\":[\"0:332\"]},{\"tk\":[120,52,120,53],\"els\":[\"0:399:198\"]},{\"tk\":[121,5,121,31],\"els\":[\"0:399:198\"]},{\"tk\":[121,32,121,41],\"els\":[\"0:399:198\"]},{\"tk\":[131,3,131,20],\"els\":[\"2:1272-1321,#124\",\"0:407\"]},{\"tk\":[131,22,131,25],\"els\":[\"2:1064-1067,#124\"]},{\"tk\":[131,25,131,26],\"els\":[\"2:1272-1321,#124\",\"0:407\"]},{\"tk\":[131,26,131,27],\"els\":[\"2:1272-1321,#124\",\"0:407\"]},{\"tk\":[149,3,149,29],\"els\":[\"0:398:198#out:1\"]},{\"tk\":[149,30,149,36],\"els\":[\"0:398:198#out:1\"]},{\"tk\":[149,37,149,38],\"els\":[\"0:398:198#out:1\",\"0:398:198\"]},{\"tk\":[149,41,149,54],\"els\":[\"0:335\",\"0:341\",\"0:343\"]},{\"tk\":[150,5,150,6],\"els\":[\"0:335\",\"0:341\",\"0:343\"]},{\"tk\":[150,6,150,32],\"els\":[\"0:335\",\"0:341\",\"0:343\"]},{\"tk\":[150,32,150,33],\"els\":[\"0:335\",\"0:341\",\"0:343\"]},{\"tk\":[150,33,150,59],\"els\":[\"0:335\",\"0:341\",\"0:343\"]},{\"tk\":[150,60,150,61],\"els\":[\"0:335\",\"0:341\",\"0:343\"]},{\"tk\":[150,62,150,63],\"els\":[\"0:335\",\"0:341\",\"0:343\",\"0:324\"]},{\"tk\":[150,63,150,69],\"els\":[\"0:335\",\"0:341\",\"0:343\"]},{\"tk\":[150,69,150,70],\"els\":[\"0:335\",\"0:341\",\"0:343\"]},{\"tk\":[150,70,150,73],\"els\":[\"0:335\",\"0:341\",\"0:343\",\"2:1064-1067,#124\"]},{\"tk\":[150,73,150,74],\"els\":[\"0:335\",\"0:341\",\"0:343\",\"0:407\",\"2:1486-1489,#124\"]},{\"tk\":[150,74,150,75],\"els\":[\"0:335\",\"0:341\",\"0:343\",\"0:407\",\"2:1486-1489,#124\"]},{\"tk\":[150,75,150,76],\"els\":[\"0:335\",\"0:341\",\"0:343\"]},{\"tk\":[150,76,150,77],\"els\":[\"0:335\",\"0:341\",\"0:343\"]},{\"tk\":[151,6,151,32],\"els\":[\"0:335\",\"0:341\",\"0:343\"]},{\"tk\":[151,32,151,33],\"els\":[\"0:335\",\"0:341\",\"0:343\"]},{\"tk\":[151,33,151,59],\"els\":[\"0:335\",\"0:341\",\"0:343\"]},{\"tk\":[151,60,151,61],\"els\":[\"0:335\",\"0:341\",\"0:343\"]},{\"tk\":[151,62,151,63],\"els\":[\"0:335\",\"0:341\",\"0:343\",\"0:325\"]},{\"tk\":[151,63,151,69],\"els\":[\"0:335\",\"0:341\",\"0:343\"]},{\"tk\":[151,69,151,70],\"els\":[\"0:335\",\"0:341\",\"0:343\"]},{\"tk\":[151,70,151,73],\"els\":[\"0:335\",\"0:341\",\"0:343\",\"2:1064-1067,#124\"]},{\"tk\":[151,73,151,74],\"els\":[\"0:335\",\"0:341\",\"0:343\",\"0:407\",\"2:1515-1518,#124\"]},{\"tk\":[151,74,151,75],\"els\":[\"0:335\",\"0:341\",\"0:343\",\"0:407\",\"2:1515-1518,#124\"]},{\"tk\":[151,75,151,76],\"els\":[\"0:335\",\"0:341\",\"0:343\"]},{\"tk\":[151,76,151,77],\"els\":[\"0:335\",\"0:341\",\"0:343\"]},{\"tk\":[151,78,151,79],\"els\":[\"0:396\"]},{\"tk\":[152,5,152,31],\"els\":[\"0:397\"]},{\"tk\":[152,32,152,60],\"els\":[\"0:397\"]},{\"tk\":[152,62,152,63],\"els\":[\"0:331\"]},{\"tk\":[153,5,153,31],\"els\":[\"0:332\"]},{\"tk\":[153,32,153,49],\"els\":[\"0:332\"]},{\"tk\":[153,51,153,52],\"els\":[\"0:398:198\"]},{\"tk\":[154,5,154,31],\"els\":[\"0:398:198\"]},{\"tk\":[154,32,154,43],\"els\":[\"0:398:198\"]},{\"tk\":[157,3,157,5],\"els\":[\"0:401\"]},{\"tk\":[157,7,157,37],\"els\":[\"0:401\"]},{\"tk\":[157,38,157,50],\"els\":[\"0:401\"]},{\"tk\":[157,51,157,53],\"els\":[\"0:401\"]},{\"tk\":[157,54,157,56],\"els\":[\"0:401\"]},{\"tk\":[158,5,158,15],\"els\":[\"0:364#out:1\"]},{\"tk\":[158,16,158,17],\"els\":[\"0:401\"]},{\"tk\":[158,18,158,44],\"els\":[\"0:401\"]},{\"tk\":[158,45,158,58],\"els\":[\"0:401\"]},{\"tk\":[158,59,158,60],\"els\":[\"0:401\"]},{\"tk\":[159,7,159,8],\"els\":[\"0:401\"]},{\"tk\":[159,8,159,9],\"els\":[\"0:401\"]},{\"tk\":[159,9,159,35],\"els\":[\"0:401\"]},{\"tk\":[159,35,159,37],\"els\":[\"0:401\"]},{\"tk\":[159,37,159,43],\"els\":[\"0:401\"]},{\"tk\":[159,43,159,44],\"els\":[\"0:401\"]},{\"tk\":[159,44,159,54],\"els\":[\"0:401\"]},{\"tk\":[159,54,159,55],\"els\":[\"0:401\"]},{\"tk\":[159,56,159,57],\"els\":[\"0:401\"]},{\"tk\":[159,58,159,62],\"els\":[\"0:401\"]},{\"tk\":[159,62,159,63],\"els\":[\"0:401\"]},{\"tk\":[160,5,160,35],\"els\":[\"0:401\"]},{\"tk\":[160,36,160,43],\"els\":[\"0:401\"]},{\"tk\":[160,44,160,45],\"els\":[\"0:401\"]},{\"tk\":[160,46,160,49],\"els\":[\"0:401\"]},{\"tk\":[160,50,160,60],\"els\":[\"0:364#out:1\"]},{\"tk\":[161,5,161,35],\"els\":[\"0:401\"]},{\"tk\":[161,36,161,43],\"els\":[\"0:401\"]},{\"tk\":[161,44,161,45],\"els\":[\"0:401\"]},{\"tk\":[161,46,161,49],\"els\":[\"0:401\"]},{\"tk\":[162,5,162,35],\"els\":[\"0:401\"]},{\"tk\":[162,36,162,48],\"els\":[\"0:401\"]},{\"tk\":[162,49,162,50],\"els\":[\"0:401\"]},{\"tk\":[162,51,162,53],\"els\":[\"0:401\"]},{\"tk\":[166,3,166,29],\"els\":[\"0:401#out:1\"]},{\"tk\":[166,30,166,38],\"els\":[\"0:401#out:1\"]},{\"tk\":[166,39,166,40],\"els\":[\"0:401#out:1\",\"0:401\"]},{\"tk\":[166,43,166,73],\"els\":[\"0:401\"]},{\"tk\":[166,74,166,81],\"els\":[\"0:401\"]},{\"tk\":[167,5,167,6],\"els\":[\"0:401\"]},{\"tk\":[167,7,167,33],\"els\":[\"0:401\"]},{\"tk\":[167,34,167,47],\"els\":[\"0:401\"]},{\"tk\":[167,48,167,49],\"els\":[\"0:401\"]},{\"tk\":[168,5,168,35],\"els\":[\"0:401\"]},{\"tk\":[168,36,168,43],\"els\":[\"0:401\"]},{\"tk\":[168,44,168,45],\"els\":[\"0:401\"]},{\"tk\":[169,5,169,31],\"els\":[\"0:401\"]},{\"tk\":[169,32,169,45],\"els\":[\"0:401\"]},{\"tk\":[169,47,169,48],\"els\":[\"0:401\"]},{\"tk\":[170,5,170,31],\"els\":[\"0:401\"]},{\"tk\":[170,32,170,45],\"els\":[\"0:401\"]},{\"tk\":[170,46,170,47],\"els\":[\"0:401\"]},{\"tk\":[171,6,171,36],\"els\":[\"0:401\"]},{\"tk\":[171,37,171,44],\"els\":[\"0:401\"]},{\"tk\":[171,45,171,46],\"els\":[\"0:401\"]},{\"tk\":[172,6,172,32],\"els\":[\"0:401\"]},{\"tk\":[172,33,172,46],\"els\":[\"0:401\"]},{\"tk\":[172,47,172,48],\"els\":[\"0:401\"]},{\"tk\":[173,6,173,36],\"els\":[\"0:401\"]},{\"tk\":[173,37,173,44],\"els\":[\"0:401\"]},{\"tk\":[173,45,173,46],\"els\":[\"0:401\"]},{\"tk\":[174,6,174,32],\"els\":[\"0:401\"]},{\"tk\":[174,33,174,46],\"els\":[\"0:401\"]},{\"tk\":[174,48,174,49],\"els\":[\"0:401\"]},{\"tk\":[175,5,175,31],\"els\":[\"0:401\"]},{\"tk\":[175,32,175,45],\"els\":[\"0:401\"]},{\"tk\":[175,47,175,48],\"els\":[\"0:401\"]},{\"tk\":[176,5,176,31],\"els\":[\"0:401\"]},{\"tk\":[176,32,176,44],\"els\":[\"0:401\"]},{\"tk\":[176,45,176,46],\"els\":[\"0:401\"]},{\"tk\":[177,5,177,31],\"els\":[\"0:401\"]},{\"tk\":[177,32,177,45],\"els\":[\"0:401\"]},{\"tk\":[187,3,187,19],\"els\":[\"3:2037-2085,#155\",\"0:406\"]},{\"tk\":[187,21,187,24],\"els\":[\"2:1064-1067,#124\"]},{\"tk\":[187,24,187,25],\"els\":[\"3:2037-2085,#155\",\"0:406\"]},{\"tk\":[187,25,187,26],\"els\":[\"3:2037-2085,#155\",\"0:406\"]},{\"tk\":[194,3,194,5],\"els\":[\"0:356\"]},{\"tk\":[194,6,194,7],\"els\":[\"0:365\"]},{\"tk\":[194,8,194,13],\"els\":[\"0:365\"]},{\"tk\":[194,14,194,40],\"els\":[\"0:365\"]},{\"tk\":[194,41,194,72],\"els\":[\"0:365\"]},{\"tk\":[194,73,194,74],\"els\":[\"0:365\"]},{\"tk\":[195,14,195,40],\"els\":[\"0:365\"]},{\"tk\":[195,41,195,49],\"els\":[\"0:365\"]},{\"tk\":[196,3,196,5],\"els\":[\"0:365\"]},{\"tk\":[196,7,196,14],\"els\":[\"0:365\"]},{\"tk\":[196,15,196,17],\"els\":[\"0:356\"]},{\"tk\":[196,19,196,21],\"els\":[\"0:365\"]},{\"tk\":[196,22,196,29],\"els\":[\"0:365\"]},{\"tk\":[196,30,196,32],\"els\":[\"0:356\"]},{\"tk\":[197,5,197,7],\"els\":[\"0:356\"]},{\"tk\":[197,8,197,9],\"els\":[\"0:365\"]},{\"tk\":[197,10,197,13],\"els\":[\"0:365\"]},{\"tk\":[199,5,199,7],\"els\":[\"0:356\"]},{\"tk\":[199,8,199,9],\"els\":[\"0:365\"]},{\"tk\":[199,10,199,14],\"els\":[\"0:365\"]},{\"tk\":[199,15,199,17],\"els\":[\"0:356\"]},{\"tk\":[199,19,199,26],\"els\":[\"0:365\"]},{\"tk\":[202,3,202,10],\"els\":[\"0:353#out:1\"]},{\"tk\":[202,11,202,12],\"els\":[\"0:365\"]},{\"tk\":[202,13,202,15],\"els\":[\"0:356\"]},{\"tk\":[202,16,202,17],\"els\":[\"0:365\"]},{\"tk\":[202,18,202,21],\"els\":[\"0:365\"]},{\"tk\":[202,22,202,23],\"els\":[\"0:365\"]},{\"tk\":[202,24,202,25],\"els\":[\"0:365\"]},{\"tk\":[202,25,202,26],\"els\":[\"0:365\"]},{\"tk\":[202,34,202,35],\"els\":[\"0:365\"]},{\"tk\":[202,44,202,45],\"els\":[\"0:365\"]},{\"tk\":[202,45,202,47],\"els\":[\"0:356\"]},{\"tk\":[202,50,202,51],\"els\":[\"0:365\"]},{\"tk\":[202,59,202,60],\"els\":[\"0:365\"]},{\"tk\":[202,69,202,71],\"els\":[\"0:356\"]},{\"tk\":[210,3,210,5],\"els\":[\"0:364\"]},{\"tk\":[210,7,210,14],\"els\":[\"0:353#out:1\"]},{\"tk\":[210,15,210,17],\"els\":[\"0:364\"]},{\"tk\":[210,18,210,44],\"els\":[\"0:364\"]},{\"tk\":[210,45,210,61],\"els\":[\"0:364\"]},{\"tk\":[211,5,211,15],\"els\":[\"0:364#out:1\"]},{\"tk\":[211,16,211,17],\"els\":[\"0:364\"]},{\"tk\":[211,18,211,44],\"els\":[\"0:358\"]},{\"tk\":[211,45,211,60],\"els\":[\"0:358\"]},{\"tk\":[213,5,213,15],\"els\":[\"0:364#out:1\"]},{\"tk\":[213,16,213,17],\"els\":[\"0:364\"]},{\"tk\":[213,18,213,44],\"els\":[\"0:357\"]},{\"tk\":[213,45,213,60],\"els\":[\"0:357\"]},{\"tk\":[219,3,219,5],\"els\":[\"0:356\"]},{\"tk\":[219,6,219,7],\"els\":[\"0:360\"]},{\"tk\":[219,8,219,21],\"els\":[\"0:360\"]},{\"tk\":[219,21,219,22],\"els\":[\"0:360\"]},{\"tk\":[219,22,219,32],\"els\":[\"0:360\",\"0:364#out:1\"]},{\"tk\":[219,32,219,33],\"els\":[\"0:360\"]},{\"tk\":[220,3,220,5],\"els\":[\"0:360\"]},{\"tk\":[220,7,220,9],\"els\":[\"0:356\"]},{\"tk\":[220,10,220,11],\"els\":[\"0:360\"]},{\"tk\":[220,12,220,17],\"els\":[\"0:360\"]},{\"tk\":[221,5,221,7],\"els\":[\"0:360\"]},{\"tk\":[221,9,221,11],\"els\":[\"0:356\"]},{\"tk\":[221,12,221,14],\"els\":[\"0:360\"]},{\"tk\":[221,15,221,18],\"els\":[\"0:360\"]},{\"tk\":[222,11,222,12],\"els\":[\"0:360\"]},{\"tk\":[222,13,222,14],\"els\":[\"0:360\"]},{\"tk\":[222,22,222,24],\"els\":[\"0:356\"]},{\"tk\":[224,11,224,12],\"els\":[\"0:360\"]},{\"tk\":[224,13,224,15],\"els\":[\"0:360\"]},{\"tk\":[227,9,227,10],\"els\":[\"0:360\"]},{\"tk\":[227,11,227,22],\"els\":[\"0:360\"]},{\"tk\":[230,3,230,18],\"els\":[\"0:360\"]},{\"tk\":[230,19,230,20],\"els\":[\"0:360\"]},{\"tk\":[235,3,235,33],\"els\":[\"0:362\"]},{\"tk\":[235,34,235,39],\"els\":[\"0:362\"]},{\"tk\":[235,40,235,52],\"els\":[\"0:362\"]},{\"tk\":[235,53,235,66],\"els\":[\"0:362\"]},{\"tk\":[235,67,235,68],\"els\":[\"0:362\"]},{\"tk\":[236,5,236,21],\"els\":[\"0:362\"]},{\"tk\":[236,22,236,25],\"els\":[\"0:362\"]},{\"tk\":[239,3,239,5],\"els\":[\"0:353\"]},{\"tk\":[239,7,239,14],\"els\":[\"0:353#out:1\"]},{\"tk\":[239,15,239,16],\"els\":[\"0:353\"]},{\"tk\":[239,17,239,18],\"els\":[\"0:353\"]},{\"tk\":[240,5,240,12],\"els\":[\"0:353#out:1\"]},{\"tk\":[240,13,240,14],\"els\":[\"0:353\"]},{\"tk\":[240,15,240,16],\"els\":[\"0:353\"]},{\"tk\":[240,16,240,23],\"els\":[\"0:353#out:1\"]},{\"tk\":[247,3,247,5],\"els\":[\"0:356\"]},{\"tk\":[247,6,247,7],\"els\":[\"0:356\"]},{\"tk\":[247,8,247,34],\"els\":[\"0:359\"]},{\"tk\":[247,35,247,50],\"els\":[\"0:359\"]},{\"tk\":[247,51,247,52],\"els\":[\"0:356\"]},{\"tk\":[247,53,247,54],\"els\":[\"0:356\"]},{\"tk\":[247,61,247,68],\"els\":[\"0:353#out:1\"]},{\"tk\":[250,3,250,5],\"els\":[\"0:363\"]},{\"tk\":[250,7,250,9],\"els\":[\"0:356\"]},{\"tk\":[250,10,250,11],\"els\":[\"0:363\"]},{\"tk\":[250,12,250,38],\"els\":[\"0:363\"]},{\"tk\":[250,39,250,64],\"els\":[\"0:363\"]},{\"tk\":[251,5,251,7],\"els\":[\"0:356\"]},{\"tk\":[251,8,251,9],\"els\":[\"0:363\"]},{\"tk\":[251,10,251,36],\"els\":[\"0:363\"]},{\"tk\":[251,37,251,62],\"els\":[\"0:363\"]},{\"tk\":[252,10,252,12],\"els\":[\"0:363\"]},{\"tk\":[252,14,252,16],\"els\":[\"0:356\"]},{\"tk\":[252,17,252,18],\"els\":[\"0:363\"]},{\"tk\":[252,19,252,45],\"els\":[\"0:363\"]},{\"tk\":[252,46,252,71],\"els\":[\"0:363\"]},{\"tk\":[253,5,253,7],\"els\":[\"0:356\"]},{\"tk\":[253,8,253,9],\"els\":[\"0:363\"]},{\"tk\":[253,10,253,36],\"els\":[\"0:363\"]},{\"tk\":[253,37,253,62],\"els\":[\"0:363\"]},{\"tk\":[261,3,261,5],\"els\":[\"0:356\"]},{\"tk\":[261,6,261,7],\"els\":[\"0:354\"]},{\"tk\":[261,8,261,12],\"els\":[\"0:354\"]},{\"tk\":[261,13,261,39],\"els\":[\"0:361\"]},{\"tk\":[261,40,261,52],\"els\":[\"0:361\"]},{\"tk\":[261,53,261,54],\"els\":[\"0:361\"]},{\"tk\":[261,55,261,65],\"els\":[\"0:364#out:1\"]},{\"tk\":[261,66,261,67],\"els\":[\"0:355\"]},{\"tk\":[261,68,261,70],\"els\":[\"0:356\"]},{\"tk\":[264,3,264,5],\"els\":[\"0:362\"]},{\"tk\":[264,7,264,8],\"els\":[\"0:362\"]},{\"tk\":[264,9,264,11],\"els\":[\"0:356\"]},{\"tk\":[264,12,264,14],\"els\":[\"0:362\"]},{\"tk\":[264,15,264,20],\"els\":[\"0:362\"]},{\"tk\":[265,5,265,7],\"els\":[\"0:356\"]},{\"tk\":[265,8,265,9],\"els\":[\"0:362\"]},{\"tk\":[265,10,265,15],\"els\":[\"0:362\"]},{\"tk\":[269,3,269,22],\"els\":[\"0:362\"]},{\"tk\":[270,6,270,36],\"els\":[\"0:362\"]},{\"tk\":[270,37,270,42],\"els\":[\"0:362\"]},{\"tk\":[270,71,270,73],\"els\":[\"0:356\"]},{\"tk\":[280,3,280,33],\"els\":[\"0:333\"]},{\"tk\":[280,34,280,63],\"els\":[\"0:333\"]},{\"tk\":[280,64,280,66],\"els\":[\"0:333\"]},{\"tk\":[281,6,281,32],\"els\":[\"0:339\"]},{\"tk\":[281,33,281,58],\"els\":[\"0:339\"]},{\"tk\":[281,59,281,60],\"els\":[\"0:339\"]},{\"tk\":[281,61,281,62],\"els\":[\"0:323\"]},{\"tk\":[281,69,281,72],\"els\":[\"2:1064-1067,#124\"]},{\"tk\":[281,72,281,73],\"els\":[\"0:406\",\"3:2219-2222,#155\"]},{\"tk\":[281,73,281,74],\"els\":[\"0:406\",\"3:2219-2222,#155\"]},{\"tk\":[281,76,281,77],\"els\":[\"0:391:180\"]},{\"tk\":[282,6,282,32],\"els\":[\"0:391:180\"]},{\"tk\":[282,33,282,43],\"els\":[\"0:391:180\"]},{\"tk\":[282,44,282,45],\"els\":[\"0:395\"]},{\"tk\":[283,6,283,32],\"els\":[\"0:394\"]},{\"tk\":[283,33,283,55],\"els\":[\"0:394\"]},{\"tk\":[283,57,283,58],\"els\":[\"0:333\"]},{\"tk\":[284,5,284,31],\"els\":[\"0:333\"]},{\"tk\":[284,32,284,62],\"els\":[\"0:333\"]},{\"tk\":[287,3,287,13],\"els\":[\"0:364#out:1\"]},{\"tk\":[287,14,287,15],\"els\":[\"0:401\"]},{\"tk\":[287,16,287,46],\"els\":[\"0:401\"]},{\"tk\":[287,47,287,54],\"els\":[\"0:401\"]},{\"tk\":[288,3,288,33],\"els\":[\"0:401\"]},{\"tk\":[288,34,288,41],\"els\":[\"0:401\"]},{\"tk\":[288,42,288,43],\"els\":[\"0:401\"]},{\"tk\":[289,5,289,35],\"els\":[\"0:401\"]},{\"tk\":[289,36,289,43],\"els\":[\"0:401\"]},{\"tk\":[289,44,289,45],\"els\":[\"0:401\"]},{\"tk\":[290,5,290,31],\"els\":[\"0:401\"]},{\"tk\":[290,32,290,45],\"els\":[\"0:401\"]},{\"tk\":[290,46,290,47],\"els\":[\"0:401\"]},{\"tk\":[291,5,291,35],\"els\":[\"0:401\"]},{\"tk\":[291,36,291,43],\"els\":[\"0:401\"]},{\"tk\":[291,44,291,45],\"els\":[\"0:401\"]},{\"tk\":[292,5,292,31],\"els\":[\"0:401\"]},{\"tk\":[292,32,292,45],\"els\":[\"0:401\"]},{\"tk\":[293,3,293,33],\"els\":[\"0:401\"]},{\"tk\":[293,34,293,41],\"els\":[\"0:401\"]},{\"tk\":[293,42,293,43],\"els\":[\"0:401\"]},{\"tk\":[294,5,294,35],\"els\":[\"0:401\"]},{\"tk\":[294,36,294,43],\"els\":[\"0:401\"]},{\"tk\":[294,44,294,45],\"els\":[\"0:401\"]},{\"tk\":[295,5,295,31],\"els\":[\"0:401\"]},{\"tk\":[295,32,295,45],\"els\":[\"0:401\"]},{\"tk\":[295,46,295,47],\"els\":[\"0:401\"]},{\"tk\":[295,48,295,58],\"els\":[\"0:364#out:1\"]},{\"tk\":[295,59,295,60],\"els\":[\"0:401\"]},{\"tk\":[296,5,296,31],\"els\":[\"0:401\"]},{\"tk\":[296,32,296,45],\"els\":[\"0:401\"]},{\"tk\":[364,3,364,33],\"els\":[\"0:405\"]},{\"tk\":[364,34,364,39],\"els\":[\"0:405\"]},{\"tk\":[364,40,364,62],\"els\":[\"0:405\"]},{\"tk\":[364,63,364,64],\"els\":[\"0:405\"]},{\"tk\":[364,65,364,70],\"els\":[\"0:405\"]},{\"tk\":[394,3,394,33],\"els\":[\"0:405\"]},{\"tk\":[394,34,394,39],\"els\":[\"0:405\"]},{\"tk\":[394,40,394,53],\"els\":[\"0:405\"]},{\"tk\":[394,54,394,55],\"els\":[\"0:405\"]},{\"tk\":[394,56,394,58],\"els\":[\"0:405\"]},{\"tk\":[404,3,404,11],\"els\":[\"1:4089-4145,#178\",\"0:405\"]},{\"tk\":[404,12,404,15],\"els\":[\"1:4113-4124,#178\",\"0:405\"]},{\"tk\":[404,17,404,21],\"els\":[\"1:4126-4134,#178\",\"0:405\"]},{\"tk\":[404,23,404,27],\"els\":[\"1:4136-4144,#178\",\"0:405\"]},{\"tk\":[411,3,411,33],\"els\":[\"0:405\"]},{\"tk\":[411,34,411,39],\"els\":[\"0:405\"]},{\"tk\":[411,40,411,55],\"els\":[\"0:405\"]},{\"tk\":[411,56,411,57],\"els\":[\"0:405\"]},{\"tk\":[411,58,411,62],\"els\":[\"0:405\"]},{\"tk\":[416,3,416,33],\"els\":[\"0:407\"]},{\"tk\":[416,34,416,37],\"els\":[\"0:407\"]},{\"tk\":[416,38,416,60],\"els\":[\"0:407\"]},{\"tk\":[416,61,416,62],\"els\":[\"0:407\"]},{\"tk\":[416,63,416,68],\"els\":[\"0:407\"]},{\"tk\":[417,3,417,33],\"els\":[\"0:407\"]},{\"tk\":[417,34,417,37],\"els\":[\"0:407\"]},{\"tk\":[417,38,417,51],\"els\":[\"0:407\"]},{\"tk\":[417,52,417,53],\"els\":[\"0:407\"]},{\"tk\":[417,54,417,56],\"els\":[\"0:407\"]},{\"tk\":[424,3,424,20],\"els\":[\"2:798-830,#96\",\"0:407\"]},{\"tk\":[425,3,425,33],\"els\":[\"0:407\"]},{\"tk\":[425,34,425,37],\"els\":[\"0:407\"]},{\"tk\":[425,38,425,53],\"els\":[\"0:407\"]},{\"tk\":[425,54,425,55],\"els\":[\"0:407\"]},{\"tk\":[425,56,425,60],\"els\":[\"0:407\"]},{\"tk\":[434,3,434,33],\"els\":[\"0:406\"]},{\"tk\":[434,34,434,39],\"els\":[\"0:406\"]},{\"tk\":[434,40,434,62],\"els\":[\"0:406\"]},{\"tk\":[434,63,434,64],\"els\":[\"0:406\"]},{\"tk\":[434,65,434,70],\"els\":[\"0:406\"]},{\"tk\":[444,3,444,33],\"els\":[\"0:406\"]},{\"tk\":[444,34,444,39],\"els\":[\"0:406\"]},{\"tk\":[444,40,444,53],\"els\":[\"0:406\"]},{\"tk\":[444,54,444,55],\"els\":[\"0:406\"]},{\"tk\":[444,56,444,58],\"els\":[\"0:406\"]},{\"tk\":[452,3,452,19],\"els\":[\"3:1559-1604,#127\",\"0:406\"]},{\"tk\":[452,20,452,23],\"els\":[\"3:1591-1603,#127\",\"0:406\"]},{\"tk\":[453,3,453,33],\"els\":[\"0:406\"]},{\"tk\":[453,34,453,39],\"els\":[\"0:406\"]},{\"tk\":[453,40,453,55],\"els\":[\"0:406\"]},{\"tk\":[453,56,453,57],\"els\":[\"0:406\"]},{\"tk\":[453,58,453,62],\"els\":[\"0:406\"]},{\"tk\":[456,3,456,33],\"els\":[\"0:360\"]},{\"tk\":[456,34,456,39],\"els\":[\"0:360\"]},{\"tk\":[456,40,456,62],\"els\":[\"0:360\"]},{\"tk\":[456,63,456,64],\"els\":[\"0:360\"]},{\"tk\":[456,65,456,70],\"els\":[\"0:360\"]},{\"tk\":[457,3,457,33],\"els\":[\"0:360\"]},{\"tk\":[457,34,457,39],\"els\":[\"0:360\"]},{\"tk\":[457,40,457,53],\"els\":[\"0:360\"]},{\"tk\":[457,54,457,55],\"els\":[\"0:360\"]},{\"tk\":[457,56,457,58],\"els\":[\"0:360\"]},{\"tk\":[458,3,458,17],\"els\":[\"0:360\"]},{\"tk\":[458,18,458,19],\"els\":[\"0:360\"]},{\"tk\":[458,21,458,22],\"els\":[\"0:360\"]},{\"tk\":[459,3,459,33],\"els\":[\"0:360\"]},{\"tk\":[459,34,459,39],\"els\":[\"0:360\"]},{\"tk\":[459,40,459,55],\"els\":[\"0:360\"]},{\"tk\":[459,56,459,57],\"els\":[\"0:360\"]},{\"tk\":[459,58,459,62],\"els\":[\"0:360\"]},{\"tk\":[462,3,462,33],\"els\":[\"0:362\"]},{\"tk\":[462,34,462,39],\"els\":[\"0:362\"]},{\"tk\":[462,40,462,62],\"els\":[\"0:362\"]},{\"tk\":[462,63,462,64],\"els\":[\"0:362\"]},{\"tk\":[462,65,462,70],\"els\":[\"0:362\"]},{\"tk\":[463,3,463,33],\"els\":[\"0:362\"]},{\"tk\":[463,34,463,39],\"els\":[\"0:362\"]},{\"tk\":[463,40,463,53],\"els\":[\"0:362\"]},{\"tk\":[463,54,463,55],\"els\":[\"0:362\"]},{\"tk\":[463,56,463,58],\"els\":[\"0:362\"]},{\"tk\":[464,3,464,33],\"els\":[\"0:362\"]},{\"tk\":[464,34,464,39],\"els\":[\"0:362\"]},{\"tk\":[464,40,464,52],\"els\":[\"0:362\"]},{\"tk\":[464,53,464,66],\"els\":[\"0:362\"]},{\"tk\":[464,67,464,68],\"els\":[\"0:362\"]},{\"tk\":[464,69,464,80],\"els\":[\"0:362\"]},{\"tk\":[465,6,465,9],\"els\":[\"0:362\"]},{\"tk\":[465,11,465,14],\"els\":[\"0:362\"]},{\"tk\":[465,16,465,19],\"els\":[\"0:362\"]},{\"tk\":[466,3,466,33],\"els\":[\"0:362\"]},{\"tk\":[466,34,466,39],\"els\":[\"0:362\"]},{\"tk\":[466,40,466,55],\"els\":[\"0:362\"]},{\"tk\":[466,56,466,57],\"els\":[\"0:362\"]},{\"tk\":[466,58,466,62],\"els\":[\"0:362\"]},{\"tk\":[469,3,469,33],\"els\":[\"0:333\"]},{\"tk\":[469,34,469,63],\"els\":[\"0:333\"]},{\"tk\":[469,64,469,65],\"els\":[\"0:333\"]},{\"tk\":[470,5,470,31],\"els\":[\"0:333\"]},{\"tk\":[470,32,470,57],\"els\":[\"0:333\"]},{\"tk\":[473,3,473,33],\"els\":[\"0:401\"]},{\"tk\":[473,34,473,46],\"els\":[\"0:401\"]},{\"tk\":[473,47,473,48],\"els\":[\"0:401\"]},{\"tk\":[473,49,473,51],\"els\":[\"0:401\"]},{\"tk\":[480,3,480,5],\"els\":[\"0:405\"]},{\"tk\":[480,7,480,8],\"els\":[\"0:405\"]},{\"tk\":[480,8,480,38],\"els\":[\"0:405\"]},{\"tk\":[480,39,480,44],\"els\":[\"0:405\"]},{\"tk\":[481,5,481,35],\"els\":[\"0:405\"]},{\"tk\":[481,36,481,41],\"els\":[\"0:405\"]},{\"tk\":[481,42,481,64],\"els\":[\"0:405\"]},{\"tk\":[481,65,481,66],\"els\":[\"0:405\"]},{\"tk\":[481,67,481,71],\"els\":[\"0:405\"]},{\"tk\":[486,3,486,5],\"els\":[\"0:407\"]},{\"tk\":[486,7,486,8],\"els\":[\"0:407\"]},{\"tk\":[486,8,486,38],\"els\":[\"0:407\"]},{\"tk\":[486,39,486,42],\"els\":[\"0:407\"]},{\"tk\":[487,5,487,35],\"els\":[\"0:407\"]},{\"tk\":[487,36,487,39],\"els\":[\"0:407\"]},{\"tk\":[487,40,487,62],\"els\":[\"0:407\"]},{\"tk\":[487,63,487,64],\"els\":[\"0:407\"]},{\"tk\":[487,65,487,69],\"els\":[\"0:407\"]},{\"tk\":[492,3,492,5],\"els\":[\"0:406\"]},{\"tk\":[492,7,492,8],\"els\":[\"0:406\"]},{\"tk\":[492,8,492,38],\"els\":[\"0:406\"]},{\"tk\":[492,39,492,44],\"els\":[\"0:406\"]},{\"tk\":[493,5,493,35],\"els\":[\"0:406\"]},{\"tk\":[493,36,493,41],\"els\":[\"0:406\"]},{\"tk\":[493,42,493,64],\"els\":[\"0:406\"]},{\"tk\":[493,65,493,66],\"els\":[\"0:406\"]},{\"tk\":[493,67,493,71],\"els\":[\"0:406\"]},{\"tk\":[499,3,499,5],\"els\":[\"0:360\"]},{\"tk\":[499,7,499,8],\"els\":[\"0:360\"]},{\"tk\":[499,8,499,38],\"els\":[\"0:360\"]},{\"tk\":[499,39,499,44],\"els\":[\"0:360\"]},{\"tk\":[500,5,500,35],\"els\":[\"0:360\"]},{\"tk\":[500,36,500,41],\"els\":[\"0:360\"]},{\"tk\":[500,42,500,64],\"els\":[\"0:360\"]},{\"tk\":[500,65,500,66],\"els\":[\"0:360\"]},{\"tk\":[500,67,500,71],\"els\":[\"0:360\"]},{\"tk\":[506,3,506,5],\"els\":[\"0:362\"]},{\"tk\":[506,7,506,8],\"els\":[\"0:362\"]},{\"tk\":[506,8,506,38],\"els\":[\"0:362\"]},{\"tk\":[506,39,506,44],\"els\":[\"0:362\"]},{\"tk\":[507,5,507,35],\"els\":[\"0:362\"]},{\"tk\":[507,36,507,41],\"els\":[\"0:362\"]},{\"tk\":[507,42,507,64],\"els\":[\"0:362\"]},{\"tk\":[507,65,507,66],\"els\":[\"0:362\"]},{\"tk\":[507,67,507,71],\"els\":[\"0:362\"]},{\"tk\":[508,5,508,7],\"els\":[\"0:362\"]},{\"tk\":[508,10,508,40],\"els\":[\"0:362\"]},{\"tk\":[508,41,508,46],\"els\":[\"0:362\"]},{\"tk\":[508,61,508,63],\"els\":[\"0:362\"]},{\"tk\":[508,64,508,66],\"els\":[\"0:362\"]},{\"tk\":[508,68,508,70],\"els\":[\"0:362\"]},{\"tk\":[509,9,509,39],\"els\":[\"0:362\"]},{\"tk\":[509,40,509,45],\"els\":[\"0:362\"]},{\"tk\":[510,7,510,37],\"els\":[\"0:362\"]},{\"tk\":[510,38,510,43],\"els\":[\"0:362\"]},{\"tk\":[510,44,510,56],\"els\":[\"0:362\"]},{\"tk\":[510,57,510,70],\"els\":[\"0:362\"]},{\"tk\":[510,71,510,72],\"els\":[\"0:362\"]},{\"tk\":[511,9,511,25],\"els\":[\"0:362\"]},{\"tk\":[511,26,511,29],\"els\":[\"0:362\"]},{\"tk\":[512,7,512,26],\"els\":[\"0:362\"]},{\"tk\":[513,10,513,40],\"els\":[\"0:362\"]},{\"tk\":[513,41,513,46],\"els\":[\"0:362\"]},{\"tk\":[513,75,513,78],\"els\":[\"0:362\"]},{\"tk\":[514,7,514,37],\"els\":[\"0:362\"]},{\"tk\":[514,38,514,43],\"els\":[\"0:362\"]},{\"tk\":[514,44,514,56],\"els\":[\"0:362\"]},{\"tk\":[514,57,514,70],\"els\":[\"0:362\"]},{\"tk\":[514,71,514,72],\"els\":[\"0:362\"]},{\"tk\":[515,9,515,25],\"els\":[\"0:362\"]},{\"tk\":[515,26,515,29],\"els\":[\"0:362\"]},{\"tk\":[516,7,516,19],\"els\":[\"0:362\"]},{\"tk\":[517,10,517,40],\"els\":[\"0:362\"]},{\"tk\":[517,41,517,46],\"els\":[\"0:362\"]}]}}}","blocks":[{"RTWName":"<S1>/volt","SIDString":"LabB_CheckCommunications:352"},{"RTWName":"<S1>/Abs","SIDString":"LabB_CheckCommunications:353"},{"RTWName":"<S1>/Abs3","SIDString":"LabB_CheckCommunications:354"},{"RTWName":"<S1>/Accelerometer","SIDString":"LabB_CheckCommunications:407"},{"RTWName":"<S1>/Add1","SIDString":"LabB_CheckCommunications:355"},{"RTWName":"<S1>/Add2","SIDString":"LabB_CheckCommunications:356"},{"RTWName":"<S1>/Byte Packing ","SIDString":"LabB_CheckCommunications:367"},{"RTWName":"<S1>/Constant1","SIDString":"LabB_CheckCommunications:357"},{"RTWName":"<S1>/Constant2","SIDString":"LabB_CheckCommunications:358"},{"RTWName":"<S1>/Constant3","SIDString":"LabB_CheckCommunications:359"},{"RTWName":"<S1>/Data Type Conversion","SIDString":"LabB_CheckCommunications:323"},{"RTWName":"<S1>/Data Type Conversion1","SIDString":"LabB_CheckCommunications:324"},{"RTWName":"<S1>/Data Type Conversion2","SIDString":"LabB_CheckCommunications:325"},{"RTWName":"<S1>/Data Type Conversion3","SIDString":"LabB_CheckCommunications:375"},{"RTWName":"<S1>/Data Type Conversion5","SIDString":"LabB_CheckCommunications:377"},{"RTWName":"<S4>/Degrees\nin","SIDString":"LabB_CheckCommunications:391:179"},{"RTWName":"<S4>/Gain1","SIDString":"LabB_CheckCommunications:391:180"},{"RTWName":"<S4>/Radians\nout","SIDString":"LabB_CheckCommunications:391:181"},{"RTWName":"<S1>/Digital Output1","SIDString":"LabB_CheckCommunications:360"},{"RTWName":"<S1>/Gain1","SIDString":"LabB_CheckCommunications:361"},{"RTWName":"<S1>/Gyroscope","SIDString":"LabB_CheckCommunications:406"},{"RTWName":"<S1>/M2V3 Left Connector 18, 19","SIDString":"LabB_CheckCommunications:405"},{"RTWName":"<S1>/PWM","SIDString":"LabB_CheckCommunications:362"},{"RTWName":"<S1>/Saturation\n0 to 255","SIDString":"LabB_CheckCommunications:363"},{"RTWName":"<S1>/Serial Transmit","SIDString":"LabB_CheckCommunications:369"},{"RTWName":"<S1>/Sum","SIDString":"LabB_CheckCommunications:330"},{"RTWName":"<S1>/Sum1","SIDString":"LabB_CheckCommunications:331"},{"RTWName":"<S1>/Sum2","SIDString":"LabB_CheckCommunications:395"},{"RTWName":"<S1>/Sum3","SIDString":"LabB_CheckCommunications:396"},{"RTWName":"<S1>/Sum4","SIDString":"LabB_CheckCommunications:400"},{"RTWName":"<S1>/Switch","SIDString":"LabB_CheckCommunications:364"},{"RTWName":"<S1>/accelerometer angle bias","SIDString":"LabB_CheckCommunications:397"},{"RTWName":"<S1>/angle offset","SIDString":"LabB_CheckCommunications:332"},{"RTWName":"<S1>/angular velocity to angle","SIDString":"LabB_CheckCommunications:333"},{"RTWName":"<S1>/conversion to duty cycle\n(convert to int)","SIDString":"LabB_CheckCommunications:365"},{"RTWName":"<S1>/g_y and g_z\nto angle in radians","SIDString":"LabB_CheckCommunications:335"},{"RTWName":"<S1>/gyro velocity bias","SIDString":"LabB_CheckCommunications:394"},{"RTWName":"<S1>/raw x velocity\nto deg. / sec.","SIDString":"LabB_CheckCommunications:339"},{"RTWName":"<S1>/raw y acceleration\nto g_y","SIDString":"LabB_CheckCommunications:341"},{"RTWName":"<S1>/raw z acceleration\nto g_z","SIDString":"LabB_CheckCommunications:343"},{"RTWName":"<S1>/angle from gyroscope\nin radians","SIDString":"LabB_CheckCommunications:345"},{"RTWName":"<S1>/angle from accelerometer\nin radians","SIDString":"LabB_CheckCommunications:346"},{"RTWName":"<S1>/encoder","SIDString":"LabB_CheckCommunications:392"},{"RTWName":"<S2>/Radians\nin","SIDString":"LabB_CheckCommunications:398:197"},{"RTWName":"<S2>/Gain","SIDString":"LabB_CheckCommunications:398:198"},{"RTWName":"<S2>/Degrees\nout","SIDString":"LabB_CheckCommunications:398:199"},{"RTWName":"<S3>/Radians\nin","SIDString":"LabB_CheckCommunications:399:197"},{"RTWName":"<S3>/Gain","SIDString":"LabB_CheckCommunications:399:198"},{"RTWName":"<S3>/Degrees\nout","SIDString":"LabB_CheckCommunications:399:199"},{"RTWName":"<Root>/Sine Wave","SIDString":"LabB_CheckCommunications:401"},{"RTWName":"<Root>/accelerometer","SIDString":"LabB_CheckCommunications:390"},{"RTWName":"<Root>/encoder","SIDString":"LabB_CheckCommunications:393"},{"RTWName":"<Root>/gyro","SIDString":"LabB_CheckCommunications:350"},{"RTWName":"<Root>/motor","SIDString":"LabB_CheckCommunications:402"},{"RTWName":"<Root>/Balancing Robot","SIDString":"LabB_CheckCommunications:312"},{"RTWName":"<S1>/Degrees to\nRadians","SIDString":"LabB_CheckCommunications:391"},{"RTWName":"<Root>/Radians\nto Degrees","SIDString":"LabB_CheckCommunications:398"},{"RTWName":"<Root>/Radians\nto Degrees1","SIDString":"LabB_CheckCommunications:399"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true,"showProtectedV2Report":true}};